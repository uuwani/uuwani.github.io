I"(¨<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#part-1-parallelism" id="markdown-toc-part-1-parallelism">Part 1: Parallelism</a>    <ul>
      <li><a href="#what-is-parallel-computing" id="markdown-toc-what-is-parallel-computing">What is parallel computing?</a></li>
      <li><a href="#parallelism-on-the-jvm" id="markdown-toc-parallelism-on-the-jvm">Parallelism on the JVM</a>        <ul>
          <li><a href="#definitions" id="markdown-toc-definitions">Definitions</a></li>
          <li><a href="#implementation" id="markdown-toc-implementation">Implementation</a></li>
        </ul>
      </li>
      <li><a href="#atomicity" id="markdown-toc-atomicity">Atomicity</a>        <ul>
          <li><a href="#synchronized-blocks" id="markdown-toc-synchronized-blocks">Synchronized blocks</a></li>
          <li><a href="#deadlocks" id="markdown-toc-deadlocks">Deadlocks</a>            <ul>
              <li><a href="#resolving-deadlocks" id="markdown-toc-resolving-deadlocks">Resolving deadlocks</a></li>
            </ul>
          </li>
          <li><a href="#memory-model" id="markdown-toc-memory-model">Memory model</a></li>
        </ul>
      </li>
      <li><a href="#running-computations-in-parallel" id="markdown-toc-running-computations-in-parallel">Running computations in parallel</a>        <ul>
          <li><a href="#signature-of-parallel" id="markdown-toc-signature-of-parallel">Signature of parallel</a></li>
          <li><a href="#underlying-hardware-architecture-affects-performance" id="markdown-toc-underlying-hardware-architecture-affects-performance">Underlying hardware architecture affects performance</a></li>
        </ul>
      </li>
      <li><a href="#tasks" id="markdown-toc-tasks">Tasks</a></li>
      <li><a href="#how-do-we-measure-performance" id="markdown-toc-how-do-we-measure-performance">How do we measure performance?</a>        <ul>
          <li><a href="#work-and-depth" id="markdown-toc-work-and-depth">Work and depth</a></li>
          <li><a href="#asymptotic-analysis" id="markdown-toc-asymptotic-analysis">Asymptotic analysis</a></li>
          <li><a href="#empirical-analysis-benchmarking" id="markdown-toc-empirical-analysis-benchmarking">Empirical analysis: Benchmarking</a></li>
        </ul>
      </li>
      <li><a href="#parallelizing-important-algorithms" id="markdown-toc-parallelizing-important-algorithms">Parallelizing important algorithms</a>        <ul>
          <li><a href="#parallel-merge-sort" id="markdown-toc-parallel-merge-sort">Parallel merge sort</a>            <ul>
              <li><a href="#copying-array-in-parallel" id="markdown-toc-copying-array-in-parallel">Copying array in parallel</a></li>
            </ul>
          </li>
          <li><a href="#parallel-map" id="markdown-toc-parallel-map">Parallel map</a>            <ul>
              <li><a href="#comparison-of-arrays-and-immutable-trees" id="markdown-toc-comparison-of-arrays-and-immutable-trees">Comparison of arrays and immutable trees</a></li>
            </ul>
          </li>
          <li><a href="#parallel-reduce" id="markdown-toc-parallel-reduce">Parallel reduce</a></li>
          <li><a href="#associative-andor-commutative-operations" id="markdown-toc-associative-andor-commutative-operations">Associative and/or commutative operations</a>            <ul>
              <li><a href="#making-an-operation-commutative-is-easy" id="markdown-toc-making-an-operation-commutative-is-easy">Making an operation commutative is easy</a></li>
              <li><a href="#constructing-associative-operations" id="markdown-toc-constructing-associative-operations">Constructing associative operations</a></li>
            </ul>
          </li>
          <li><a href="#parallel-scan" id="markdown-toc-parallel-scan">Parallel scan</a>            <ul>
              <li><a href="#on-trees" id="markdown-toc-on-trees">On trees</a></li>
              <li><a href="#on-arrays" id="markdown-toc-on-arrays">On arrays</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#data-parallelism" id="markdown-toc-data-parallelism">Data parallelism</a>        <ul>
          <li><a href="#workload" id="markdown-toc-workload">Workload</a></li>
          <li><a href="#parallel-for-loop" id="markdown-toc-parallel-for-loop">Parallel for-loop</a></li>
          <li><a href="#non-parallelizable-operations" id="markdown-toc-non-parallelizable-operations">Non-parallelizable operations</a></li>
          <li><a href="#parallelizable-operations" id="markdown-toc-parallelizable-operations">Parallelizable operations</a></li>
          <li><a href="#parallel-collections" id="markdown-toc-parallel-collections">Parallel collections</a>            <ul>
              <li><a href="#avoiding-parallel-errors" id="markdown-toc-avoiding-parallel-errors">Avoiding parallel errors</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#data-parallel-abstractions" id="markdown-toc-data-parallel-abstractions">Data-parallel abstractions</a>        <ul>
          <li><a href="#iterators" id="markdown-toc-iterators">Iterators</a></li>
          <li><a href="#splitters" id="markdown-toc-splitters">Splitters</a></li>
          <li><a href="#builders" id="markdown-toc-builders">Builders</a></li>
          <li><a href="#combiners" id="markdown-toc-combiners">Combiners</a>            <ul>
              <li><a href="#implementing-combiners" id="markdown-toc-implementing-combiners">Implementing combiners</a></li>
              <li><a href="#two-phase-construction" id="markdown-toc-two-phase-construction">Two-phase construction</a></li>
              <li><a href="#conc-trees" id="markdown-toc-conc-trees">Conc-Trees</a></li>
              <li><a href="#combiners-using-conc-trees" id="markdown-toc-combiners-using-conc-trees">Combiners using Conc-Trees</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#part-2-concurrent-programming" id="markdown-toc-part-2-concurrent-programming">Part 2: Concurrent programming</a>    <ul>
      <li><a href="#a-surprising-program" id="markdown-toc-a-surprising-program">A surprising program</a></li>
      <li><a href="#overview-of-threads" id="markdown-toc-overview-of-threads">Overview of threads</a>        <ul>
          <li><a href="#some-more-definitions" id="markdown-toc-some-more-definitions">Some more definitions</a></li>
        </ul>
      </li>
      <li><a href="#monitors" id="markdown-toc-monitors">Monitors</a>        <ul>
          <li><a href="#memory-model-1" id="markdown-toc-memory-model-1">Memory model</a>            <ul>
              <li><a href="#volatile-fields" id="markdown-toc-volatile-fields">Volatile fields</a></li>
            </ul>
          </li>
          <li><a href="#executors" id="markdown-toc-executors">Executors</a></li>
          <li><a href="#atomic-primitives" id="markdown-toc-atomic-primitives">Atomic primitives</a></li>
        </ul>
      </li>
      <li><a href="#programming-without-locks" id="markdown-toc-programming-without-locks">Programming without locks</a>        <ul>
          <li><a href="#lazy-values" id="markdown-toc-lazy-values">Lazy values</a></li>
          <li><a href="#collections" id="markdown-toc-collections">Collections</a></li>
        </ul>
      </li>
      <li><a href="#futures" id="markdown-toc-futures">Futures</a>        <ul>
          <li><a href="#synchronous-try" id="markdown-toc-synchronous-try">Synchronous: <code class="highlighter-rouge">Try</code></a></li>
          <li><a href="#asynchronous-future" id="markdown-toc-asynchronous-future">Asynchronous: <code class="highlighter-rouge">Future</code></a>            <ul>
              <li><a href="#recover-and-recoverwith" id="markdown-toc-recover-and-recoverwith">Recover and recoverWith</a></li>
            </ul>
          </li>
          <li><a href="#implementation-of-flatmap-on-future" id="markdown-toc-implementation-of-flatmap-on-future">Implementation of FlatMap on Future</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#part-3-actors" id="markdown-toc-part-3-actors">Part 3: Actors</a>    <ul>
      <li><a href="#why-actors" id="markdown-toc-why-actors">Why Actors?</a></li>
      <li><a href="#what-is-an-actor" id="markdown-toc-what-is-an-actor">What is an Actor?</a>        <ul>
          <li><a href="#the-actor-trait" id="markdown-toc-the-actor-trait">The Actor Trait</a></li>
        </ul>
      </li>
      <li><a href="#a-simple-stateful-actor" id="markdown-toc-a-simple-stateful-actor">A simple, stateful Actor</a>        <ul>
          <li><a href="#how-messages-are-sent" id="markdown-toc-how-messages-are-sent">How messages are sent</a></li>
          <li><a href="#the-actors-context" id="markdown-toc-the-actors-context">The Actor‚Äôs Context</a></li>
          <li><a href="#creating-and-stopping-actors" id="markdown-toc-creating-and-stopping-actors">Creating and Stopping Actors</a></li>
        </ul>
      </li>
      <li><a href="#message-processing" id="markdown-toc-message-processing">Message Processing</a>        <ul>
          <li><a href="#revisiting-the-bank-account-example" id="markdown-toc-revisiting-the-bank-account-example">Revisiting the Bank Account Example</a></li>
          <li><a href="#message-delivery-guarantees" id="markdown-toc-message-delivery-guarantees">Message Delivery Guarantees</a></li>
          <li><a href="#message-ordering" id="markdown-toc-message-ordering">Message Ordering</a></li>
        </ul>
      </li>
      <li><a href="#designing-actor-systems" id="markdown-toc-designing-actor-systems">Designing Actor Systems</a>        <ul>
          <li><a href="#actor-based-logging" id="markdown-toc-actor-based-logging">Actor-Based Logging</a></li>
          <li><a href="#handling-timeouts" id="markdown-toc-handling-timeouts">Handling Timeouts</a></li>
        </ul>
      </li>
      <li><a href="#testing-actor-systems" id="markdown-toc-testing-actor-systems">Testing Actor Systems</a></li>
      <li><a href="#failure-handling-with-actors" id="markdown-toc-failure-handling-with-actors">Failure Handling with Actors</a>        <ul>
          <li><a href="#strategies" id="markdown-toc-strategies">Strategies</a></li>
          <li><a href="#restarts" id="markdown-toc-restarts">Restarts</a></li>
          <li><a href="#lifecycle-hooks" id="markdown-toc-lifecycle-hooks">Lifecycle Hooks</a></li>
          <li><a href="#lifecycle-monitoring" id="markdown-toc-lifecycle-monitoring">Lifecycle Monitoring</a></li>
          <li><a href="#the-chlidren-list" id="markdown-toc-the-chlidren-list">The Chlidren List</a></li>
          <li><a href="#the-error-kernel" id="markdown-toc-the-error-kernel">The Error Kernel</a></li>
          <li><a href="#eventstream" id="markdown-toc-eventstream">EventStream</a></li>
          <li><a href="#unhandled-messages" id="markdown-toc-unhandled-messages">Unhandled Messages</a></li>
          <li><a href="#persistent-actor-state" id="markdown-toc-persistent-actor-state">Persistent Actor State</a></li>
        </ul>
      </li>
      <li><a href="#actors-are-distributed" id="markdown-toc-actors-are-distributed">Actors are Distributed</a>        <ul>
          <li><a href="#the-impact-of-network-communication" id="markdown-toc-the-impact-of-network-communication">The Impact of Network Communication</a></li>
          <li><a href="#actor-path" id="markdown-toc-actor-path">Actor Path</a></li>
          <li><a href="#clusters" id="markdown-toc-clusters">Clusters</a></li>
          <li><a href="#eventual-consistency" id="markdown-toc-eventual-consistency">Eventual Consistency</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#part-4-big-data-analysis-with-scala-and-spark" id="markdown-toc-part-4-big-data-analysis-with-scala-and-spark">Part 4: Big Data Analysis with Scala and Spark</a>    <ul>
      <li><a href="#data-parallel-to-distributed-data-parallel" id="markdown-toc-data-parallel-to-distributed-data-parallel">Data-Parallel to Distributed Data-Parallel</a>        <ul>
          <li><a href="#latency" id="markdown-toc-latency">Latency</a></li>
        </ul>
      </li>
      <li><a href="#rdds-sparks-distributed-collections" id="markdown-toc-rdds-sparks-distributed-collections">RDDs, Spark‚Äôs Distributed Collections</a>        <ul>
          <li><a href="#creating-rdds" id="markdown-toc-creating-rdds">Creating RDDs</a></li>
          <li><a href="#transformations-and-actions" id="markdown-toc-transformations-and-actions">Transformations and Actions</a></li>
          <li><a href="#benefits-of-laziness-for-large-scale-data" id="markdown-toc-benefits-of-laziness-for-large-scale-data">Benefits of laziness for Large-Scale Data</a></li>
          <li><a href="#caching-and-persistence" id="markdown-toc-caching-and-persistence">Caching and Persistence</a></li>
        </ul>
      </li>
      <li><a href="#reductions" id="markdown-toc-reductions">Reductions</a></li>
      <li><a href="#distributed-key-value-pairs-pair-rdds" id="markdown-toc-distributed-key-value-pairs-pair-rdds">Distributed Key-Value Pairs (Pair RDDs)</a>        <ul>
          <li><a href="#creating-a-pair-rdd" id="markdown-toc-creating-a-pair-rdd">Creating a Pair RDD</a></li>
          <li><a href="#groupbykey" id="markdown-toc-groupbykey"><code class="highlighter-rouge">groupByKey</code></a></li>
          <li><a href="#reducebykey" id="markdown-toc-reducebykey"><code class="highlighter-rouge">reduceByKey</code></a></li>
          <li><a href="#mapvalues" id="markdown-toc-mapvalues"><code class="highlighter-rouge">mapValues</code></a></li>
          <li><a href="#countbykey" id="markdown-toc-countbykey"><code class="highlighter-rouge">countByKey</code></a></li>
          <li><a href="#keys" id="markdown-toc-keys"><code class="highlighter-rouge">keys</code></a></li>
          <li><a href="#example" id="markdown-toc-example">Example</a></li>
        </ul>
      </li>
      <li><a href="#joins" id="markdown-toc-joins">Joins</a></li>
      <li><a href="#shuffles" id="markdown-toc-shuffles">Shuffles</a>        <ul>
          <li><a href="#partitioning" id="markdown-toc-partitioning">Partitioning</a></li>
          <li><a href="#optimizing-with-partitioners" id="markdown-toc-optimizing-with-partitioners">Optimizing with Partitioners</a></li>
          <li><a href="#wide-vs-narrow-dependencies" id="markdown-toc-wide-vs-narrow-dependencies">Wide vs Narrow Dependencies</a></li>
        </ul>
      </li>
      <li><a href="#structured-and-unstructured-data" id="markdown-toc-structured-and-unstructured-data">Structured and Unstructured Data</a></li>
      <li><a href="#spark-sql" id="markdown-toc-spark-sql">Spark SQL</a>        <ul>
          <li><a href="#getting-started" id="markdown-toc-getting-started">Getting started</a></li>
          <li><a href="#dataframes" id="markdown-toc-dataframes">DataFrames</a>            <ul>
              <li><a href="#cleaning-data-with-dataframes" id="markdown-toc-cleaning-data-with-dataframes">Cleaning Data with DataFrames</a></li>
              <li><a href="#common-actions-on-dataframes" id="markdown-toc-common-actions-on-dataframes">Common actions on DataFrames</a></li>
              <li><a href="#joins-on-dataframes" id="markdown-toc-joins-on-dataframes">Joins on DataFrames</a></li>
              <li><a href="#optimizations-on-dataframes" id="markdown-toc-optimizations-on-dataframes">Optimizations on DataFrames</a></li>
              <li><a href="#limitations" id="markdown-toc-limitations">Limitations</a></li>
            </ul>
          </li>
          <li><a href="#datasets" id="markdown-toc-datasets">Datasets</a>            <ul>
              <li><a href="#creating-datasets" id="markdown-toc-creating-datasets">Creating Datasets</a></li>
              <li><a href="#transformations-on-datasets" id="markdown-toc-transformations-on-datasets">Transformations on Datasets</a></li>
              <li><a href="#aggregators" id="markdown-toc-aggregators">Aggregators</a></li>
              <li><a href="#dataset-actions" id="markdown-toc-dataset-actions">Dataset Actions</a></li>
              <li><a href="#limitations-of-datasets" id="markdown-toc-limitations-of-datasets">Limitations of Datasets</a></li>
            </ul>
          </li>
          <li><a href="#datasets-vs-dataframes-vs-rdds" id="markdown-toc-datasets-vs-dataframes-vs-rdds">Datasets vs DataFrames vs RDDs</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<!-- More -->

<p>These are my notes from the <a href="http://lara.epfl.ch/w/parcon17:top">CS-206 Parallelism and Concurrency course</a>. Prerequisites are:</p>

<ul>
  <li><a href="/funprog/">Functional Programming</a></li>
  <li><a href="/algorithms/">Algorithms</a></li>
  <li>Computer Architecture</li>
</ul>

<p>Please note that these notes won‚Äôt be as good or complete as in the previous semester, as some of the lectures in this course were given ex cathedra instead of as a MOOC.</p>

<h2 id="introduction">Introduction</h2>
<p>Almost every desktop, laptop, mobile device today has multiple processors; it is therefore important to learn how to harness these resources. We‚Äôll see how functional programming applies to parallelization. We‚Äôll also learn how to estimate and measure performance.</p>

<h2 id="part-1-parallelism">Part 1: Parallelism</h2>

<h4 id="what-is-parallel-computing">What is parallel computing?</h4>
<p><em>Parallel computing</em> is a type of computation in which many calculations are performed at the same time. The basic principle is to divide the computation into smaller subproblems, each of which can be solved simultaneously. This is, of course, assuming that parallel hardware is at our disposal, with shared access to memory. Parallel programming is much harder than sequential programming, but we can get significant <em>speedups</em>.</p>

<p>Parallelism and concurrency are closely related concepts:</p>

<ul>
  <li><strong>Parallel program</strong>: uses parallel hardware to execute computation more quickly. It is mainly concerned with division into subproblems and optimal use of parallel hardware</li>
  <li><strong>Concurrent program</strong>: may or may not execute multiple executions at the same time. Mainly concerned with modularity, responsiveness or maintainability (convenience).</li>
</ul>

<p>The two often overlap; neither is the superset of the other.</p>

<p>Parallelism manifests itself at different granularity levels.</p>

<ul>
  <li><strong>Bit-level parallelism</strong>: processing multiple bits of data in parallel</li>
  <li><strong>Instruction-level parallelism</strong>: executing different instructions from the same instruction stream in parallel</li>
  <li><strong>Task-level parallelism</strong>: executing separate instruction streams in parallel</li>
</ul>

<p>The first two are mainly implemented in hardware or in compilers; as developers, we focus on task-level parallelism.</p>

<h3 id="parallelism-on-the-jvm">Parallelism on the JVM</h3>

<h4 id="definitions">Definitions</h4>
<p>A process is an instance of a program that is executing in the OS. The same program can be started as a process more than once, or even simultaneously in the same OS. The operating system <em>multiplexes</em> many different processes and a limited number of CPUs, so that they get <em>time slices</em> of execution. This
mechanism is called <em>multitasking</em>.</p>

<p>Two different processes cannot access each other‚Äôs memory directly ‚Äî they
are isolated. Interprocess communication methods exist, but they aren‚Äôt particularly straightforward.</p>

<p>Each process can contain multiple independent concurrency units called
<em>threads</em>. They can be started programmatically within the program, and they share the same memory address space ‚Äî this allows them to exchange information by doing memory read/writes.</p>

<p>Each thread has a program counter and a program stack. JVM threads can‚Äôt modify each other‚Äôs stack memory, they can only modify the heap memory.</p>

<h4 id="implementation">Implementation</h4>
<p>Each JVM process starts with a <strong>main thread</strong>. To start additional threads:</p>

<ol>
  <li>Define a <code class="highlighter-rouge">Thread</code> subclass.</li>
  <li>Instantiate a new <code class="highlighter-rouge">Thread</code> object.</li>
  <li>Call <code class="highlighter-rouge">start</code> on the <code class="highlighter-rouge">Thread</code> object.</li>
</ol>

<p>Notice that the same class can be used to start multiple threads.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">HelloThread</span> <span class="k">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nf">println</span><span class="o">(</span><span class="s">"Hello world!"</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HelloThread</span> <span class="c1">// new thread instance</span>

<span class="nv">t</span><span class="o">.</span><span class="py">start</span><span class="o">()</span> <span class="c1">// start thread</span>
<span class="nv">t</span><span class="o">.</span><span class="py">join</span><span class="o">()</span> <span class="c1">// wait for its completion</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">t.join()</code> blocks the main thread‚Äôs execution until the <code class="highlighter-rouge">t</code> thread is done executing.</p>

<p>Let‚Äôs look at a more complex example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">HelloThread</span> <span class="k">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)</span>
        <span class="nf">println</span><span class="o">(</span><span class="s">"world!"</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">def</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HelloThread</span>
    <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HelloThread</span>

    <span class="nv">t</span><span class="o">.</span><span class="py">start</span><span class="o">()</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">start</span><span class="o">()</span>
    <span class="nv">t</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Running it multiple times might yield the following output:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>Hello
world!
Hello
world!

Hello
world!
Hello
world!

Hello
Hello
world!
world!
</pre></td></tr></tbody></table></code></pre></figure>

<p>On the first two executions, the threads happened to execute linearly; first <code class="highlighter-rouge">t</code>, then <code class="highlighter-rouge">s</code>. But on the third attempt, the first thread printed <code class="highlighter-rouge">Hello</code>, but then the second thread kicked in, also printed <code class="highlighter-rouge">Hello</code> ‚Äî before the first had time to print out <code class="highlighter-rouge">world!</code>, and then they both completed.</p>

<h3 id="atomicity">Atomicity</h3>
<p>The above shows that <strong>two parallel threads can overlap arbitrarily</strong>. However, we sometimes want to ensure that a sequence of statements executes at once, as if they were just one statement, meaning that we don‚Äôt want them to overlap. This is called atomicity.</p>

<p>An operation is <em>atomic</em> if it appears as if it occurred instantaneously from the point of view of other threads.</p>

<p>The implementation of <code class="highlighter-rouge">getUniqueId()</code> below isn‚Äôt atomic, as it suffers from the same problem as the hello world example above.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">private</span> <span class="k">var</span> <span class="n">uidCount</span> <span class="k">=</span> <span class="mi">0L</span> <span class="c1">// 0 as a long</span>
<span class="k">def</span> <span class="nf">getUniqueId</span><span class="o">()</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">uidCount</span> <span class="k">=</span> <span class="n">uidCount</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">uidCount</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="synchronized-blocks">Synchronized blocks</h4>
<p>How can we secure it from this problem? How do we get it to execute atomically?</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">private</span> <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AnyRef</span> <span class="o">{}</span>
<span class="k">private</span> <span class="k">var</span> <span class="n">uidCount</span> <span class="k">=</span> <span class="mi">0L</span>
<span class="k">def</span> <span class="nf">getUniqueId</span><span class="o">()</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
    <span class="n">uidCount</span> <span class="k">=</span> <span class="n">uidCount</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">uidCount</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">synchronized</code> block is used to achieve atomicity. Code blocks after a <code class="highlighter-rouge">synchronized</code> call on an object <code class="highlighter-rouge">x</code> are never executed on two threads at once. The JVM ensures this by storing an object called the <em>monitor</em> in each object. At most one thread can own the monitor at any particular time, and releases it when it‚Äôs done executing.</p>

<p><code class="highlighter-rouge">synchronized</code> blocks can even be nested.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Account</span><span class="o">(</span><span class="k">private</span> <span class="k">var</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Account</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
        <span class="k">this</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span> <span class="c1">// synchronized block on source account</span>
            <span class="nv">target</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span> <span class="c1">// and on target account</span>
                <span class="k">this</span><span class="o">.</span><span class="py">amount</span> <span class="o">-=</span> <span class="n">n</span>
                <span class="nv">target</span><span class="o">.</span><span class="py">amount</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This way, the thread gets a monitor on account A, and then on account B. Once it has monitors on both, it can transfer the amount from A to B. Another thread can do this with C and D in parallel.</p>

<h4 id="deadlocks">Deadlocks</h4>
<p>Sometimes though, this may cause the code to freeze, or to <em>deadlock</em>. This is a scenario in which two or more threads compete for resources (such as monitor ownership) and wait for each to finish without releasing
the already acquired resources.</p>

<p>The following code should cause a deadlock:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Account</span><span class="o">(</span><span class="mi">50</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Account</span><span class="o">(</span><span class="mi">70</span><span class="o">)</span>

<span class="c1">// thread T1</span>
<span class="nv">a</span><span class="o">.</span><span class="py">transfer</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// thread T2</span>
<span class="nv">b</span><span class="o">.</span><span class="py">transfer</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">T1</code> gets the monitor for <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">T2</code> gets the monitor for <code class="highlighter-rouge">b</code>. Then they both wait for each other to release the monitor, leaving us in a deadlock.</p>

<h5 id="resolving-deadlocks">Resolving deadlocks</h5>
<p>One approach is to always acquire resources in the same order. This assumes an ordering relationship on the resources. In our example, we can simply assign unique IDs on the accounts, and order our <code class="highlighter-rouge">synchronized</code> calls according to this ID.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">uid</span> <span class="k">=</span> <span class="nf">getUniqueUid</span><span class="o">()</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">lockAndTransfer</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Account</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">this</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
        <span class="nv">target</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="py">amount</span> <span class="o">-=</span> <span class="n">n</span>
            <span class="nv">target</span><span class="o">.</span><span class="py">amount</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="k">def</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Account</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">uid</span> <span class="o">&lt;</span> <span class="nv">target</span><span class="o">.</span><span class="py">uid</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="py">lockAndTransfer</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
    <span class="k">else</span> <span class="nv">target</span><span class="o">.</span><span class="py">lockAndTransfer</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="o">-</span><span class="n">n</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="memory-model">Memory model</h4>
<p>A <em>memory model</em> is a set of rules describing how threads interact when accessing shared memory. Java Memory Model is the memory model for the JVM. There are many rules, but the ones we chose to remember in the context of this course are:</p>

<ol>
  <li>Two threads writing to separate locations in memory do not need synchronization.</li>
  <li>A thread X that calls <code class="highlighter-rouge">join</code> on another thread Y is guaranteed to observe all the writes by thread Y after <code class="highlighter-rouge">join</code> returns. Note that if we don‚Äôt call <code class="highlighter-rouge">join</code>, there‚Äôs no guarantee that X will see any of Y‚Äôs changes when it reads in memory.</li>
</ol>

<p>We will not be using threads and the <code class="highlighter-rouge">synchronized</code> primitive directly in the remainder of the course. However, the methods in the course are based on these, and knowledge about them is indeed useful.</p>

<h3 id="running-computations-in-parallel">Running computations in parallel</h3>
<p>How can we run the following code in parallel?</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">pNormTwoPart</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nf">val</span> <span class="o">(</span><span class="n">sum1</span><span class="o">,</span> <span class="n">sum2</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">m</span><span class="o">),</span>
                        <span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span><span class="o">))</span>
    <span class="nf">power</span><span class="o">(</span><span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span><span class="o">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We just add <code class="highlighter-rouge">parallel</code>!</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">pNormTwoPart</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nf">val</span> <span class="o">(</span><span class="n">sum1</span><span class="o">,</span> <span class="n">sum2</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span><span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">m</span><span class="o">),</span>
                                <span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span><span class="o">))</span>
    <span class="nf">power</span><span class="o">(</span><span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span><span class="o">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Recursion works very well with parallelism. We can for instance spin up an arbitrary number of threads:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">pNormRec</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="nf">power</span><span class="o">(</span><span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span><span class="o">),</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="o">)</span>

<span class="c1">// like sumSegment but parallel</span>
<span class="k">def</span> <span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="c1">// small segment: do it sequentially</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="n">s</span> <span class="o">+</span> <span class="o">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">)/</span><span class="mi">2</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">sum1</span><span class="o">,</span> <span class="n">sum2</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span><span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span><span class="o">),</span>
                                    <span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span>
        <span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="signature-of-parallel">Signature of parallel</h5>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">parallel</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">taskA</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">taskB</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>It returns the same value as it is given, but can do it faster than its sequential counterpart. From the point of view of the value, it is an identity function. Its arguments are taken <em>by name</em> (CBN); otherwise it wouldn‚Äôt be able to do much with them, as they would be evaluated sequentially before being sent to <code class="highlighter-rouge">parallel</code>. <code class="highlighter-rouge">parallel</code> needs the unevaluated computations to function, thus CBN.</p>

<h4 id="underlying-hardware-architecture-affects-performance">Underlying hardware architecture affects performance</h4>
<p>Sometimes, we do not achieve any speedup even though we ran computations in parallel. For instance, if we sum up array elements instead of summing <em>powers</em> of array elements like above, we don‚Äôt see any speedups using parallelism. This is because this computation is bound by the memory bandwidth, which acts as a bottleneck to any speedup.</p>

<p>Therefore, when considering opportunities for speed-up, we must take into account not only the number of cores, but also the parallelism available for any other shared resources that we might need in order to perform computation, such as memory in this case.</p>

<p>In general, parallel computation takes as long as its slowest / longest thread.</p>

<h3 id="tasks">Tasks</h3>
<p>Instead of invoking threads, we can use a more flexible construct for parallel computation: tasks.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">t1</span> <span class="k">=</span> <span class="nf">task</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">t2</span> <span class="k">=</span> <span class="nf">task</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">v1</span> <span class="k">=</span> <span class="nv">t1</span><span class="o">.</span><span class="py">join</span>
<span class="k">val</span> <span class="nv">v2</span> <span class="k">=</span> <span class="nv">t2</span><span class="o">.</span><span class="py">join</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">t = task(e)</code> starts a computation ‚Äúin the background‚Äù; the main thread continues while the task is running (unless we use <code class="highlighter-rouge">join</code> in which case it waits). Tasks are easier to use; instead of this mess with nested calls to <code class="highlighter-rouge">parallel</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="nf">val</span> <span class="o">((</span><span class="n">part1</span><span class="o">,</span> <span class="n">part2</span><span class="o">),(</span><span class="n">part3</span><span class="o">,</span><span class="n">part4</span><span class="o">))</span> <span class="k">=</span>
    <span class="nf">parallel</span><span class="o">(</span><span class="nf">parallel</span><span class="o">(</span><span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">mid1</span><span class="o">),</span>
                      <span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">mid1</span><span class="o">,</span> <span class="n">mid2</span><span class="o">)),</span>
             <span class="nf">parallel</span><span class="o">(</span><span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">mid2</span><span class="o">,</span> <span class="n">mid3</span><span class="o">),</span>
                      <span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">mid3</span><span class="o">,</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span><span class="o">)))</span>
<span class="nf">power</span><span class="o">(</span><span class="n">part1</span> <span class="o">+</span> <span class="n">part2</span> <span class="o">+</span> <span class="n">part3</span> <span class="o">+</span> <span class="n">part4</span><span class="o">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can easily get 4 tasks by doing:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">t1</span> <span class="k">=</span> <span class="n">task</span> <span class="o">{</span><span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">mid1</span><span class="o">)}</span>
<span class="k">val</span> <span class="nv">t2</span> <span class="k">=</span> <span class="n">task</span> <span class="o">{</span><span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">mid1</span><span class="o">,</span> <span class="n">mid2</span><span class="o">)}</span>
<span class="k">val</span> <span class="nv">t3</span> <span class="k">=</span> <span class="n">task</span> <span class="o">{</span><span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">mid2</span><span class="o">,</span> <span class="n">mid3</span><span class="o">)}</span>
<span class="k">val</span> <span class="nv">t4</span> <span class="k">=</span> <span class="n">task</span> <span class="o">{</span><span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">mid3</span><span class="o">,</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span><span class="o">)}</span>
<span class="nf">power</span><span class="o">(</span><span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span> <span class="o">+</span> <span class="n">t4</span><span class="o">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We don‚Äôt call <code class="highlighter-rouge">join</code>, it‚Äôs implicit?</p>

<h3 id="how-do-we-measure-performance">How do we measure performance?</h3>

<h4 id="work-and-depth">Work and depth</h4>
<p>We introduce two measures for a program:</p>

<ul>
  <li><strong>Work</strong> <code class="highlighter-rouge">W(e)</code>: number of steps <code class="highlighter-rouge">e</code> would take if there was no parallelism. This is simply the sequential execution time</li>
  <li><strong>Depth</strong> <code class="highlighter-rouge">D(e)</code>: number of steps if we had unbounded parallelism</li>
</ul>

<p>The key rules are:</p>

<ul>
  <li>$W(\text{parallel}(e_1, e_2)) = W(e_1) + W(e_2) + c_2$.</li>
  <li>$D(\text{parallel}(e_1, e_2)) = max(D(e_1), D(e_2)) + c_1$.</li>
</ul>

<p>For parts of code where we do not use <code class="highlighter-rouge">parallel</code> explicitly, we must add up
costs. For function call or operation $f(e_1, ‚Ä¶, e_n)$:</p>

<ul>
  <li>$W(f(e_1, ‚Ä¶, e_n)) = W(e_1) + ‚Ä¶ + W(e_n) + W(f)(v_1, ‚Ä¶, v_n)$.</li>
  <li>$D(f(e_1, ‚Ä¶, e_n)) = D(e_1) + ‚Ä¶ + D(e_n) + D(f)(v_1, ‚Ä¶, v_n)$.</li>
</ul>

<p>Here $v_i$ denotes values of $e_i$. If $f$ is a primitive operation on integers, then $W(f)$ and $D(f)$ are constant functions, regardless of $v_i$.</p>

<p>Suppose we know $W(e)$ and $D(e)$ and our platform has <em>P</em> parallel threads. It is reasonable to use this estimate for running time:</p>

\[D(e) + \frac{W(e)}{P}\]

<p>Given $W$ and $D$, we can estimate how programs behave for different $P$:</p>

<ul>
  <li>If $P$ is constant but inputs grow, parallel programs have the same asymptotic time complexity as sequential ones.</li>
  <li>Even with infinite resources ($P\rightarrow \infty$) we have non-zero complexity given by $D(e)$.</li>
</ul>

<h4 id="asymptotic-analysis">Asymptotic analysis</h4>
<p>Asymptotic analysis allows us to understand how the runtime of our algorithm changes when the inputs get larger or when we have more parallel hardware available. Just like in <a href="/algorithms/">Algorithms</a>, we consider the worst case to get an upper bound using big-O notation.</p>

<p>Let‚Äôs look at an example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="n">s</span>
    <span class="k">var</span> <span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="nf">power</span><span class="o">(</span><span class="nf">a</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">p</span><span class="o">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">}</span>
    <span class="n">sum</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The running time is linear in the time between <code class="highlighter-rouge">t</code> and <code class="highlighter-rouge">s</code>, $O(t-s)$, a function of the form $c_1(t-s)+c_2, \quad  c_1, c_2 \in \mathbb{R}$.</p>

<p>Now what about this recursive function?</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="n">s</span> <span class="o">+</span> <span class="o">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">)/</span><span class="mi">2</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">sum1</span><span class="o">,</span> <span class="n">sum2</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span><span class="o">),</span>
                            <span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span>
        <span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The cost (<em>work</em>) of this function is:</p>

\[W(s, t) = \begin{cases}
c_1(t-s) + c_2, &amp; \text{if } t-s &lt; \text{threshold} \\
W(s, m) + W(m, t) + c_3 &amp; \text{otherwise, for } m = \lfloor (s+t)/2 \rfloor \\
\end{cases}\]

<p>$c_3$ is some function overhead, the cost of calculating the middle <code class="highlighter-rouge">m</code> and starting two parallel threads. Assume $t-s = 2^N(threshold-1)$, where $N$ is the depth of the tree (how we ‚Äúsplit our program into two‚Äù). The computation tree has $2^N$ leaves and $2^N - 1$ internal nodes, so:</p>

\[W(s, t) = 2^N(c_1(threshold-1) + c_2) + (2^N-1)c_3 = 2^N c_4 + c_5\]

<p>For each internal node, we do $(2^N - 1)c_3$ work, and for each leaf we do $2^N(c_1(threshold-1) + c_2)$ work. If we look at what is constant, we can write it in the above form. If we pick our $N$ so that $2^{N-1} &lt; \frac{t-s}{threshold - 1} \leq 2^N$ (meaning we just find the closest power of 2 approximation), we have:</p>

\[W(s, t) \leq 2^N c_4 + c_5 &lt; (t-s)\cdot 2/(threshold-1) + c_5\]

<p>$W(s, t)$ in $O(t-s)$, so our function is in $t-s$. What if we now make it parallel?</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="nf">sumSegment</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="n">s</span> <span class="o">+</span> <span class="o">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">)/</span><span class="mi">2</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">sum1</span><span class="o">,</span> <span class="n">sum2</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span>
            <span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span><span class="o">),</span>
            <span class="nf">segmentRec</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span>
        <span class="o">)</span>
        <span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The depth of our computation tree is given by:</p>

\[D(s, t) = \begin{cases}
c_1(t-s) + c_2, &amp; \text{if } t-s &lt; \text{threshold} \\
max(D(s, m), D(m, t)) + c_3, &amp; \text{otherwise, for } m = \lfloor (s+t)/2 \rfloor \\
\end{cases}\]

<p>Since we‚Äôre running the branches of the computation tree in parallel, the depth will be the max of the left and the right branch, plus some constant overhead. Let‚Äôs assume again that $t-s$ is of the convenient form $t-s = 2^N(threshold-1)$, where $N$ is the depth of the tree. The computation tree has $2^N$ leaves and $2^N - 1$ internal nodes.</p>

<ul>
  <li><strong>Leaves of computation tree</strong>: $c_1(threshold - 1) + c_2$</li>
  <li><strong>One level above</strong>: $c_1(threshold - 1) + c_2 + c_3$</li>
  <li><strong>Two levels above</strong>: $c_1(threshold - 1) + c_2 + 2c_3$</li>
  <li>‚Ä¶</li>
  <li><strong>Root</strong>: $c_1 (threshold - 1) + c_2 + (N-1)c_3$</li>
</ul>

<p>Since $N$ is the depth of the tree. Our depth is thus bounded by $O(N)$. As before, running time is monotonic is $t-s$. Let‚Äôs pick our $N$ to approximate our depth, meaning that for $2^{N-1} &lt; \frac{t-s}{threshold - 1} \leq 2^N$, we have $ N &lt; \log{(t-s)} + c_6 $. This is an important result, since combined with the idea that depth is bounded by $O(N)$, we conclude that $D(s, t)$ is $O(\log{(t-s)})$. This means that parallelization has taken us from linear to logarithmic runtime (assuming unlimited parallelization).</p>

<h4 id="empirical-analysis-benchmarking">Empirical analysis: Benchmarking</h4>
<p>Measuring performance is difficult. To ensure somewhat reliable results, we need a strict measurement methodology involving:</p>

<ul>
  <li>Multiple repetitions</li>
  <li>Statistical treatment ‚Äì computing mean and variance</li>
  <li>Eliminating outliers</li>
  <li>Ensuring steady state (warm-up)</li>
  <li>Preventing anomalies (GC, JIT compilation, aggressive optimizations)</li>
</ul>

<p>This is all quite complex, so we use a tool to do it for us: ScalaMeter. To use it, we first need to add it as a dependency in <code class="highlighter-rouge">build.sbt</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">libraryDependencies</span> <span class="o">+=</span> 
    <span class="s">"com.storm-enroute"</span> <span class="o">%%</span> <span class="s">"scalameter-core"</span> <span class="o">%</span> <span class="s">"0.6"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Then we can use it as such:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">org.scalameter._</span>

<span class="k">val</span> <span class="nv">time</span> <span class="k">=</span> <span class="n">measure</span> <span class="o">{</span>
    <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="mi">1000000</span><span class="o">).</span><span class="py">toArray</span>
<span class="o">}</span>

<span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Array initialization time: $time ms"</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>But this yields unreliable results due to garbage collection and dynamic optimization and stuff like that. Running it multiple times can yield anything from  7 to 50ms. We notice that the program runs in about 7ms after a few runs; this is the <em>JVM Warmup</em>.</p>

<p>ScalaMeter can ensure that warm-up has taken place if we do:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">org.scalameter._</span>

<span class="k">val</span> <span class="nv">time</span> <span class="k">=</span> <span class="nf">withWarmer</span><span class="o">(</span><span class="k">new</span> <span class="nv">Warmer</span><span class="o">.</span><span class="py">Default</span><span class="o">)</span> <span class="n">measure</span> <span class="o">{</span>
    <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="mi">1000000</span><span class="o">).</span><span class="py">toArray</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we are not entirely satisfied with the defaults settings of ScalaMeter, we can change them as such:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">time</span> <span class="k">=</span> <span class="nf">config</span><span class="o">(</span>
    <span class="nv">Key</span><span class="o">.</span><span class="py">exec</span><span class="o">.</span><span class="py">minWarmupRuns</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">,</span>
    <span class="nv">Key</span><span class="o">.</span><span class="py">exec</span><span class="o">.</span><span class="py">maxWarmupRuns</span> <span class="o">-&gt;</span> <span class="mi">60</span><span class="o">,</span>
    <span class="nv">Key</span><span class="o">.</span><span class="py">verbose</span> <span class="o">-&gt;</span> <span class="kc">true</span> <span class="c1">// increase verbosity</span>
<span class="o">)</span> <span class="nf">withWarmer</span><span class="o">(</span><span class="k">new</span> <span class="nv">Warmer</span><span class="o">.</span><span class="py">Default</span><span class="o">)</span> <span class="n">measure</span> <span class="o">{</span>
    <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="mi">1000000</span><span class="o">).</span><span class="py">toArray</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Finally, ScalaMeter can measure more than just the running time:</p>

<ul>
  <li><code class="highlighter-rouge">Measurer.Default</code>: plain running time</li>
  <li><code class="highlighter-rouge">IgnoringGC</code>: running time without GC pauses</li>
  <li><code class="highlighter-rouge">OutlierElimination</code>: removes statistical outliers</li>
  <li><code class="highlighter-rouge">MemoryFootprint</code>: memory footprint of an object</li>
  <li><code class="highlighter-rouge">GarbageCollectionCycles</code>: total number of GC pauses</li>
</ul>

<h3 id="parallelizing-important-algorithms">Parallelizing important algorithms</h3>

<h4 id="parallel-merge-sort">Parallel merge sort</h4>
<p>As we mentioned in Algorithms, <a href="/algorithms/#merge-sort">Merge Sort</a> works very well in parallel. We‚Äôll see how to do just that now. We‚Äôll use two arrays <code class="highlighter-rouge">xs</code> and <code class="highlighter-rouge">ys</code>, where <code class="highlighter-rouge">ys</code> is just a temporary array to which we‚Äôll be copying elements from the original array <code class="highlighter-rouge">xs</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sort</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">until</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">maxDepth</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// base case</span>
        <span class="nf">quickSort</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">until</span> <span class="o">-</span> <span class="n">from</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// recursively parallelize</span>
        <span class="c1">// Divide</span>
        <span class="k">val</span> <span class="nv">mid</span> <span class="k">=</span> <span class="o">(</span><span class="n">from</span> <span class="o">+</span> <span class="n">until</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="nf">parallel</span><span class="o">(</span><span class="nf">sort</span><span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">until</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">),</span> <span class="nf">sort</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
        <span class="c1">// Merge two sorted sublists</span>
        <span class="k">val</span> <span class="nv">flip</span> <span class="k">=</span> <span class="o">(</span><span class="n">maxDepth</span> <span class="o">-</span> <span class="n">depth</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">val</span> <span class="nv">src</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">flip</span><span class="o">)</span> <span class="n">ys</span> <span class="k">else</span> <span class="n">xs</span>
        <span class="k">val</span> <span class="nv">dst</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">flip</span><span class="o">)</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">ys</span>
        <span class="nf">merge</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">until</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">src</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">dst</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> 
          <span class="n">from</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">mid</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">until</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>

<span class="nf">sort</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">merge</code> implementation is sequential, so we will not go through it. Benchmarking this parallel merge sort to the Scala <code class="highlighter-rouge">quicksort</code> implementation shows up to a two-fold speedup in practice.</p>

<h5 id="copying-array-in-parallel">Copying array in parallel</h5>
<p>To copy the temporary array into the original one, we need an optimized algorithm:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">copy</span><span class="o">(</span><span class="n">src</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">target</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span>
<span class="n">from</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">until</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">maxDepth</span><span class="o">)</span> <span class="o">{</span>
        <span class="nv">Array</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">until</span> <span class="o">-</span> <span class="n">from</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">mid</span> <span class="k">=</span> <span class="o">(</span><span class="n">from</span> <span class="o">+</span> <span class="n">until</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">val</span> <span class="nv">right</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span>
            <span class="nf">copy</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">until</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">),</span>
            <span class="nf">copy</span><span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nf">if</span> <span class="o">(</span><span class="n">maxDepth</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nf">copy</span><span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">xs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="parallel-map">Parallel map</h4>
<p>Some operations we saw in the previous course were <a href="/funprog/#map">map</a>, <a href="/funprog/#reduce">fold</a> and scan (like <code class="highlighter-rouge">fold</code> but stores intermediate results).</p>

<p>Lists aren‚Äôt terribly efficient, as splitting them in half and combining them take linear time. As alternatives, we‚Äôll use <em>arrays</em> and <em>trees</em> in our implementation. We‚Äôll see more about Scala‚Äôs parallel collection libraries in future lectures.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">mapASegPar</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">f</span> <span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span>
                    <span class="n">out</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// Writes to out(i) for left &lt;= i &lt;= right-1</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="nf">mapASegSeq</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span> <span class="c1">// assuming a sequential implementation has been defined as such</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">mid</span> <span class="k">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)/</span><span class="mi">2</span>
        <span class="nf">parallel</span><span class="o">(</span><span class="nf">mapASegPar</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">out</span><span class="o">),</span>
                 <span class="nf">mapASegPar</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">out</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Parallelization yields 5x or 6x speedup in certain benchmarks. From the benchmarks we can also tell that the parallelized <code class="highlighter-rouge">map</code> is basically as efficient as specialized implementations of operations in parallel.</p>

<p>If we use trees instead of arrays:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">mapTreePar</span><span class="o">[</span><span class="kt">A:Manifest</span>,<span class="kt">B:Manifest</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="c1">// base case</span>
            <span class="k">val</span> <span class="nv">len</span> <span class="k">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span>
            <span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">len</span><span class="o">)</span>
            <span class="k">var</span> <span class="n">i</span><span class="k">=</span> <span class="mi">0</span>
            <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
                <span class="nf">b</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nf">a</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
                <span class="n">i</span><span class="k">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="o">}</span>
            <span class="nc">Leaf</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="c1">// recursive parallelization</span>
            <span class="nf">val</span> <span class="o">(</span><span class="n">lb</span><span class="o">,</span><span class="n">rb</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span><span class="nf">mapTreePar</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">f</span><span class="o">),</span> <span class="nf">mapTreePar</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="n">f</span><span class="o">))</span>
            <span class="nc">Node</span><span class="o">(</span><span class="n">lb</span><span class="o">,</span> <span class="n">rb</span><span class="o">)</span> <span class="c1">// combine computations into new node</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="comparison-of-arrays-and-immutable-trees">Comparison of arrays and immutable trees</h5>
<p></p>

<p><strong>Arrays</strong>:</p>

<ul>
  <li>(+) random access to elements, on shared memory can share array</li>
  <li>(+) good memory locality</li>
  <li>(-) imperative: must ensure parallel tasks write to disjoint parts</li>
  <li>(-) expensive to concatenate</li>
</ul>

<p><strong>Immutable trees</strong>:</p>

<ul>
  <li>(+) purely functional, produce new trees, keep old ones</li>
  <li>(+) no need to worry about disjointness of writes by parallel tasks</li>
  <li>(+) efficient to combine two trees</li>
  <li>(-) high memory allocation overhead</li>
  <li>(-) bad locality</li>
</ul>

<h4 id="parallel-reduce">Parallel reduce</h4>
<p>For reduce (or fold), the order of operation matters. When we process the elements in parallel, we must therefore impose that the operation be <strong>associative</strong>, meaning that the order doesn‚Äôt matter.  Examples of associative operations include addition or concatenation of strings, but not subtraction.</p>

<p>An operation <code class="highlighter-rouge">f: (A, A) =&gt; A</code> is associative <em>if and only if</em> for every <code class="highlighter-rouge">x, y, z</code>, <code class="highlighter-rouge">f(x, f(y, z)) == f(f(x, y), z)</code>.</p>

<p>We can represent the reduction as an operation tree, where every node corresponds to a single operation (say, addition or concatenation). If <code class="highlighter-rouge">t1</code> and <code class="highlighter-rouge">t2</code> are different tree representations of the same reduction (so they correspond to the same reduction, but in a different order), and <code class="highlighter-rouge">f: (A, A) =&gt; A</code> is associative, then:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nf">reduce</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="o">==</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">t2</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we want to implement <code class="highlighter-rouge">reduce</code> for arrays instead of trees, we can just conceptually consider arrays as trees by cutting them in half at every step (until a certain <code class="highlighter-rouge">threshold</code> size):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">reduceSeg</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">var</span> <span class="n">res</span><span class="k">=</span> <span class="nf">inp</span><span class="o">(</span><span class="n">left</span><span class="o">);</span> <span class="k">var</span> <span class="n">i</span><span class="k">=</span> <span class="n">left</span><span class="o">+</span><span class="mi">1</span>
        <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="nf">inp</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
            <span class="n">i</span><span class="k">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="o">}</span>
        <span class="n">res</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">mid</span> <span class="k">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)/</span><span class="mi">2</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">a1</span><span class="o">,</span><span class="n">a2</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span><span class="nf">reduceSeg</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">f</span><span class="o">),</span>
                               <span class="nf">reduceSeg</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">f</span><span class="o">))</span>
        <span class="nf">f</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span><span class="n">a2</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">reduce</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="nf">reduceSeg</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">inp</span><span class="o">.</span><span class="py">length</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="associative-andor-commutative-operations">Associative and/or commutative operations</h4>

<p><em>Associative</em> <strong>and</strong> <em>commutative</em> operations:</p>

<ul>
  <li>Addition and multiplication of mathematical integers (<code class="highlighter-rouge">BigInt</code>) and of
exact rational numbers (given as, e.g., pairs of <code class="highlighter-rouge">BigInts</code>)</li>
  <li>Addition and multiplication modulo a positive integer (e.g. 232),
including the usual arithmetic on 32-bit <code class="highlighter-rouge">Int</code> or 64-bit <code class="highlighter-rouge">Long</code> values</li>
  <li>Union, intersection, and symmetric difference of sets</li>
  <li>Union of bags (multisets) that preserves duplicate elements</li>
  <li>Boolean operations <code class="highlighter-rouge">&amp;&amp;</code>, <code class="highlighter-rouge">||</code>, <code class="highlighter-rouge">xor</code></li>
  <li>Addition and multiplication of polynomials</li>
  <li>Addition of vectors</li>
  <li>Addition of matrices of fixed dimension</li>
</ul>

<p><em>Associative</em> <strong>but not</strong> <em>commutative</em> operations:</p>

<ul>
  <li>Concatenation (append) of lists: <code class="highlighter-rouge">(x ++ y) ++ z == x ++ (y ++ z)</code></li>
  <li>Concatenation of <code class="highlighter-rouge">Strings</code> (which can be viewed as lists of <code class="highlighter-rouge">Char</code>)</li>
  <li>Matrix multiplication AB for matrices A and B of compatible dimensions</li>
  <li>Composition of relations $r \odot s = \left\{(a,c) : \exists b : (a,b)\in r \wedge (b, c)\in s\right\}$</li>
  <li>Composition of functions $(f \circ g)(x) = f(g(x))$</li>
</ul>

<p>Many operations <em>Commutative</em> <strong>but not</strong> <em>associative</em>, such as $f(x, y) = x^2 + y^2$. Interestingly, addition or multiplication of floating point numbers is commutative, but not associative. This is because of floating point errors (where they‚Äôre off by <code class="highlighter-rouge">0.000...01</code>), so we don‚Äôt always have</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">mx</span><span class="o">)</span> <span class="o">+</span> <span class="n">e</span> <span class="o">==</span> <span class="n">x</span> <span class="o">+</span> <span class="o">(</span><span class="n">mx</span> <span class="o">+</span> <span class="n">e</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>As a conclusion, proving commutativity alone does not prove associativity. Another thing to look out for is that associativity is not preserved by mapping; when combining and optimizing <code class="highlighter-rouge">reduce</code> and <code class="highlighter-rouge">map</code> invocations, we need to be careful that operations given to <code class="highlighter-rouge">reduce</code> remain associative.</p>

<h5 id="making-an-operation-commutative-is-easy">Making an operation commutative is easy</h5>
<p>Suppose we have a binary operation <code class="highlighter-rouge">g</code> and a strict total ordering <code class="highlighter-rouge">less</code> (e.g. lexicographical ordering of bit representations). Then this operation is commutative:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">less</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">))</span> <span class="nf">g</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="k">else</span> <span class="nf">g</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There is no such trick for associativity, though.</p>

<h5 id="constructing-associative-operations">Constructing associative operations</h5>
<p>Suppose <code class="highlighter-rouge">f1: (A1,A1) =&gt; A1</code> and <code class="highlighter-rouge">f2: (A2,A2) =&gt; A2</code> are associative.</p>

<p>Then <code class="highlighter-rouge">f: ((A1,A2), (A1,A2)) =&gt; (A1,A2)</code> defined by</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nf">f</span><span class="o">((</span><span class="n">x1</span><span class="o">,</span><span class="n">x2</span><span class="o">),</span> <span class="o">(</span><span class="n">y1</span><span class="o">,</span><span class="n">y2</span><span class="o">))</span> <span class="k">=</span> <span class="o">(</span><span class="nf">f1</span><span class="o">(</span><span class="n">x1</span><span class="o">,</span><span class="n">y1</span><span class="o">),</span> <span class="nf">f2</span><span class="o">(</span><span class="n">x2</span><span class="o">,</span><span class="n">y2</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>is also associative.</p>

<p>The following functions are also associative:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="nf">times</span><span class="o">((</span><span class="n">x1</span><span class="o">,</span><span class="n">y1</span><span class="o">),</span> <span class="o">(</span><span class="n">x2</span><span class="o">,</span> <span class="n">y2</span><span class="o">))</span> <span class="k">=</span> <span class="o">(</span><span class="n">x1</span><span class="o">*</span><span class="n">x2</span><span class="o">,</span> <span class="n">y1</span><span class="o">*</span><span class="n">y2</span><span class="o">)</span>

<span class="c1">// Calculating average</span>
<span class="k">val</span> <span class="nv">sum</span> <span class="k">=</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">collection</span><span class="o">,</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">length</span> <span class="k">=</span> <span class="nf">reduce</span><span class="o">(</span><span class="nf">map</span><span class="o">(</span><span class="n">collection</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="o">),</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="n">sum</span><span class="o">/</span><span class="n">length</span>

<span class="c1">// Equivalently</span>
<span class="nf">val</span> <span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">length</span><span class="o">)</span> <span class="k">=</span> <span class="nf">reduce</span><span class="o">(</span><span class="nf">map</span><span class="o">(</span><span class="n">collection</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="mi">1</span><span class="o">)),</span> <span class="n">f</span><span class="o">)</span>
<span class="n">sum</span><span class="o">/</span><span class="n">length</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are some situations where commutativity can help us establish associativity, but we need some additional property. Let:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nf">E</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">)</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We say arguments of <code class="highlighter-rouge">E</code> can rotate if:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="nf">E</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">)</span> <span class="k">=</span> <span class="nf">E</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">,</span><span class="n">x</span><span class="o">)</span>
<span class="c1">// equivalent to</span>
<span class="nf">f</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">),</span> <span class="n">x</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If the above function <code class="highlighter-rouge">f</code> is commutative and the arguments if E can rotate, <strong>then <code class="highlighter-rouge">f</code> is also associative</strong>. Proof:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nf">f</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">),</span> <span class="n">x</span><span class="o">)</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can use this to prove associativity for the following examples:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nf">plus</span><span class="o">((</span><span class="n">x1</span><span class="o">,</span><span class="n">y1</span><span class="o">),</span> <span class="o">(</span><span class="n">x2</span><span class="o">,</span> <span class="n">y2</span><span class="o">))</span> <span class="k">=</span> <span class="o">(</span><span class="n">x1</span><span class="o">*</span><span class="n">y2</span> <span class="o">+</span> <span class="n">x2</span><span class="o">*</span><span class="n">y1</span><span class="o">,</span> <span class="n">y1</span><span class="o">*</span><span class="n">y2</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Again, we should be wary of floating point numbers in proving associativity!</p>

<h4 id="parallel-scan">Parallel scan</h4>
<p>Sequentially, <code class="highlighter-rouge">scanLeft</code> can be implemented as:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">scanLeft</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span>
                <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">out</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="n">a0</span>
    <span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="n">a0</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nv">inp</span><span class="o">.</span><span class="py">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">a</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="nf">inp</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
        <span class="n">i</span> <span class="k">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nf">out</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Can this be made parallel? We‚Äôll assume <code class="highlighter-rouge">f</code> is associative. Our goal is to have an $O(\log{n})$ algorithm (given infinite parallelism).</p>

<p>At first, this task seems almost impossible, because the value of the last element in sequence is computed from the previous element. And for every element, it looks like the natural way is indeed what we gave in the sequential algorithm. But even if we parallelize the individual applications of <code class="highlighter-rouge">f</code>, we would not be able to parallelize the traversal of the array itself. So this would give us still a linear algorithm even with infinite parallelism.</p>

<p>So, we need to perform computation in a different order, the idea is to give up reusing all intermediate results. And in fact, we will do more work and more applications of f that need the simple sequential version. However, this will allow us to improve parallelism and in terms of the parallel running time, more than compensate for the fact that we are applying f a few more times than in the sequential algorithm.</p>

<p>To show that this is even possible in parallel, here‚Äôs how we‚Äôd define it in terms of the parallel <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">reduce</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">scanLeft</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">fi</span> <span class="k">=</span> <span class="o">{</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">v</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">reduceSeg1</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="o">}</span>
    <span class="nf">mapSeg</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">inp</span><span class="o">.</span><span class="py">length</span><span class="o">,</span> <span class="n">fi</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">last</span> <span class="k">=</span> <span class="nv">inp</span><span class="o">.</span><span class="py">length</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nf">out</span><span class="o">(</span><span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nf">out</span><span class="o">(</span><span class="n">last</span><span class="o">),</span> <span class="nf">inp</span><span class="o">(</span><span class="n">last</span><span class="o">))</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="on-trees">On trees</h5>
<p>Let‚Äôs implement <code class="highlighter-rouge">scanLeft</code> on trees.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">upsweep</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">TreeRes</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">LeafRes</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">tL</span><span class="o">,</span> <span class="n">tR</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span><span class="nf">upsweep</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">f</span><span class="o">),</span> <span class="nf">upsweep</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">f</span><span class="o">))</span>
        <span class="nc">NodeRes</span><span class="o">(</span><span class="n">tL</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="nv">tL</span><span class="o">.</span><span class="py">res</span><span class="o">,</span> <span class="nv">tR</span><span class="o">.</span><span class="py">res</span><span class="o">),</span> <span class="n">tR</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// ‚Äôa0‚Äô is reduce of all elements left of the tree ‚Äôt‚Äô</span>
<span class="k">def</span> <span class="nf">downsweep</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">TreeRes</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span> <span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">LeafRes</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Leaf</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">a0</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">NodeRes</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">tL</span><span class="o">,</span> <span class="n">tR</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span><span class="n">downsweep</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="n">f</span><span class="o">),</span>
                                <span class="n">downsweep</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">a0</span><span class="o">,</span> <span class="nv">l</span><span class="o">.</span><span class="py">res</span><span class="o">),</span> <span class="n">f</span><span class="o">))</span>
        <span class="nc">Node</span><span class="o">(</span><span class="n">tL</span><span class="o">,</span> <span class="n">tR</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">prepend</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Node</span><span class="o">(</span><span class="nc">Leaf</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Node</span><span class="o">(</span><span class="nf">prepend</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">),</span> <span class="n">r</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">scanLeft</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">tRes</span> <span class="k">=</span> <span class="nf">upsweep</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">scan1</span> <span class="k">=</span> <span class="nf">downsweep</span><span class="o">(</span><span class="n">tRes</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
    <span class="nf">prepend</span><span class="o">(</span><span class="n">a0</span><span class="o">,</span> <span class="n">scan1</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here‚Äôs how downsweep works:</p>

<p><img src="/images/parcon/downsweep.gif" alt="Gif of downsweep" /></p>

<h5 id="on-arrays">On arrays</h5>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">upsweep</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">from</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
               <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">TreeResA</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">to</span> <span class="o">-</span> <span class="n">from</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="nc">Leaf</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="nf">reduceSeg1</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">from</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="nf">inp</span><span class="o">(</span><span class="n">from</span><span class="o">),</span> <span class="n">f</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">mid</span> <span class="k">=</span> <span class="n">from</span> <span class="o">+</span> <span class="o">(</span><span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="o">)/</span><span class="mi">2</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">tL</span><span class="o">,</span><span class="n">tR</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span><span class="nf">upsweep</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">f</span><span class="o">),</span>
                               <span class="nf">upsweep</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">f</span><span class="o">))</span>
        <span class="nc">Node</span><span class="o">(</span><span class="n">tL</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="nv">tL</span><span class="o">.</span><span class="py">res</span><span class="o">,</span><span class="nv">tR</span><span class="o">.</span><span class="py">res</span><span class="o">),</span> <span class="n">tR</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">reduceSeg1</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
                  <span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="n">a0</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="n">left</span>
    <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">a</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="nf">inp</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
        <span class="n">i</span> <span class="k">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="o">}</span>
    <span class="n">a</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">downsweep</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span>
                 <span class="n">t</span><span class="k">:</span> <span class="kt">TreeResA</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">scanLeftSeg</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="nf">val</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="nf">parallel</span><span class="o">(</span>
        <span class="nf">downsweep</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">out</span><span class="o">),</span>
        <span class="nf">downsweep</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">a0</span><span class="o">,</span><span class="nv">l</span><span class="o">.</span><span class="py">res</span><span class="o">),</span> <span class="n">f</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">out</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">def</span> <span class="nf">scanLeftSeg</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
                   <span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="n">left</span>
        <span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="n">a0</span>
        <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">a</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="nf">inp</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
            <span class="n">i</span> <span class="k">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="nf">out</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">scanLeft</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">inp</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span>
                <span class="n">out</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">t</span> <span class="k">=</span> <span class="nf">upsweep</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">inp</span><span class="o">.</span><span class="py">length</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
    <span class="nf">downsweegp</span><span class="o">(</span><span class="n">inp</span><span class="o">,</span> <span class="n">a0</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span> <span class="c1">// fills out[1..inp.length]</span>
    <span class="nf">out</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="n">a0</span> <span class="c1">// prepends a0</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="data-parallelism">Data parallelism</h3>
<p>So far, we‚Äôve learned about task-parallel programming:</p>

<blockquote>
  <p>A form of parallelization that distributes execution processes across computing nodes.</p>
</blockquote>

<p>In Scala, we express this with <code class="highlighter-rouge">task</code> and <code class="highlighter-rouge">parallel</code>.</p>

<p>Data-parallel programs have a different approach:</p>

<blockquote>
  <p>A form of parallelization that distributes data across computing nodes.</p>
</blockquote>

<p>Why would we want to use data-parallelism? It can be much faster than task parallelism (in the demo with Mandelbrot sets, it was 2x faster).</p>

<h4 id="workload">Workload</h4>
<p>Why are data parallel programs sometimes faster than task parallel ones?</p>

<p>Different data-parallel programs have different workloads. <strong>Workload</strong> is a function that maps each input element to the amount of work required to process it.</p>

<p><code class="highlighter-rouge">initializeArray</code> had a workload defined by a constant function, $w(i) = \text{const}$. We call this <strong>uniform workload</strong>, and it‚Äôs really easy to parallelize.</p>

<p>An <strong>irregular workload</strong> is one where the work is described by an arbitrary function: $w(i) = f(i)$. This is where we have a <strong>data-parallel scheduler</strong>, whose role is to efficiently balance the workload across processors without any knowledge about the $w(i)$. The idea of the scheduler is to shift away the task of balancing the workload from the programmer. They have similar semantics, so we won‚Äôt study them in detail.</p>

<h4 id="parallel-for-loop">Parallel for-loop</h4>
<p>To initialize arrays with a given value in parallel (writing <code class="highlighter-rouge">v</code> to every position in <code class="highlighter-rouge">xs</code>)</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">initializeArray</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span><span class="o">).</span><span class="py">par</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="n">v</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here, the <code class="highlighter-rouge">.par</code> method converts the range to a parallel range; the for loop will be executed in parallel. Parallel for-loops are not functional, do not return a value, and can therefore only communicate with the rest of the program through some side effect, such as writing to an array. Therefore, the parallel for-loop must write to separate memory locations or be synchronized in order to work.</p>

<h4 id="non-parallelizable-operations">Non-parallelizable operations</h4>
<p>In general terms, most sequential collections can be converted to parallel collections by using <code class="highlighter-rouge">.par</code>; <em>some</em> collection operations subsequently applied become data-parallel, but not all. Let‚Äôs look at an example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nv">xs</span><span class="o">.</span><span class="py">par</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This <strong>does not</strong> execute in parallel, as <code class="highlighter-rouge">foldLeft</code> has no way of <em>not</em> processing elements sequentially (its name implies that it must go left to right); <code class="highlighter-rouge">foldRight</code>, <code class="highlighter-rouge">reduceLeft</code>, <code class="highlighter-rouge">reduceRight</code>, <code class="highlighter-rouge">scanLeft</code> and <code class="highlighter-rouge">scanRight</code> similarly must process the elements sequentially and operate sequentially on parallel collections.</p>

<h4 id="parallelizable-operations">Parallelizable operations</h4>
<p>However, <code class="highlighter-rouge">fold</code> (without any direction) can process elements in parallel (see LEGO bricks explanation in lecture videos). Our previous <code class="highlighter-rouge">sum</code> function, and <code class="highlighter-rouge">max</code> could be written like this instead:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nv">xs</span><span class="o">.</span><span class="py">par</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">max</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nv">xs</span><span class="o">.</span><span class="py">par</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="nv">Int</span><span class="o">.</span><span class="py">MinValue</span><span class="o">)(</span><span class="nv">math</span><span class="o">.</span><span class="py">max</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>It is important to note that <code class="highlighter-rouge">fold</code> will work with a function <code class="highlighter-rouge">f</code> if:</p>

<ul>
  <li><code class="highlighter-rouge">f</code> is an <em>associative</em> operation</li>
  <li>When applied to the neutral element <code class="highlighter-rouge">z</code>, it must act as an identity function.</li>
</ul>

<p>In other words, the following relations must hold:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="o">==</span> <span class="nf">f</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="n">c</span><span class="o">)</span>
<span class="nf">f</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">==</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="o">==</span> <span class="n">a</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In more formal terms, the neutral element <em>z</em> and the binary operator <code class="highlighter-rouge">f</code> must form a <a href="http://mathworld.wolfram.com/Monoid.html">monoid</a>. Commutativity is not important for <code class="highlighter-rouge">fold</code>, but it is important that the neutral element <code class="highlighter-rouge">z</code> be of the same type as the collection items (unlike <code class="highlighter-rouge">foldLeft</code>); this is clear if we look at the signature of <code class="highlighter-rouge">fold</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">fold</span><span class="o">(</span><span class="n">z</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This seems like a lot of limitations, so we‚Äôll need a more powerful data parallel operation. Enter <code class="highlighter-rouge">aggregate</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">aggregate</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>What it does is divide the collection into pieces, applying the sequential folding operator <code class="highlighter-rouge">f</code> and combine results using the parallel folding operator <code class="highlighter-rouge">g</code>. Using it, we can do what we couldn‚Äôt do with <code class="highlighter-rouge">fold</code>: count the number of vowels in a character array:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nc">Array</span><span class="o">(</span><span class="sc">'E'</span><span class="o">,</span> <span class="sc">'P'</span><span class="o">,</span> <span class="sc">'F'</span><span class="o">,</span> <span class="sc">'L'</span><span class="o">).</span><span class="py">par</span><span class="o">.</span><span class="py">aggregate</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span>
    <span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">isVowel</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">count</span><span class="o">,</span>
    <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
<span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Again, the parallel reduction operator <code class="highlighter-rouge">g</code> and the neutral element <code class="highlighter-rouge">z</code> should form a <a href="http://mathworld.wolfram.com/Monoid.html">monoid</a> (<code class="highlighter-rouge">z</code> should be the neutral element of <code class="highlighter-rouge">g</code>). Note that this is <em>just</em> an ‚Äúif‚Äù, not ‚Äúif and only if‚Äù; the iff condition for <code class="highlighter-rouge">aggregate</code> to work is:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="o">(</span><span class="n">x1</span> <span class="o">++</span> <span class="n">x2</span><span class="o">).</span><span class="py">foldLeft</span><span class="o">(</span><span class="n">z</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span> <span class="o">==</span> <span class="nf">g</span><span class="o">(</span><span class="nv">x1</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="n">z</span><span class="o">)(</span><span class="n">f</span><span class="o">),</span> <span class="nv">x2</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="n">z</span><span class="o">)(</span><span class="n">f</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Alternatively, we can formulate this same requirement as two requirements, for all <code class="highlighter-rouge">u</code> and <code class="highlighter-rouge">v</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nf">g</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="o">==</span> <span class="n">u</span>                   <span class="c1">// g-right-unit</span>
<span class="nf">g</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span> <span class="o">==</span> <span class="nf">f</span><span class="o">(</span><span class="nf">g</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">),</span> <span class="n">x</span><span class="o">)</span> <span class="c1">// g-f-assoc</span>
</pre></td></tr></tbody></table></code></pre></figure>

<!-- We did this in group exercises. Martin Odersky came by at that moment, and joked "if it type checks, it's correct" -->

<p>Many other parallel collection operations can be expressed in terms of <code class="highlighter-rouge">aggregate</code>. So far we‚Äôve only seen <em>accessor</em> combinators (<code class="highlighter-rouge">sum</code>, <code class="highlighter-rouge">max</code>, <code class="highlighter-rouge">fold</code>, <code class="highlighter-rouge">count</code>, <code class="highlighter-rouge">aggregate</code>, ‚Ä¶). <em>Transformer</em> combinators (such as <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">groupBy</code>) do not return a single value, but instead return new collections as a result.</p>

<h4 id="parallel-collections">Parallel collections</h4>
<p>In sequential collections, the hierarchy is as follows:</p>

<ul>
  <li><code class="highlighter-rouge">Traversable[T]</code>: collection of elements with type <code class="highlighter-rouge">T</code>, with operations
implemented using foreach
    <ul>
      <li><code class="highlighter-rouge">Iterable[T]</code>: collection of elements with type <code class="highlighter-rouge">T</code>, with operations
implemented using iterator
        <ul>
          <li><code class="highlighter-rouge">Seq[T]</code>: an ordered sequence of elements with type <code class="highlighter-rouge">T</code></li>
          <li><code class="highlighter-rouge">Set[T]</code>: a set of elements with type <code class="highlighter-rouge">T</code> (no duplicates)</li>
          <li><code class="highlighter-rouge">Map[K, V]</code>: a map of keys with type K associated with values of type
V (no duplicate keys)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Traits <code class="highlighter-rouge">ParIterable[T]</code>, <code class="highlighter-rouge">ParSeq[T]</code>, <code class="highlighter-rouge">ParSet[T]</code> and <code class="highlighter-rouge">ParMap[K, V]</code> are the
parallel counterparts of different sequential traits. For code that is <em>agnostic</em> about parallelism, there exists a separate hierarchy of generic collection traits <code class="highlighter-rouge">GenIterable[T]</code>, <code class="highlighter-rouge">GenSeq[T]</code>, <code class="highlighter-rouge">GenSet[T]</code> and <code class="highlighter-rouge">GenMap[K, V]</code>.</p>

<p><img src="/images/parcon/generic_collections.png" alt="Hierarchy of generic collections" /></p>

<p>Using these generic collections, operations may or may not execute in parallel:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">largestPalindrome</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">GenSeq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nv">xs</span><span class="o">.</span><span class="py">aggregate</span><span class="o">(</span><span class="nv">Int</span><span class="o">.</span><span class="py">MinValue</span><span class="o">)((</span><span class="n">largest</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="o">&amp;&amp;</span> <span class="nv">n</span><span class="o">.</span><span class="py">toString</span> <span class="o">==</span> <span class="nv">n</span><span class="o">.</span><span class="py">toString</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="n">n</span> <span class="k">else</span> <span class="n">largest</span><span class="o">,</span>
        <span class="nv">math</span><span class="o">.</span><span class="py">max</span>
    <span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="nv">array</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="mi">1000000</span><span class="o">).</span><span class="py">toArray</span>

<span class="nf">largestPalindrome</span><span class="o">(</span><span class="n">array</span><span class="o">)</span> <span class="c1">// sequential</span>
<span class="nf">largestPalindrome</span><span class="o">(</span><span class="nv">array</span><span class="o">.</span><span class="py">par</span><span class="o">)</span> <span class="c1">// parallel</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In practice, parallelizable collections are:</p>

<ul>
  <li><code class="highlighter-rouge">ParArray[T]</code>: parallel array of objects, counterpart of Array and
ArrayBuffer</li>
  <li><code class="highlighter-rouge">ParRange</code>: parallel range of integers, counterpart of Range</li>
  <li><code class="highlighter-rouge">ParVector[T]</code>: parallel vector, counterpart of Vector</li>
  <li><code class="highlighter-rouge">immutable.ParHashSet[T]</code>: counterpart of immutable.HashSet</li>
  <li><code class="highlighter-rouge">immutable.ParHashMap[K, V]</code>: counterpart of immutable.HashMap</li>
  <li><code class="highlighter-rouge">mutable.ParHashSet[T]</code>: counterpart of mutable.HashSet</li>
  <li><code class="highlighter-rouge">mutable.PasHashMap[K, V]</code>: counterpart of mutable.HashMap</li>
  <li><code class="highlighter-rouge">ParTrieMap[K, V]</code>: thread-safe parallel map with atomic snapshots,
counterpart of <code class="highlighter-rouge">TrieMap</code></li>
  <li>for other collections, par creates the closest parallel collection: e.g. a
List is converted to a ParVector</li>
</ul>

<p>The last point stresses the importance of picking data structures carefully and making sure that they are parallelizable; otherwise, the conversion might take longer than the parallel instructions themselves.</p>

<h5 id="avoiding-parallel-errors">Avoiding parallel errors</h5>
<p>As we‚Äôve said previously, one should either synchronize or write to separate memory locations. To synchronize, we can use the Java <code class="highlighter-rouge">ConcurrentSkipListSet[T]</code> instead of Scala mutable Set. To avoid side-effects, we can use the right combinators (for instead, use <code class="highlighter-rouge">filter</code> instead of making your own code).</p>

<p>A rule to avoid concurrent modifications during traversals is to <em>never</em> read or write to a parallel collection on which a data-parallel operation is in progress.</p>

<p>The <code class="highlighter-rouge">TrieMap</code> collection is an exception to this; it atomically takes snapshots whenever a parallel operation starts, so concurrent updates aren‚Äôt observed during that time. It offers the <code class="highlighter-rouge">snapshot</code> method (efficient: constant time), which can be used to efficiently grab the current state.</p>

<h3 id="data-parallel-abstractions">Data-parallel abstractions</h3>
<p>Transformer operations are collection operations that create another collection instead of a single value. Methods such as <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">groupBy</code> are examples of transformer operations.</p>

<h4 id="iterators">Iterators</h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Iterator</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">next</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span>
    <span class="k">def</span> <span class="nf">hasNext</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
<span class="k">def</span> <span class="nf">iterator</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="c1">// on every collection</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <em>iterator contract</em> states that:</p>

<ul>
  <li><code class="highlighter-rouge">next</code> can be called only if <code class="highlighter-rouge">hasNext</code> returns <code class="highlighter-rouge">true</code>. That means that when defining <code class="highlighter-rouge">next</code>, one should always call <code class="highlighter-rouge">hasNext</code>.</li>
  <li>After <code class="highlighter-rouge">hasNext</code> returns <code class="highlighter-rouge">false</code>, it will always return <code class="highlighter-rouge">false</code></li>
</ul>

<h4 id="splitters">Splitters</h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Splitter</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Iterator</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">split</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Splitter</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
    <span class="k">def</span> <span class="nf">remaining</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>
<span class="k">def</span> <span class="nf">splitter</span><span class="k">:</span> <span class="kt">Splitter</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="c1">// on every parallel collection</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <em>splitter contract</em> states that:</p>

<ul>
  <li>After calling <code class="highlighter-rouge">split</code>, the original splitter is left in an undefined state</li>
  <li>The resulting splitters traverse disjoint subsets of the original splitter</li>
  <li><code class="highlighter-rouge">remaining</code> is an estimate on the number of remaining elements</li>
  <li><code class="highlighter-rouge">split</code> is an efficient method ‚Äì $O(\log{n})$ or better (since we invoke it in parallel in hopes of obtaining a speedup)</li>
</ul>

<h4 id="builders">Builders</h4>
<p>Builders are abstractions for creating new <strong>sequential</strong> collections. <code class="highlighter-rouge">T</code> denotes the type of the elements of the collection (e.g. <code class="highlighter-rouge">String</code>), and <code class="highlighter-rouge">Repr</code> is the type of the resulting collection of elements (e.g. <code class="highlighter-rouge">Seq[String]</code>).</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Builder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span> <span class="c1">// add element to the builder</span>
    <span class="k">def</span> <span class="nf">result</span><span class="k">:</span> <span class="kt">Repr</span> <span class="c1">// obtain collection after all elements are added </span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span> <span class="c1">// on every collection</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <em>builder contract</em> states that:</p>

<ul>
  <li>Calling <code class="highlighter-rouge">result</code> returns a collection of type <code class="highlighter-rouge">Repr</code>, containing the elements that were previously added with <code class="highlighter-rouge">+=</code></li>
  <li>Calling <code class="highlighter-rouge">result</code> leaves the Builder in an undefined state (after this we cannot use it anymore)</li>
</ul>

<h4 id="combiners">Combiners</h4>
<p>A combiner is a <strong>parallel</strong> version of a builder. It has the same <code class="highlighter-rouge">+=</code> and <code class="highlighter-rouge">result</code> methods as it <code class="highlighter-rouge">extends Builder</code>, but adds a method <code class="highlighter-rouge">combine</code> to merge two combiners (invalidating the two old combiners in the process).</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Combiner</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Builder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Combiner</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">])</span><span class="k">:</span> <span class="kt">Combiner</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">newCombiner</span><span class="k">:</span> <span class="kt">Combiner</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">Repr</span><span class="o">]</span> <span class="c1">// on every parallel collection</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <em>combiner contract</em> states that:</p>

<ul>
  <li>Calling <code class="highlighter-rouge">combine</code> returns a new combiner that contains elements of input combiners</li>
  <li>Calling <code class="highlighter-rouge">combine</code> leaves both original <code class="highlighter-rouge">Combiners</code> in an undefined state</li>
  <li><code class="highlighter-rouge">combine</code> is an efficient method ‚Äì $O(\log{n})$ or better (usually, this means that we should run it in parallel)</li>
</ul>

<h5 id="implementing-combiners">Implementing combiners</h5>
<p>How do we implement it efficiently ($O(\log{n}+\log{m})$)? We‚Äôll see that this depends on the underlying data structure; <code class="highlighter-rouge">Repr</code> could be a map, a set or a sequence, and that changes everything:</p>

<ul>
  <li>When <code class="highlighter-rouge">Repr</code> is a set or a map, <code class="highlighter-rouge">combine</code> represents <strong>union</strong></li>
  <li>When <code class="highlighter-rouge">Repr</code> is a sequence, <code class="highlighter-rouge">combine</code> represents <strong>concatenation</strong></li>
</ul>

<p>For <strong>arrays</strong>, there is no efficient <code class="highlighter-rouge">combine</code> operation. This has to do with how arrays are stored in memory; the two subarrays may be stored in different locations, which implies having to move one to the end of another; this cannot be done in logarithmic time, only in linear time.</p>

<p>For <strong>sets</strong>, we can use different data structures, that may have different runtimes for lookup, insertion and deletion:</p>

<ul>
  <li>Hash tables: expected $O(1)$</li>
  <li>Balanced trees: $O(\log{n})$</li>
  <li>Linked lists: $O(\log{n})$</li>
</ul>

<p>Unfortunately, most set implementations do not have an efficient union operation, so <code class="highlighter-rouge">combine</code> is tricky to implement.</p>

<p>For <strong>sequences</strong>, there are also a few data structures, with which the operation complexity varies.</p>

<ul>
  <li>Mutable linked lists: $O(1)$ prepend and append, $O(n)$ insertion</li>
  <li>Functional (cons) lists: $O(1)$ prepend, everything else $O(n)$</li>
  <li>Array lists: amortized $O(1)$ append, $O(1)$ random access, otherwise $O(n)$</li>
</ul>

<p><em>(Amortized means that we may need to copy the array to another location when we need more space, but overall we expect it to be constant time on average.)</em></p>

<p>Mutable linked lists can have $O(1)$ concatenation, but for most sequences, concatenation is $O(n)$.</p>

<p>All of the above shows that providing a combiner for the corresponding collections is not straightforward, since most parallel data structures do not have the efficient union or concatenation operation we want ‚Äî but it is still possible to implement.</p>

<h5 id="two-phase-construction">Two-phase construction</h5>
<p>Most data structures can be constructed in parallel using <em>two-phase</em> construction. Here, the combiner doesn‚Äôt use the final data structure in its internal representation; it uses an intermediate data structure that:</p>

<ul>
  <li>Has an efficient <code class="highlighter-rouge">combine</code> method: $O(\log{n}+\log{m})$ or better</li>
  <li>Has an efficient <code class="highlighter-rouge">+=</code> method (this ensures that individual processors can efficiently modify the data structure)</li>
  <li>Can be converted to the resulting data structure in $O(n/P)$ time (<em>n</em> size of data structure, <em>P</em> number of processors)</li>
</ul>

<p>Let‚Äôs implement it for arrays:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">ArrayCombiner</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="k">val</span> <span class="nv">parallelism</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> 
    <span class="c1">// parallelism = parallelism level</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">numElems</span> <span class="k">=</span> <span class="mi">0</span> <span class="c1">// # of elements in the combiner</span>
    <span class="k">private</span> <span class="k">val</span> <span class="nv">buffers</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">ArrayBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="c1">// nested ArrayBuffer</span>
    <span class="n">buffers</span> <span class="o">+=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

    <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="c1">// Amortized O(1)</span>
        <span class="c1">// if the ArrayBuffer ever gets full,</span>
        <span class="c1">// it is expanded to accommodate more elements</span>
        <span class="nv">buffers</span><span class="o">.</span><span class="py">last</span> <span class="o">+=</span> <span class="n">x</span>
        <span class="n">numElems</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">this</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">ArrayCombiner</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span> <span class="c1">// O(P) since there are P array combiners</span>
        <span class="n">buffers</span> <span class="o">++=</span> <span class="nv">that</span><span class="o">.</span><span class="py">buffers</span> <span class="c1">// copies references</span>
        <span class="n">numElems</span> <span class="o">+=</span> <span class="nv">that</span><span class="o">.</span><span class="py">numElems</span>
        <span class="k">this</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">result</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">array</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">numElems</span><span class="o">)</span>
        <span class="k">val</span> <span class="nv">step</span> <span class="k">=</span> <span class="nv">math</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">numElems</span> <span class="o">/</span> <span class="n">parallelism</span><span class="o">)</span>
        <span class="k">val</span> <span class="nv">starts</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">numElems</span> <span class="n">by</span> <span class="n">step</span><span class="o">)</span> <span class="o">:+</span> <span class="n">numElems</span>
        <span class="k">val</span> <span class="nv">chunks</span> <span class="k">=</span> <span class="nv">starts</span><span class="o">.</span><span class="py">zip</span><span class="o">(</span><span class="nv">starts</span><span class="o">.</span><span class="py">tail</span><span class="o">)</span>
        <span class="k">val</span> <span class="nv">tasks</span> <span class="k">=</span> <span class="nf">for</span> <span class="o">((</span><span class="n">from</span><span class="o">,</span> <span class="n">end</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">chunks</span><span class="o">)</span> <span class="k">yield</span> <span class="n">task</span> <span class="o">{</span>
           <span class="nf">copyTo</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">end</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="nv">tasks</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">join</span><span class="o">())</span>
        <span class="n">array</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Benchmarks show over 2x speedups with 4 (not linear because of the memory access bottleneck). So for arrays:</p>

<ol>
  <li>partition the indices into subintervals</li>
  <li>initialize the array in parallel</li>
</ol>

<p>For hash tables:</p>

<ol>
  <li>partition the hash codes into buckets (e.g. linked lists of arrays) according to their hashcode prefix</li>
  <li>allocate the table, and map hash codes from different buckets into different regions</li>
</ol>

<p>For search trees:</p>

<ol>
  <li>partition the elements into non-overlapping intervals according to
their ordering</li>
  <li>construct search trees in parallel, and link non-overlapping trees (which is efficient when they‚Äôre non-overlapping)</li>
</ol>

<p>Spatial data structures (see exercises):</p>

<ol>
  <li>spatially partition the elements</li>
  <li>construct non-overlapping subsets and link them</li>
</ol>

<p>So as a conclusion, how can we implement combiners?</p>

<ol>
  <li><strong>Two-phase construction</strong>: the combiner uses an intermediate data
structure with an efficient combine method to partition the elements.
When result is called, the final data structure is constructed in
parallel from the intermediate data structure.</li>
  <li><strong>An efficient concatenation or union operation</strong>: a preferred way when
the resulting data structure allows this.</li>
  <li><strong>Concurrent data structure</strong>: different combiners share the same
underlying data structure, and rely on synchronization to correctly
update the data structure when <code class="highlighter-rouge">+=</code> is called.</li>
</ol>

<p>We‚Äôll look more into the second method, which is more suited for parallel computations.</p>

<h5 id="conc-trees">Conc-Trees</h5>
<p><code class="highlighter-rouge">Conc</code> is the parallel counterpart to parallel cons lists, and is used to manipulate data. Let‚Äôs compare them to other data structures with an example: the implementation of <code class="highlighter-rouge">filter</code>:</p>

<p>Lists are built for sequential computations, and are traversed left to right:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">filter</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">lst</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">lst</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">if</span> <span class="nf">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">filter</span><span class="o">(</span><span class="n">xs</span><span class="o">)(</span><span class="n">p</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">xs</span><span class="o">)(</span><span class="n">p</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Trees allow parallel computations ‚Äì their subtrees can be traversed in
parallel (this is not a search tree, just a regular tree):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">filter</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Node</span><span class="o">(</span><span class="nf">parallel</span><span class="o">(</span><span class="nf">filter</span><span class="o">(</span><span class="n">left</span><span class="o">)(</span><span class="n">p</span><span class="o">),</span> <span class="nf">filter</span><span class="o">(</span><span class="n">right</span><span class="o">)(</span><span class="n">p</span><span class="o">)))</span>
    <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">p</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span> <span class="n">t</span> <span class="k">else</span> <span class="nc">Empty</span>
    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Empty</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Trees are not good for parallelism unless they are balanced. Let‚Äôs devise a data type called <code class="highlighter-rouge">Conc</code>, which represents balanced trees:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Conc</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">level</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// level of subtree</span>
    <span class="k">def</span> <span class="nf">size</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// size of subtree</span>
    <span class="k">def</span> <span class="nf">left</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
    <span class="k">def</span> <span class="nf">right</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Conc</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">level</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">size</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Single</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">level</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">size</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span>
<span class="c1">// "Conc class": you can go left &lt; or right &gt;</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">&lt;&gt;</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">left</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">level</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nv">math</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="nv">left</span><span class="o">.</span><span class="py">level</span><span class="o">,</span> <span class="nv">right</span><span class="o">.</span><span class="py">level</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">size</span> <span class="k">=</span> <span class="nv">left</span><span class="o">.</span><span class="py">size</span> <span class="o">+</span> <span class="nv">right</span><span class="o">.</span><span class="py">size</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In addition, we will define the following <em>invariants</em> for Conc-trees:</p>

<ol>
  <li>A <code class="highlighter-rouge">&lt;&gt;</code> node can never contain <code class="highlighter-rouge">Empty</code> as its subtree. This guards us from sparse trees with too many empty subtrees</li>
  <li>The level (read: height) difference between the left and the right subtree of a <code class="highlighter-rouge">&lt;&gt;</code> node is always 1 or less. This ensures that the height is bounded by $\log{n}$.</li>
</ol>

<p>Concatenation is then:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">&lt;&gt;</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="nc">Empty</span><span class="o">)</span> <span class="n">that</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">that</span> <span class="o">==</span> <span class="nc">Empty</span><span class="o">)</span> <span class="k">this</span>
    <span class="k">else</span> <span class="nf">concat</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">that</span><span class="o">)</span> <span class="c1">// delegate real work to concat</span>
                            <span class="c1">// which may reorganize the tree completely</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">concat</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">diff</span> <span class="k">=</span> <span class="nv">ys</span><span class="o">.</span><span class="py">level</span> <span class="o">-</span> <span class="nv">xs</span><span class="o">.</span><span class="py">level</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">diff</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">new</span> <span class="o">&lt;&gt;(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="c1">// link the trees</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">if</span> <span class="o">(</span><span class="nv">xs</span><span class="o">.</span><span class="py">left</span><span class="o">.</span><span class="py">level</span> <span class="o">&gt;=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">right</span><span class="o">.</span><span class="py">level</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Left leaning (left deeper)</span>
            <span class="k">val</span> <span class="nv">nr</span> <span class="k">=</span> <span class="nf">concat</span><span class="o">(</span><span class="nv">xs</span><span class="o">.</span><span class="py">right</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
            <span class="k">new</span> <span class="o">&lt;&gt;(</span><span class="nv">xs</span><span class="o">.</span><span class="py">left</span><span class="o">,</span> <span class="n">nr</span><span class="o">)</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// Right leaning</span>
            <span class="k">val</span> <span class="nv">nrr</span> <span class="k">=</span> <span class="nf">concat</span><span class="o">(</span><span class="nv">xs</span><span class="o">.</span><span class="py">right</span><span class="o">.</span><span class="py">right</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
            <span class="nf">if</span> <span class="o">(</span><span class="nv">nrr</span><span class="o">.</span><span class="py">level</span> <span class="o">==</span> <span class="nv">xs</span><span class="o">.</span><span class="py">level</span> <span class="o">-</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">val</span> <span class="nv">nl</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">left</span>
                <span class="k">val</span> <span class="nv">nr</span> <span class="k">=</span> <span class="k">new</span> <span class="o">&lt;&gt;(</span><span class="nv">xs</span><span class="o">.</span><span class="py">right</span><span class="o">.</span><span class="py">left</span><span class="o">,</span> <span class="n">nrr</span><span class="o">)</span>
                <span class="k">new</span> <span class="o">&lt;&gt;(</span><span class="n">nl</span><span class="o">,</span> <span class="n">nr</span><span class="o">)</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">val</span> <span class="nv">nl</span> <span class="k">=</span> <span class="k">new</span> <span class="o">&lt;&gt;(</span><span class="nv">xs</span><span class="o">.</span><span class="py">left</span><span class="o">,</span> <span class="nv">xs</span><span class="o">.</span><span class="py">right</span><span class="o">.</span><span class="py">left</span><span class="o">)</span> <span class="c1">// new left</span>
                <span class="k">val</span> <span class="nv">nr</span> <span class="k">=</span> <span class="n">nrr</span> <span class="c1">// new right</span>
                <span class="k">new</span> <span class="o">&lt;&gt;(</span><span class="n">nl</span><span class="o">,</span> <span class="n">nr</span><span class="o">)</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Concatenation takes $O(h_1 ‚àí h_2)$ time, where $h_1$ and $h_2$ are the heights of the two trees.</p>

<h5 id="combiners-using-conc-trees">Combiners using Conc-Trees</h5>
<p>First we‚Äôll implement <code class="highlighter-rouge">+=</code>. To make it efficient ($O(1)$), We extend the Conc-Tree with a new node type:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">left</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">level</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nv">math</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="nv">left</span><span class="o">.</span><span class="py">level</span><span class="o">,</span> <span class="nv">right</span><span class="o">.</span><span class="py">level</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">size</span> <span class="k">=</span> <span class="nv">left</span><span class="o">.</span><span class="py">size</span> <span class="o">+</span> <span class="nv">right</span><span class="o">.</span><span class="py">size</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">Append</code> node has the same structure as a regular <code class="highlighter-rouge">&lt;&gt;</code> Conc node, and it has the same level and size; however, we will not impose the balance invariant on it. Trees of arbitrary size difference are allowed. To append a leaf:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">appendLeaf</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Append</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Single</span><span class="o">(</span><span class="n">y</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is indeed $O(1)$ but creates an unbalanced tree, which means concatenation will be $O(n)$ instead of $O(\log{n})$.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">appendLeaf</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Single</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="n">ys</span>
    <span class="k">case</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">Single</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="o">&lt;&gt;(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="o">&lt;&gt;</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Append</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">Append</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nf">append</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="c1">// delegate work to append</span>
<span class="o">}</span>

<span class="nd">@tailrec</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Append</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">xs</span><span class="o">.</span><span class="py">right</span><span class="o">.</span><span class="py">level</span> <span class="o">&gt;</span> <span class="nv">ys</span><span class="o">.</span><span class="py">level</span><span class="o">)</span> <span class="k">new</span> <span class="nc">Append</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">zs</span> <span class="k">=</span> <span class="k">new</span> <span class="o">&lt;&gt;(</span><span class="nv">xs</span><span class="o">.</span><span class="py">right</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
        <span class="nv">xs</span><span class="o">.</span><span class="py">left</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">ws</span> <span class="k">@</span> <span class="nc">Append</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">append</span><span class="o">(</span><span class="n">ws</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span>
            <span class="k">case</span> <span class="n">ws</span> <span class="k">if</span> <span class="nv">ws</span><span class="o">.</span><span class="py">level</span> <span class="o">&lt;=</span> <span class="nv">zs</span><span class="o">.</span><span class="py">level</span> <span class="k">=&gt;</span> <span class="n">ws</span> <span class="o">&lt;&gt;</span> <span class="n">zs</span>
            <span class="k">case</span> <span class="n">ws</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Append</span><span class="o">(</span><span class="n">ws</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We have implemented an <em>immutable</em> data structure with:</p>

<ul>
  <li>$O(1)$ appends</li>
  <li>$O(\log{n})$ concatenation</li>
</ul>

<p>Transforming a Conc-Tree with <code class="highlighter-rouge">Append</code> nodes into a regular Conc-Tree should be fairly straightforward from this point on (concatenate trees from append list together). We almost have a functioning combiner; we just need to do a little more work.</p>

<p>The <code class="highlighter-rouge">ConcBuffer</code> appends elements into an array of size <em>k</em>. When the array gets full, it is stored into a <code class="highlighter-rouge">Chunk</code> node and added into the Conc-tree.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">ConcBuffer</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="k">val</span> <span class="nv">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">private</span> <span class="k">var</span> <span class="n">conc</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">(</span><span class="n">k</span><span class="o">)</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">chunkSize</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">final</span> <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">chunkSize</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="nf">expand</span><span class="o">()</span> <span class="c1">// push array into conc-tree</span>
        <span class="nf">chunk</span><span class="o">(</span><span class="n">chunkSize</span><span class="o">)</span> <span class="k">=</span> <span class="n">elem</span>
        <span class="n">chunkSize</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">}</span>

    <span class="k">private</span> <span class="k">def</span> <span class="nf">expand</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">conc</span> <span class="k">=</span> <span class="nf">appendLeaf</span><span class="o">(</span><span class="n">conc</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Chunk</span><span class="o">(</span><span class="n">chunk</span><span class="o">,</span> <span class="n">chunkSize</span><span class="o">))</span>
        <span class="n">chunk</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">(</span><span class="n">k</span><span class="o">)</span>
        <span class="n">chunkSize</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="o">}</span>

    <span class="k">final</span> <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">ConcBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">ConcBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">combinedConc</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="py">result</span> <span class="o">&lt;&gt;</span> <span class="nv">that</span><span class="o">.</span><span class="py">result</span> <span class="c1">// obtain conc-trees from buffers</span>
        <span class="k">new</span> <span class="nc">ConcBuffer</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">combinedConc</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">result</span><span class="k">:</span> <span class="kt">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="c1">// packs chuck array into the tree, returns resulting tree</span>
        <span class="n">conc</span> <span class="k">=</span> <span class="nf">appendLeaf</span><span class="o">(</span><span class="n">conc</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Chunk</span><span class="o">(</span><span class="n">chunk</span><span class="o">,</span> <span class="n">chunkSize</span><span class="o">))</span>
        <span class="n">conc</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Chunk</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">val</span> <span class="nv">array</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="k">val</span> <span class="nv">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Conc</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">level</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">Chunk</code> nodes are similar to <code class="highlighter-rouge">Single</code> nodes, but instead of a single element, they hold an array of elements.</p>

<p>Summary:</p>

<ul>
  <li>$O(\log{n})$ <code class="highlighter-rouge">combine</code> concatenation</li>
  <li>Fast $O(1)$ <code class="highlighter-rouge">+=</code> operation</li>
  <li>$O(1)$ <code class="highlighter-rouge">result</code> operation</li>
</ul>

<h2 id="part-2-concurrent-programming">Part 2: Concurrent programming</h2>

<h3 id="a-surprising-program">A surprising program</h3>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">var</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="k">=</span> <span class="kc">false</span>
<span class="k">var</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="k">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">val</span> <span class="nv">t1</span> <span class="k">=</span> <span class="n">thread</span> <span class="o">{</span>
    <span class="nv">Thread</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// pause for 1ms</span>
    <span class="n">a</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="n">y</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>    
<span class="o">}</span>
<span class="k">val</span> <span class="nv">t2</span> <span class="k">=</span> <span class="n">thread</span> <span class="o">{</span>
    <span class="nv">Thread</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// pause for 1ms</span>
    <span class="n">b</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="n">x</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
<span class="o">}</span>
<span class="nv">t1</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="nv">t2</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="nf">assert</span><span class="o">(!(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we try to mentally simulate all runtime scenarios, where the threads execute in parallel, we can distrniguish three scenarios:</p>

<ul>
  <li><code class="highlighter-rouge">y = 1</code>, <code class="highlighter-rouge">x = 0</code></li>
  <li><code class="highlighter-rouge">y = 0</code>, <code class="highlighter-rouge">x = 1</code></li>
  <li><code class="highlighter-rouge">y = 0</code>, <code class="highlighter-rouge">x = 0</code></li>
</ul>

<p>In no scenario do we have <code class="highlighter-rouge">x = 1</code>, <code class="highlighter-rouge">y = 1</code>. Yet if we run this program, we do encounter this scenario! Let‚Äôs rebuild our intuition of concurrent programming.</p>

<p>Every concurrent programming model must answer two questions:</p>

<ol>
  <li>How to express that two executions are concurrent?</li>
  <li>Given a set of concurrent executions, how can they exchange
information (i.e. synchronize)?</li>
</ol>

<p>In what follows, we will answer these two questions in the context of the
JVM concurrency model.</p>

<h3 id="overview-of-threads">Overview of threads</h3>
<p>The thread notation starts a new thread ‚Äì a concurrent execution.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="n">thread</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="n">y</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The thread function is implemented as follows:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">thread</span><span class="o">(</span><span class="n">body</span><span class="k">:</span> <span class="o">=&gt;</span><span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Thread</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="k">override</span> <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="k">=</span> <span class="n">body</span>
    <span class="o">}</span>
    <span class="nv">t</span><span class="o">.</span><span class="py">start</span><span class="o">()</span>
    <span class="n">t</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We need threads, instead of working directly with the CPU for two reasons:</p>

<ul>
  <li><strong>Portability</strong>: We don‚Äôt know which / how many CPUs to address, since this depends on the system</li>
  <li>The number of concurrent entities in a program can be much larger than the number of CPUs</li>
</ul>

<p>Threads work as an abstraction. A thread image in memory contains:</p>

<ul>
  <li>Copies of processor registers</li>
  <li>The call stack (~2MB per default)</li>
</ul>

<p>The operating system eventually assigns threads to processes (the OS
guarantees liveness). Two approaches:</p>

<ul>
  <li>Cooperative multitasking: a program has to explicitly give control (yield) back to the OS (think Windows 3.1)</li>
  <li>Preemptive multitasking: the OS has a hardware timer that periodically interrupts the running thread, and assigns different thread to the CPU (time slices usually ~10 ms)</li>
</ul>

<h4 id="some-more-definitions">Some more definitions</h4>

<p><strong>Non-deterministic program</strong>: Given the same input, the program output is not unique between multiple runs. We want to write deterministic programs!</p>

<p>When <code class="highlighter-rouge">join</code> returns, the effects of the terminated thread are visible to the
thread that called <code class="highlighter-rouge">join</code>.</p>

<p>To avoid <em>race conditions</em>, we want to ensure that all operations of a function are performed <em>atomically</em>, without another thread reading or writing intermediate results. To do so, we used <code class="highlighter-rouge">synchronized</code> blocks, as seen previously (remember how it places a lock on the object).</p>

<h3 id="monitors">Monitors</h3>
<p>How do we know if a monitor is released? We could do <em>polling</em> (also called <em>busy waiting</em>), but that consumes compute time while waiting. Instead, we can use a notification; indeed, all <code class="highlighter-rouge">Monitor</code> objects have the following methods:</p>

<ul>
  <li><code class="highlighter-rouge">wait()</code>: suspends the current thread</li>
  <li><code class="highlighter-rouge">notify()</code>: wakes up one other thread waiting on the current object</li>
  <li><code class="highlighter-rouge">notifyAll()</code>: wakes up all other thread waiting on the current object</li>
</ul>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">OnePlaceBuffer</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Monitor</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="k">_</span><span class="o">;</span> <span class="k">var</span> <span class="n">full</span> <span class="k">=</span> <span class="kc">false</span>
    <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">synchronized</span> <span class="o">{</span>
        <span class="nf">while</span> <span class="o">(</span><span class="n">full</span><span class="o">)</span> <span class="nf">wait</span><span class="o">()</span>
        <span class="n">elem</span> <span class="k">=</span> <span class="n">e</span>
        <span class="n">full</span> <span class="k">=</span> <span class="kc">true</span>
        <span class="nf">notifyAll</span><span class="o">()</span>
    <span class="o">}</span>
    <span class="k">def</span> <span class="nf">get</span><span class="o">()</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="n">synchronized</span> <span class="o">{</span>
        <span class="nf">while</span> <span class="o">(!</span><span class="n">full</span><span class="o">)</span> <span class="nf">wait</span><span class="o">()</span>
        <span class="n">full</span> <span class="k">=</span> <span class="kc">false</span>
        <span class="nf">notifyAll</span><span class="o">()</span>
        <span class="n">elem</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The fine print:</p>

<ul>
  <li><code class="highlighter-rouge">wait</code>, <code class="highlighter-rouge">notify</code> and <code class="highlighter-rouge">notifyAll</code> should <strong>only</strong> be called from within a
<code class="highlighter-rouge">synchronized</code> on <code class="highlighter-rouge">this</code></li>
  <li><code class="highlighter-rouge">wait</code> will release the lock, so other threads can enter the monitor</li>
  <li><code class="highlighter-rouge">notify</code> and <code class="highlighter-rouge">notifyAll</code> schedule other threads for execution after the calling thread has released the lock (has left the monitor)</li>
  <li>On the JVM runtime, it is possible that a thread calling <code class="highlighter-rouge">wait</code>
sometimes wakes up even if nobody called <code class="highlighter-rouge">notify</code> or <code class="highlighter-rouge">notifyAll</code>. This is why we use <code class="highlighter-rouge">while</code> and not <code class="highlighter-rouge">if</code>.</li>
  <li>In practice, we‚Äôll use <code class="highlighter-rouge">notifyAll()</code> much more often</li>
</ul>

<h4 id="memory-model-1">Memory model</h4>
<p>A <em>memory model</em> is a set of rules that defines how and when the writes to
memory by one thread become visible to other threads. Consider our introductory example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">var</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="k">=</span> <span class="kc">false</span>
<span class="k">var</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="k">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">val</span> <span class="nv">t1</span> <span class="k">=</span> <span class="n">thread</span> <span class="o">{</span>
    <span class="nv">Thread</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// pause for 1ms</span>
    <span class="n">a</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="n">y</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>    
<span class="o">}</span>
<span class="k">val</span> <span class="nv">t2</span> <span class="k">=</span> <span class="n">thread</span> <span class="o">{</span>
    <span class="nv">Thread</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// pause for 1ms</span>
    <span class="n">b</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="n">x</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
<span class="o">}</span>
<span class="nv">t1</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="nv">t2</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="nf">assert</span><span class="o">(!(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>When we initially analyzed the introductory example, we assumed that
every read and write happens in the program order, and that every read
and write goes to main memory. That specific memory model is called the sequential consistency model. More formally:</p>

<blockquote>
  <p>Consider all the reads and writes to program variables. If the
result of the execution is the same as if the read and write
operations were executed in some sequential order, and the
operations of each individual processor appear in the program
order, then the model is sequentially consistent.</p>
</blockquote>

<p>Unfortunately, as we saw in our experiment, multicore processors and
compilers do not implement the sequential consistency model.</p>

<p>The <strong>Java Memory Model</strong> (JMM) defines a ‚Äú<em>happens-before</em>‚Äù relationship as follows.</p>

<ul>
  <li><strong>Program order</strong>: Each action in a thread <em>happens-before</em> every
subsequent action in the same thread.</li>
  <li><strong>Monitor locking</strong>: Unlocking a monitor <em>happens-before</em> every
subsequent locking of that monitor.</li>
  <li><strong>Volatile fields</strong>: A write to a volatile field <em>happens-before</em> every
subsequent read of that field.</li>
  <li><strong>Thread start</strong>: A call to <code class="highlighter-rouge">start()</code> on a thread <em>happens-before</em> all
actions of that thread.</li>
  <li><strong>Thread termination</strong>: An action in a thread <em>happens-before</em> another
thread completes a join on that thread.</li>
  <li><strong>Transitivity</strong>: If A happens before B and B <em>happens-before</em> C, then A
<em>happens-before</em> C.</li>
</ul>

<p>This means:</p>

<ul>
  <li>A program point of a thread <em>t</em> is <em>guaranteed</em> to see all actions that <em>happen_before</em> it.</li>
  <li>It <em>may</em> (<strong>may</strong>) also see actions that can occur before it in the sequential consistency (interleaving) model.</li>
</ul>

<p>Back to our surprising program:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">var</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="k">=</span> <span class="kc">false</span>
<span class="k">var</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="k">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">val</span> <span class="nv">t1</span> <span class="k">=</span> <span class="n">thread</span> <span class="o">{</span>
    <span class="nv">Thread</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// pause for 1ms</span>
    <span class="n">a</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="n">y</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>    
<span class="o">}</span>
<span class="k">val</span> <span class="nv">t2</span> <span class="k">=</span> <span class="n">thread</span> <span class="o">{</span>
    <span class="nv">Thread</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// pause for 1ms</span>
    <span class="n">b</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="n">x</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
<span class="o">}</span>
<span class="nv">t1</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="nv">t2</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="nf">assert</span><span class="o">(!(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This can fail since the two threads operate on their separate copy of memory, and can therefore have outdated information compared to each other.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">var</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="k">=</span> <span class="kc">false</span>
<span class="k">var</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="k">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">val</span> <span class="nv">t1</span> <span class="k">=</span> <span class="n">thread</span> <span class="o">{</span>
    <span class="n">synchronized</span> <span class="o">{</span> <span class="n">a</span> <span class="k">=</span> <span class="kc">true</span> <span class="o">}</span>
    <span class="n">synchronized</span> <span class="o">{</span> <span class="n">y</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">}</span>
<span class="o">}</span>
<span class="k">val</span> <span class="nv">t2</span> <span class="k">=</span> <span class="n">thread</span> <span class="o">{</span>
    <span class="n">synchronized</span> <span class="o">{</span> <span class="n">b</span> <span class="k">=</span> <span class="kc">true</span> <span class="o">}</span>
    <span class="n">synchronized</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">}</span>
<span class="o">}</span>
<span class="nv">t1</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="nv">t2</span><span class="o">.</span><span class="py">join</span><span class="o">()</span>
<span class="nf">assert</span><span class="o">(!(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This would work though! Because <code class="highlighter-rouge">synchronized</code> <strong>synchronizes the processor caches with <em>main memory</em></strong> at the end of its execution.</p>

<p>In general, a memory model is an abstraction of the hardware capabilities of different computer systems. It essentially abstracts over the underlying system‚Äôs <em>cache coherence protocol</em>.</p>

<h5 id="volatile-fields">Volatile fields</h5>
<p>A volatile field is a field that may change at any time, thanks to another thread. Making a variable <code class="highlighter-rouge">@volatile</code> has several effects:</p>

<ul>
  <li>Reads and writes to volatile variables are never reordered by the compiler.</li>
  <li>Reads and writes are never cached in CPU registers ‚Äî they go directly to the main memory</li>
  <li>Writes to normal variables, that in the program precede a volatile write <em>W</em>, cannot be moved by the compiler after <em>W</em></li>
  <li>Reads from normal variables that in the program appear after a volatile read <em>R</em> cannot be moved by the compiler before R.</li>
  <li>Before a volatile write, values cached in registers must be written back to main memory.</li>
  <li>After a volatile read, values cached in registers must be re-read from the main memory.</li>
</ul>

<p>Writes to <code class="highlighter-rouge">@volatile</code> are somewhat expensive (~50% as much as <code class="highlighter-rouge">synchronized</code>), but reads are very cheap. But <code class="highlighter-rouge">@volatile</code> offers fewer guarantees than <code class="highlighter-rouge">synchronized</code>.</p>

<h4 id="executors">Executors</h4>
<p>Threads have a lot of nice guarantees, but they are expensive to create. What people do to counteract that is use threads as workhorses that perform the tasks given to them. The number of available threads in a pool is typically some polynomial of the number of cores $N$ (e.g. $N^2$).</p>

<p>A task presented to an executor is encapsulated in a <code class="highlighter-rouge">Runnable</code> object:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="c1">// actions to be performed by the task</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here‚Äôs how a task gets passed to the <code class="highlighter-rouge">ForkJoinPool</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">java.util.concurrent.ForkJoinPool</span>
<span class="k">object</span> <span class="nc">ExecutorsCreate</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">executor</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ForkJoinPool</span>
    <span class="nv">executor</span><span class="o">.</span><span class="py">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="k">=</span> <span class="nf">log</span><span class="o">(</span><span class="s">"This task is run async"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="nv">Thread</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that there is no way to await the end of a task like we did with <code class="highlighter-rouge">t.join()</code> for threads. Instead, we pause the main thread to give the executor threads time to finish.</p>

<p>The <code class="highlighter-rouge">scala.concurrent</code> package defines the <code class="highlighter-rouge">ExecutionContext</code> trait and object which is similar to <code class="highlighter-rouge">Executor</code> but more specific to Scala.</p>

<p>Execution contexts are passed as implicit parameters to many of Scala‚Äôs concurrency abstractions. Here‚Äôs how one runs a task using the default execution context:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">scala.concurrent</span>
<span class="k">object</span> <span class="nc">ExecutionContextCreate</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">ectx</span> <span class="k">=</span> <span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span>
    <span class="nv">ectx</span><span class="o">.</span><span class="py">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="k">=</span> <span class="nf">log</span><span class="o">(</span><span class="s">"This task is run async"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="nv">Thread</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To hide all of this boilerplate, we can put it all in an <code class="highlighter-rouge">execute</code> function.</p>

<h4 id="atomic-primitives">Atomic primitives</h4>
<p><code class="highlighter-rouge">synchronized</code>, <code class="highlighter-rouge">wait</code>, <code class="highlighter-rouge">notify</code>, <code class="highlighter-rouge">notifyAll</code> are complex and require support from the OS scheduler. We now look at the primitives in terms of which these higher-level operations are implemented.</p>

<p>An atomic variable is a memory location that supports <strong>linearizable</strong> operations (meaning that can be executed atomically). Here‚Äôs how we can define <code class="highlighter-rouge">getUID</code> without <code class="highlighter-rouge">synchronized</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">java.util.concurrent.atomic._</span>
<span class="k">object</span> <span class="nc">AtomicUid</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">val</span> <span class="nv">uid</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicLong</span><span class="o">(</span><span class="mi">0L</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">getUID</span><span class="o">()</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="nv">uid</span><span class="o">.</span><span class="py">incrementAndGet</span><span class="o">()</span>
    <span class="n">execute</span> <span class="o">{</span>
        <span class="nf">log</span><span class="o">(</span><span class="n">s</span><span class="s">"Got a unique id asynchronously: ${getUID()}"</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="nf">log</span><span class="o">(</span><span class="n">s</span><span class="s">"God a unique id: ${getUID()}"</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">AtomicLong</code> offers the atomic operations <code class="highlighter-rouge">incrementAndGet()</code> <code class="highlighter-rouge">getAndSet(newValue: Long)</code>, and <code class="highlighter-rouge">compareAndSet(expect: Long, update: Long)</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">AtomicLong</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="c1">// Functionally equivalent to the following (but in hardware):</span>
    <span class="k">def</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="n">expect</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">update</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
        <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">get</span> <span class="o">==</span> <span class="n">expect</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="py">set</span><span class="o">(</span><span class="n">update</span><span class="o">);</span> <span class="kc">true</span> <span class="o">}</span>
        <span class="k">else</span> <span class="kc">false</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">compareAndSet</code>, also known as CAS, is a building block on which other linearizable operations are implemented with. It‚Äôs often built-in into the hardware, and runs over a hundred cycles or so.</p>

<p>We can implement <code class="highlighter-rouge">getUID</code> using CAS directly:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="nd">@tailrec</span> <span class="k">def</span> <span class="nf">getUID</span><span class="o">()</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">oldUID</span> <span class="k">=</span> <span class="nv">uid</span><span class="o">.</span><span class="py">get</span>  <span class="c1">// read old value from atomic variable</span>
    <span class="k">val</span> <span class="nv">newUID</span> <span class="k">=</span> <span class="n">oldUID</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// compute new value</span>
    <span class="c1">// Attempt to do a CAS</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">uid</span><span class="o">.</span><span class="py">compareAndSet</span><span class="o">(</span><span class="n">oldUID</span><span class="o">,</span> <span class="n">newUID</span><span class="o">))</span> <span class="n">newUID</span> <span class="c1">// Success!</span>
    <span class="k">else</span> <span class="nf">getUID</span><span class="o">()</span> <span class="c1">// Some other thread has already done it. Try again</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="programming-without-locks">Programming without locks</h3>
<p>Locks as implemented by <code class="highlighter-rouge">synchronized</code> are a convenient concurrency mechanism, but are also problematic (possibility of deadlock, possibility to arbitrarily delay other threads if a thread executes a long-running operation in a <code class="highlighter-rouge">synchronized</code>).</p>

<p>With atomic variables and their <strong>lock-free operation</strong>, we can avoid these problems. We can even simulate locks with atomic variables!</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">private</span> <span class="k">val</span> <span class="nv">lock</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicBoolean</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">mySynchronized</span><span class="o">(</span><span class="n">body</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">while</span> <span class="o">(!</span><span class="nv">lock</span><span class="o">.</span><span class="py">compareAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">{}</span>
    <span class="k">try</span> <span class="n">body</span>
    <span class="k">finally</span> <span class="nv">lock</span><span class="o">.</span><span class="py">set</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here‚Äôs how we define <strong>lock-freedom</strong>:</p>

<blockquote>
  <p>An operation <code class="highlighter-rouge">op</code> is <strong>lock-free</strong> if, whenever there is a set of threads executing <code class="highlighter-rouge">op</code>, at least one thread completes the operation after a finite number of steps, regardless of the speed in which the different threads progress.</p>
</blockquote>

<p>Essentially: <em>at least one</em> thread needs to complete the operation in a finite number of steps.</p>

<h4 id="lazy-values">Lazy values</h4>
<p>Here‚Äôs how <code class="highlighter-rouge">scalac</code> currently implements lazy values. It doesn‚Äôt use <code class="highlighter-rouge">synchronized</code> around the whole block since it‚Äôs quite costly, but still must set up some protections:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="nd">@volatile</span> <span class="k">private</span> <span class="k">var</span> <span class="n">x_defined</span> <span class="k">=</span> <span class="kc">false</span>
<span class="k">private</span> <span class="k">var</span> <span class="n">x_cached</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">_</span>
<span class="k">def</span> <span class="nf">x</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(!</span><span class="n">x_defined</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
        <span class="nf">if</span> <span class="o">(!</span><span class="n">x_defined</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// this pattern is called double-locking</span>
            <span class="n">x_cached</span> <span class="k">=</span> <span class="n">E</span>
            <span class="n">x_defined</span> <span class="k">=</span> <span class="kc">true</span>
        <span class="o">}</span>
        <span class="n">x_cached</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The problems with this implementation are:</p>

<ul>
  <li>It‚Äôs not lock-free; <code class="highlighter-rouge">E</code> could take arbitrarily long time.</li>
  <li>It uses <code class="highlighter-rouge">this</code> as a lock, which might conflict with application-defined locking.</li>
  <li>It‚Äôs prone to deadlocks.</li>
</ul>

<p>The new Scala compiler, <code class="highlighter-rouge">dotty</code>, does this instead:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">x</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(!</span><span class="n">x_defined</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
            <span class="nf">if</span> <span class="o">(</span><span class="n">x_evaluating</span><span class="o">)</span> <span class="nf">wait</span><span class="o">()</span>
            <span class="k">else</span> <span class="n">x_evaluating</span> <span class="k">=</span> <span class="kc">true</span>
        <span class="o">}</span>
        <span class="nf">if</span> <span class="o">(!</span><span class="n">x_defined</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x_cached</span> <span class="k">=</span> <span class="n">E</span>
            <span class="k">this</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
                <span class="n">x_evaluating</span> <span class="k">=</span> <span class="kc">false</span>
                <span class="n">x_defined</span> <span class="k">=</span> <span class="kc">true</span>
                <span class="nf">notifyAll</span><span class="o">()</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>The evaluation of <code class="highlighter-rouge">E</code> happens outside a monitor, therefore no arbitrary slowdowns</li>
  <li>Two short <code class="highlighter-rouge">synchronized</code> blocks instead of one arbitrary long one</li>
  <li>No interference with user-defined locks</li>
  <li>Deadlocks are still possible but only in cases where sequential execution would give an infinite loop</li>
</ul>

<h4 id="collections">Collections</h4>
<p>Operations on mutable collections are usually not thread-safe. The safe way to deal with this is of course to use <code class="highlighter-rouge">synchronized</code>, but that often leads to too much blocking. To gain speed, we can use or implement special <em>concurrent collection</em> implementations.</p>

<p>As an example, here‚Äôs how concurrent queues could be implemented:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">java.util.concurrent.atomic._</span>
<span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="k">object</span> <span class="nc">ConcQueue</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="nd">@volatile</span> <span class="k">var</span> <span class="n">next</span><span class="k">:</span> <span class="kt">Node</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span>
        <span class="k">var</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">_</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">ConcQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">ConcQueue._</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">last</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicReference</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="kc">null</span><span class="o">))</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">head</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicReference</span><span class="o">(</span><span class="nv">last</span><span class="o">.</span><span class="py">get</span><span class="o">)</span>

    <span class="nd">@tailrec</span> <span class="k">final</span> <span class="k">def</span> <span class="nf">append</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// fiddle with last pointer</span>
        <span class="k">val</span> <span class="nv">last1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="kc">null</span><span class="o">)</span>
        <span class="nv">last1</span><span class="o">.</span><span class="py">elem</span> <span class="k">=</span> <span class="n">elem</span>
        <span class="k">val</span> <span class="nv">prev</span> <span class="k">=</span> <span class="nv">last</span><span class="o">.</span><span class="py">get</span>
        <span class="c1">// the following 2 lines differ from the sequential implementation</span>
        <span class="c1">// append needs to atomically update 2 variables, but CAS can only</span>
        <span class="c1">// work with 1 variable at a time. So we only use one CAS, and set</span>
        <span class="c1">// the other assignment when successful</span>
        <span class="nf">if</span> <span class="o">(</span><span class="nv">last</span><span class="o">.</span><span class="py">compareAndSet</span><span class="o">(</span><span class="n">prev</span><span class="o">,</span> <span class="n">last1</span><span class="o">))</span> <span class="nv">prev</span><span class="o">.</span><span class="py">next</span> <span class="k">=</span> <span class="n">last1</span>
        <span class="k">else</span> <span class="nf">append</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="nd">@tailrec</span> <span class="k">final</span> <span class="k">def</span> <span class="nf">remove</span><span class="o">()</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">head</span> <span class="n">eq</span> <span class="n">last</span><span class="o">)</span> <span class="nc">None</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">val</span> <span class="nv">hd</span> <span class="k">=</span> <span class="nv">head</span><span class="o">.</span><span class="py">get</span>
            <span class="k">val</span> <span class="nv">first</span> <span class="k">=</span> <span class="nv">hd</span><span class="o">.</span><span class="py">next</span>
            <span class="c1">// We just need to do a CAS in case first == null</span>
            <span class="c1">// This is to ensure that we don't have prev.next == null</span>
            <span class="c1">// instead of prev.next == last1 in append()</span>
            <span class="nf">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nv">head</span><span class="o">.</span><span class="py">compareAndSet</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="n">first</span><span class="o">))</span>
                <span class="nc">Some</span><span class="o">(</span><span class="nv">first</span><span class="o">.</span><span class="py">elem</span><span class="o">)</span>
            <span class="k">else</span> <span class="nf">remove</span><span class="o">()</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is not lock-free, but it guarantees that we actually remove. We could also just give up if <code class="highlighter-rouge">first == null</code> and return <code class="highlighter-rouge">None</code>, which would be lock-free.</p>

<h3 id="futures">Futures</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">¬†</th>
      <th style="text-align: center">One</th>
      <th style="text-align: center">Many</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Synchronous</td>
      <td style="text-align: center"><code class="highlighter-rouge">Try[T]</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">Iterable[T]</code></td>
    </tr>
    <tr>
      <td style="text-align: left">Asynchronous</td>
      <td style="text-align: center"><code class="highlighter-rouge">Future[T]</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">Observable[T]</code></td>
    </tr>
  </tbody>
</table>

<h4 id="synchronous-try">Synchronous: <code class="highlighter-rouge">Try</code></h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">collectCoins</span><span class="o">()</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Coin</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nf">eatenByMonster</span><span class="o">(</span><span class="k">this</span><span class="o">))</span>
       <span class="k">throw</span> <span class="k">new</span> <span class="nc">GameOverException</span><span class="o">(</span><span class="s">"Ooops"</span><span class="o">)</span>
    <span class="nc">List</span><span class="o">(</span><span class="nc">Gold</span><span class="o">,</span> <span class="nc">Gold</span><span class="o">,</span> <span class="nc">Silver</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The return type here is dishonest, since actions may fail. So if we want to expose the possibility of failure in the types, then we should do <code class="highlighter-rouge">T =&gt; Try[S]</code> instead of <code class="highlighter-rouge">T =&gt; S</code>. Our game might now look like this:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="c1">// Making failure evident in types:</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Success</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Try</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Adventure</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">collectCoins</span><span class="o">()</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Coin</span><span class="o">]]</span>
    <span class="k">def</span> <span class="nf">buyTreasure</span><span class="o">(</span><span class="n">coins</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Coin</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Treasure</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// Dealing with failure explicitly</span>
<span class="k">val</span> <span class="nv">adventure</span> <span class="k">=</span> <span class="nc">Adventure</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">coins</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Coin</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">adventure</span><span class="o">.</span><span class="py">collectCoins</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">treasure</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Treasure</span><span class="o">]</span> <span class="k">=</span> <span class="n">coins</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">cs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">adventure</span><span class="o">.</span><span class="py">buyTreasure</span><span class="o">(</span><span class="n">cs</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">failure</span><span class="nd">@Failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">failure</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are some higher-order functions available that manipulate <code class="highlighter-rouge">Try[T]</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span><span class="o">=&gt;</span><span class="nc">Try</span><span class="o">[</span><span class="kt">S</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">flatten</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span><span class="o">=&gt;</span><span class="n">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span><span class="o">=&gt;</span><span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">recoverWith</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Throwable</span>,<span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="asynchronous-future">Asynchronous: <code class="highlighter-rouge">Future</code></h4>
<p><code class="highlighter-rouge">Future[T]</code> is a monad that handles exceptions and <strong>latency</strong>. Usually exceptions aren‚Äôt really nice in a multi-threaded context, but <code class="highlighter-rouge">Future</code> exists to abstract away from all of our worries. They can asynchronously notify consumers:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">onComplete</span><span class="o">(</span><span class="n">success</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">,</span> <span class="n">failed</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
    <span class="k">def</span> <span class="nf">onComplete</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Observer</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Sending a packet across the Atlantic is a situation in which we could use futures; it takes quite a while and we‚Äôd like to do other things in the meantime, and still manage failures:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">socket</span> <span class="k">=</span> <span class="nc">Socket</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">packet</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span>
<span class="nv">socket</span><span class="o">.</span><span class="py">readFromMemory</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">confirmation</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">packet</span><span class="o">.</span><span class="py">onComplete</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">socket</span><span class="o">.</span><span class="py">sendToEurope</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="err">‚Ä¶</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">socket</span> <span class="k">=</span> <span class="nc">Socket</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">packet</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">socket</span><span class="o">.</span><span class="py">readFromMemory</span><span class="o">()</span>
<span class="nv">packet</span><span class="o">.</span><span class="py">onComplete</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">confirmation</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span>
        <span class="nv">socket</span><span class="o">.</span><span class="py">sendToEurope</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="err">‚Ä¶</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is a bit awkward, we can do much better:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="c1">// Starts an asynchronous computation</span>
<span class="c1">// and returns a future object to which you</span>
<span class="c1">// can subscribe to be notified when the</span>
<span class="c1">// future completes</span>
<span class="k">object</span> <span class="nc">Future</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">body</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">context</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can then do this elegantly (?):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>
<span class="k">import</span> <span class="nn">akka.serializer._</span>

<span class="k">val</span> <span class="nv">memory</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">EMailMessage</span><span class="o">](</span>
    <span class="nc">EMailMessage</span><span class="o">(</span><span class="n">from</span> <span class="k">=</span> <span class="s">"Erik"</span><span class="o">,</span> <span class="n">to</span> <span class="k">=</span> <span class="s">"Roland"</span><span class="o">),</span>
    <span class="nc">EMailMessage</span><span class="o">(</span><span class="n">from</span> <span class="k">=</span> <span class="s">"Martin"</span><span class="o">,</span> <span class="n">to</span> <span class="k">=</span> <span class="s">"Erik"</span><span class="o">),</span>
    <span class="nc">EMailMessage</span><span class="o">(</span><span class="n">from</span> <span class="k">=</span> <span class="s">"Roland"</span><span class="o">,</span> <span class="n">to</span> <span class="k">=</span> <span class="s">"Martin"</span><span class="o">))</span>

<span class="k">def</span> <span class="nf">readFromMemory</span><span class="o">()</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="c1">// LOOK HERE!</span>
    <span class="k">val</span> <span class="nv">email</span> <span class="k">=</span> <span class="nv">queue</span><span class="o">.</span><span class="py">dequeue</span><span class="o">()</span>
    <span class="k">val</span> <span class="nv">serializer</span> <span class="k">=</span> <span class="nv">serialization</span><span class="o">.</span><span class="py">findSerializerFor</span><span class="o">(</span><span class="n">email</span><span class="o">)</span>
    <span class="nv">serializer</span><span class="o">.</span><span class="py">toBinary</span><span class="o">(</span><span class="n">email</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="recover-and-recoverwith">Recover and recoverWith</h5>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">recover</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Throwable</span>,<span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">recoverWith</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here‚Äôs how we would send packets using futures robustly:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sendTo</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">URL</span><span class="o">,</span> <span class="n">packet</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Http</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="nc">Request</span><span class="o">(</span><span class="n">packet</span><span class="o">))</span>
        <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">response</span> <span class="k">=&gt;</span> <span class="nv">response</span><span class="o">.</span><span class="py">isOK</span><span class="o">)</span>
        <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">response</span> <span class="k">=&gt;</span> <span class="nv">response</span><span class="o">.</span><span class="py">toByteArray</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">sendToSafe</span><span class="o">(</span><span class="n">packet</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nf">sendTo</span><span class="o">(</span><span class="nv">mailServer</span><span class="o">.</span><span class="py">europe</span><span class="o">,</span> <span class="n">packet</span><span class="o">)</span> <span class="n">recoverWith</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">europeError</span> <span class="k">=&gt;</span> <span class="c1">// catches everything</span>
            <span class="nf">sendTo</span><span class="o">(</span><span class="nv">mailServer</span><span class="o">.</span><span class="py">usa</span><span class="o">,</span> <span class="n">packet</span><span class="o">)</span> <span class="n">recover</span> <span class="o">{</span>
                <span class="k">case</span> <span class="n">usaError</span> <span class="k">=&gt;</span> <span class="nv">usaError</span><span class="o">.</span><span class="py">getMessage</span><span class="o">.</span><span class="py">toByteArray</span>
            <span class="o">}</span>
    <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>A sometimes cleaner way of doing it is to provide a fallback:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sendToSafe</span><span class="o">(</span><span class="n">packet</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nf">sendTo</span><span class="o">(</span><span class="nv">mailServer</span><span class="o">.</span><span class="py">europe</span><span class="o">,</span> <span class="n">packet</span><span class="o">)</span> <span class="n">recoverWith</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">europeError</span> <span class="k">=&gt;</span> <span class="nf">sendTo</span><span class="o">(</span><span class="nv">mailServer</span><span class="o">.</span><span class="py">usa</span><span class="o">,</span> <span class="n">packet</span><span class="o">)</span> <span class="n">recover</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">usaError</span> <span class="k">=&gt;</span> <span class="nv">usaError</span><span class="o">.</span><span class="py">getMessage</span><span class="o">.</span><span class="py">toByteArray</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
<span class="k">def</span> <span class="nf">fallbackTo</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="o">=&gt;</span><span class="nc">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="err">‚Ä¶</span> <span class="k">if</span> <span class="k">this</span> <span class="n">future</span> <span class="n">fails</span> <span class="n">take</span> <span class="n">the</span> <span class="n">successful</span> <span class="n">result</span>
    <span class="n">of</span> <span class="n">that</span> <span class="n">future</span> <span class="err">‚Ä¶</span>
    <span class="err">‚Ä¶</span> <span class="k">if</span> <span class="n">that</span> <span class="n">future</span> <span class="n">fails</span> <span class="n">too</span><span class="o">,</span> <span class="n">take</span> <span class="n">the</span> <span class="n">error</span> <span class="n">of</span>
    <span class="k">this</span> <span class="n">future</span> <span class="err">‚Ä¶</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="implementation-of-flatmap-on-future">Implementation of FlatMap on Future</h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
    <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">S</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">onComplete</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
            <span class="n">self</span> <span class="n">onComplete</span> <span class="o">{</span>
                <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span>
                    <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="py">onComplete</span><span class="o">(</span><span class="n">callback</span><span class="o">)</span> <span class="c1">// we apply f and if that succeeds, we do callback</span>
                <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">callback</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
            <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The actual implementation is a bit more evolved, as there‚Äôs some scheduling involved, but this is the gist of it.</p>

<h2 id="part-3-actors">Part 3: Actors</h2>

<h3 id="why-actors">Why Actors?</h3>
<p>Actors were invented in 1973 for research on artificial intelligence. Actors were added to the Scala standard library in 2006. Akka, an Actor framework on the JVM with Java and Scala APIs, was created in 2009.</p>

<p>Today, CPUs aren‚Äôt really gettting faster as much as they‚Äôre getting wider: we use multiple physical and virtual execution cores. To take advantage of these cores, we run multiple programs in parallel (<em>multi-tasking</em>) or we run parts of the same program in parallel (<em>multi-threading</em>).</p>

<p>We saw in the earlier example about bank accounts that if we don‚Äôt synchronize our actions, we may ‚Äúcreate money‚Äù and write incorrect amounts to the balance. To avoid this, we saw how locks work with <code class="highlighter-rouge">obj.synchronized { ... }</code>. We also saw that we have to be <a href="#resolving-deadlocks">careful to avoid deadlocks</a> when using these. Since this blocking synchronization may introduce dead-locks, and since it is bad for CPU utilization, we will look into Actors, which are non-blocking objetcts.</p>

<h3 id="what-is-an-actor">What is an Actor?</h3>
<p>The Actor Model represents objects and their interactions, resembling human organizations. It is helpful to visualize Actors not as abstract objects on which we call methods, but as people talking to each other. More formally, an Actor:</p>

<ul>
  <li>is an object with identity</li>
  <li>has a behavior</li>
  <li>only interacts using <em>asynchronous</em> message passing</li>
</ul>

<h4 id="the-actor-trait">The Actor Trait</h4>
<p>For this, we use the <code class="highlighter-rouge">Actor</code> trait in Akka:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">type</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Unit</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">receive</span><span class="k">:</span> <span class="kt">Receive</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>It defines one abstract method, <code class="highlighter-rouge">receive</code>, which returns a <a href="http://www.scala-lang.org/api/2.12.1/scala/PartialFunction.html">partial function</a> from <code class="highlighter-rouge">Any</code> to <code class="highlighter-rouge">Unit</code>, describing the response of the Actor to a message. Any message could come in (hence <code class="highlighter-rouge">Any</code>), and the Actor may act upon it but cannot return anything, since the sender is long gone (hence <code class="highlighter-rouge">Unit</code>).</p>

<h3 id="a-simple-stateful-actor">A simple, stateful Actor</h3>
<p>Let‚Äôs implement the <code class="highlighter-rouge">Actor</code> trait in an example class:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Counter</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="s">"incr"</span> <span class="k">=&gt;</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nf">case</span> <span class="o">(</span><span class="s">"get"</span><span class="o">,</span> <span class="n">customer</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">customer</span> <span class="o">!</span> <span class="n">count</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If the counter gets the message <code class="highlighter-rouge">"incr"</code>, it simply increments the counter. But our actor can also send messages to addresses they know (in Akka, they are <code class="highlighter-rouge">ActorRef</code>s). If the customer (the actor that sends the message) sends a <code class="highlighter-rouge">("get", customer: ActorRef)</code> tuple, our counter will send the count back. Note that the exclamation mark <code class="highlighter-rouge">!</code> is used to send messages in Akka (it means ‚Äúfire and forget‚Äù, also known as <em>tell</em>).</p>

<h4 id="how-messages-are-sent">How messages are sent</h4>
<p>Let‚Äôs look at more parts of the <code class="highlighter-rouge">Actor</code> trait:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">self</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="c1">// each Actor knows its own address</span>
    <span class="k">def</span> <span class="nf">sender</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="c1">// the ActorRef of sender of the received message</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">ActorRef</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">!</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">sender</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="nv">Actor</span><span class="o">.</span><span class="py">noSender</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="c1">// implicitly picks up self as the sender</span>
    <span class="k">def</span> <span class="nf">tell</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">sender</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">.!(</span><span class="n">msg</span><span class="o">)(</span><span class="n">sender</span><span class="o">)</span> <span class="c1">// Java syntax</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>With this API in mind, we can make our previous example a little nicer:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Counter</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="s">"incr"</span> <span class="k">=&gt;</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">case</span> <span class="s">"get"</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="n">count</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="the-actors-context">The Actor‚Äôs Context</h4>
<p>It can do more things than just send messages: it can create other Actors, change its behavior, etc. The <code class="highlighter-rouge">Actor</code> type describes the behavior, while the execution is done by its <code class="highlighter-rouge">ActorContext</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">ActorContext</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">become</span><span class="o">(</span><span class="n">behavior</span><span class="k">:</span> <span class="kt">Receive</span><span class="o">,</span> <span class="n">discardOld</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
    <span class="k">def</span> <span class="nf">unbecome</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">context</span><span class="k">:</span> <span class="kt">ActorContext</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Each Actor has a stack of behaviors, and the topmost one is always the active one. The default mode of <code class="highlighter-rouge">become</code> is to replace the top of the stack with a new behavior, but it can also be used to push, and <code class="highlighter-rouge">unbecome</code> to pop behaviors. Let‚Äôs see it in action by reformulating our <code class="highlighter-rouge">Counter</code> Actor:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Counter</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">counter</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span> <span class="c1">// takes an argument for the current state</span>
        <span class="k">case</span> <span class="s">"incr"</span> <span class="k">=&gt;</span> <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">counter</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="c1">// change behavior to become counter of n+1</span>
        <span class="k">case</span> <span class="s">"get"</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="n">n</span> <span class="c1">// reply with current value</span>
    <span class="o">}</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="nf">counter</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// initialize it at 0</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Functionally, it is equivalent to the previous version. It looks a bit like a tail-recursive function because it calls itself, but <em>it is asynchronous</em>, since <code class="highlighter-rouge">context.become</code> only evaluates when the next message is processed. There are advantages in this version though:</p>

<ul>
  <li>State change is explicit; there‚Äôs only one place where the state is changed</li>
  <li>State is scoped to current behavior; there are no variables that can be left in an unkown state</li>
</ul>

<h4 id="creating-and-stopping-actors">Creating and Stopping Actors</h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">ActorContext</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">actorOf</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Props</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ActorRef</span>
    <span class="k">def</span> <span class="nf">stop</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Actors are always created by actors; that means that they always form a hierarchy. <code class="highlighter-rouge">stop</code> is often applied to <code class="highlighter-rouge">self</code>, meaning that the actor wants to terminate. We can now define an Actor application:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>

<span class="k">class</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">counter</span> <span class="k">=</span> <span class="nv">context</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Counter</span><span class="o">],</span> <span class="s">"counter"</span><span class="o">)</span>

    <span class="n">counter</span> <span class="o">!</span> <span class="s">"incr"</span>
    <span class="n">counter</span> <span class="o">!</span> <span class="s">"incr"</span>
    <span class="n">counter</span> <span class="o">!</span> <span class="s">"incr"</span>
    <span class="n">counter</span> <span class="o">!</span> <span class="s">"get"</span>

    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span>
            <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"count was $count"</span><span class="o">)</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that in order to run this in an IDE, we‚Äôll need to set the main class to <code class="highlighter-rouge">akka.Main</code> and give it as first argument the full class name of the Actor class which is to be instantiated.</p>

<h3 id="message-processing">Message Processing</h3>
<p>Access to the state of Actors is only possible by exchanging messages. Messages can be sent to to known addresses (<code class="highlighter-rouge">ActorRef</code>):</p>

<ul>
  <li>Every actor knows its own address (<code class="highlighter-rouge">self</code>)</li>
  <li>Creating an actor returns its address (not the Actor object)</li>
  <li>Addresses can be sent with messages (<code class="highlighter-rouge">sender</code>, for instance, which is captured automatically)</li>
</ul>

<p>Actors are completely independent agents of computation:</p>

<ul>
  <li>Local execution, no notion of global synchronization</li>
  <li>All actors run fully concurrently</li>
  <li>Message passing is the only way to interact</li>
  <li>Message passing is a one-way communication (an Actor doesn‚Äôt know if the sent message has been sent or processed)</li>
</ul>

<p>An actor is single-threaded</p>

<ul>
  <li>Messages are received sequentially</li>
  <li>Behavior change is effective before processing the next message</li>
  <li>Processing one message is the atomic unit of execution</li>
</ul>

<p>This has the same benefits of <code class="highlighter-rouge">synchronized</code> methods, but blocking is replaced by enqueuing messages for later execution.</p>

<h4 id="revisiting-the-bank-account-example">Revisiting the Bank Account Example</h4>
<p>It‚Äôs good practice to define an Actor‚Äôs messages (both what it can receive and send) in the Actor‚Äôs companion object:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">BankAccount</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">class</span> <span class="nc">Deposit</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">require</span><span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// always positive</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="k">class</span> <span class="nc">Withdraw</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">require</span><span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// always positive</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Done</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Failed</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">BankAccount</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">BankAccount._</span>
    <span class="k">var</span> <span class="n">balance</span> <span class="k">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Deposit</span><span class="o">(</span><span class="n">amount</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="n">balance</span> <span class="o">+=</span> <span class="n">amount</span>
            <span class="n">sender</span> <span class="o">!</span> <span class="nc">Done</span>
        <span class="k">case</span> <span class="nc">Withdraw</span><span class="o">(</span><span class="n">amount</span><span class="o">)</span> <span class="k">=&gt;</span> 
            <span class="n">balance</span> <span class="o">-=</span> <span class="n">amount</span>
            <span class="n">sender</span> <span class="o">!</span> <span class="nc">Done</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="nc">Failed</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Use a different actor for the logic of the transfer</span>
<span class="c1">// (since the bank account shouldn't have to deal with that logic)</span>
<span class="k">object</span> <span class="nc">WireTransfer</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">class</span> <span class="nc">Transfer</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Done</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Failed</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">WireTransfer</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">WireTransfer._</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Transfer</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">amount</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="n">from</span> <span class="o">!</span> <span class="nv">BanckAccount</span><span class="o">.</span><span class="py">Withdraw</span><span class="o">(</span><span class="n">amount</span><span class="o">)</span> <span class="c1">// send message</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">awaitWithdraw</span><span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">amount</span><span class="o">,</span> <span class="n">sender</span><span class="o">))</span> <span class="c1">// await result of withdraw activity</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">awaitWithdraw</span><span class="o">(</span><span class="n">to</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">client</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nv">BankAccount</span><span class="o">.</span><span class="py">Done</span> <span class="k">=&gt;</span>
            <span class="n">to</span> <span class="o">!</span> <span class="nv">BankAccount</span><span class="o">.</span><span class="py">Deposit</span><span class="o">(</span><span class="n">amount</span><span class="o">)</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">awaitDeposit</span><span class="o">(</span><span class="n">client</span><span class="o">))</span>
        <span class="k">case</span> <span class="nv">BankAccount</span><span class="o">.</span><span class="py">Failed</span> <span class="k">=&gt;</span>
            <span class="n">client</span> <span class="o">!</span> <span class="nc">Failed</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">awaitDeposit</span><span class="o">(</span><span class="n">client</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nv">BankAccount</span><span class="o">.</span><span class="py">Done</span> <span class="k">=&gt;</span>
            <span class="n">client</span> <span class="o">!</span> <span class="nc">Done</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="message-delivery-guarantees">Message Delivery Guarantees</h4>
<p>All communication is inherently unreliable ‚Äî we can‚Äôt know for sure that the message was actually received. As a fix, we can set the following resending policies:</p>

<ul>
  <li><code class="highlighter-rouge">at-most-once</code>: sending once delivers $\left[0, 1\right]$ times. This can be done without keeping any state</li>
  <li><code class="highlighter-rouge">at-least-once</code>: resending until acknowledged delivers $\left[1, \infty\right[$ times. The sender needs to buffer the message in case it needs to resend</li>
  <li><code class="highlighter-rouge">exactly-once</code>: processing only first reception delivers 1 time. This requires a buffer and keeping track of which messages have been processed.</li>
</ul>

<p>Luckily for us, messages support reliability:</p>

<ul>
  <li>All messages can be persisted, meaning that we can take a copy and store it in some persistent storage.</li>
  <li>Messages can include unique IDs</li>
  <li>Delivery can be retried until successful</li>
</ul>

<p>But this only works if we use acknowledgements from the receiver. We can make the <code class="highlighter-rouge">WireTransfer</code> reliable by:</p>

<ul>
  <li>Logging activities of <code class="highlighter-rouge">WireTransfer</code> to persistent storage</li>
  <li>Giving each transfer a unique ID</li>
  <li>Adding IDs to <code class="highlighter-rouge">Withdraw</code> and <code class="highlighter-rouge">Deposit</code></li>
  <li>Storing IDs of completed actions within BankAccount</li>
</ul>

<h4 id="message-ordering">Message Ordering</h4>
<p>If an actor sends multiple messages to the same destination, they will not arrive out of order (this is Akka-specific). Other than that, message ordering to different receivers is not prescribed by the Actor model.</p>

<h3 id="designing-actor-systems">Designing Actor Systems</h3>
<p>Imagine giving the task to a group of people, dividing it up. Consider the group to be of very large size, and the people to be easily replaceable (since Actors have quite low overhead, we can make plenty of them). Draw a diagram with how the task will be split up between the people and the communication lines between them. For example, if we want to build a web crawler, we might use:</p>

<ul>
  <li>A web client which turns a URL into a HTTP body asynchronously</li>
  <li>A <code class="highlighter-rouge">Getter</code> actor for processing the body</li>
  <li>A <code class="highlighter-rouge">Controller</code> which spawns <code class="highlighter-rouge">Getter</code>s for all links encountered</li>
  <li>A <code class="highlighter-rouge">Receptionist</code> managing one <code class="highlighter-rouge">Controller</code> per request</li>
</ul>

<p>The videos goes into a long example (seriously, 40 minutes), but here are the important lessons:</p>

<ul>
  <li>A reactive application is non-blocking and event-driven top to bottom</li>
  <li>Actors are run by a dispatcher (potentially shared) which can also run <code class="highlighter-rouge">Future</code>s</li>
  <li>Prefer immutable data structures, since they can be shared</li>
  <li>Do not refer to actor state from code running asynchronously</li>
  <li>Prefer <code class="highlighter-rouge">context.become</code> for different states, with data local to the behavior</li>
</ul>

<h4 id="actor-based-logging">Actor-Based Logging</h4>
<p>In Akka, you can log like this:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="nv">log</span><span class="o">.</span><span class="py">debug</span><span class="o">(</span><span class="s">"received message: {}"</span><span class="o">,</span> <span class="n">msg</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Logging includes IO which can block indefinitely, but Akka‚Äôs logging passes that task to dedicated actors. You can set the level of debugging by setting <code class="highlighter-rouge">akka.loglevel=DEBUG</code> (other levels are <code class="highlighter-rouge">debug</code>, <code class="highlighter-rouge">info</code>, <code class="highlighter-rouge">warning</code>, <code class="highlighter-rouge">error</code>).</p>

<h4 id="handling-timeouts">Handling Timeouts</h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">class</span> <span class="nc">Controller</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>
    <span class="nv">context</span><span class="o">.</span><span class="py">setReceiveTimeout</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="c1">// reset after each message processing</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Check</span><span class="o">(...)</span> <span class="k">=&gt;</span> <span class="o">...</span>
        <span class="k">case</span> <span class="nv">Getter</span><span class="o">.</span><span class="py">Done</span> <span class="k">=&gt;</span> <span class="o">..</span>
        <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">=&gt;</span> <span class="n">children</span> <span class="nf">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="o">!</span> <span class="nv">Getter</span><span class="o">.</span><span class="py">Abort</span><span class="o">)</span> <span class="c1">// abort all children</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Getter</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">case</span> <span class="nc">Abort</span> <span class="k">=&gt;</span> <span class="nf">stop</span><span class="o">()</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">stop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="nv">context</span><span class="o">.</span><span class="py">parent</span> <span class="o">!</span> <span class="nc">Done</span>
        <span class="nv">context</span><span class="o">.</span><span class="py">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="testing-actor-systems">Testing Actor Systems</h3>
<p>Tests can only verify message passing. Say we have an Actor called <code class="highlighter-rouge">Toggle</code> that responds with <code class="highlighter-rouge">happy</code> and <code class="highlighter-rouge">sad</code> alternatively:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">implicit</span> <span class="k">val</span> <span class="nv">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"TestSys"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">toggle</span> <span class="k">=</span> <span class="nv">system</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Toggle</span><span class="o">])</span>
<span class="k">val</span> <span class="nv">p</span> <span class="k">=</span> <span class="nc">TestProbe</span><span class="o">()</span>
<span class="nv">p</span><span class="o">.</span><span class="py">send</span><span class="o">(</span><span class="n">toggle</span><span class="o">,</span> <span class="s">"How are you?"</span><span class="o">)</span>
<span class="nv">p</span><span class="o">.</span><span class="py">expectMsg</span><span class="o">(</span><span class="s">"happy"</span><span class="o">)</span>
<span class="nv">p</span><span class="o">.</span><span class="py">send</span><span class="o">(</span><span class="n">toggle</span><span class="o">,</span> <span class="s">"How are you?"</span><span class="o">)</span>
<span class="nv">p</span><span class="o">.</span><span class="py">expectMsg</span><span class="o">(</span><span class="s">"sad"</span><span class="o">)</span>
<span class="nv">p</span><span class="o">.</span><span class="py">send</span><span class="o">(</span><span class="n">toggle</span><span class="o">,</span> <span class="s">"unkown"</span><span class="o">)</span>
<span class="nv">p</span><span class="o">.</span><span class="py">expectNoMsg</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="nv">system</span><span class="o">.</span><span class="py">shutdown</span><span class="o">()</span> <span class="c1">// otherwise the thread keeps running</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can also run a test within a <code class="highlighter-rouge">TestProbe</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">new</span> <span class="nc">TestKit</span><span class="o">(</span><span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"TestSys"</span><span class="o">))</span> <span class="k">with</span> <span class="nc">ImplicitSender</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">toggle</span> <span class="k">=</span> <span class="nv">system</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Toggle</span><span class="o">])</span>
    <span class="n">toggle</span> <span class="o">!</span> <span class="s">"How are you?"</span>
    <span class="nf">expectMsg</span><span class="o">(</span><span class="s">"happy"</span><span class="o">)</span>
    <span class="n">toggle</span> <span class="o">!</span> <span class="s">"How are you?"</span>
    <span class="nf">expectMsg</span><span class="o">(</span><span class="s">"sad"</span><span class="o">)</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Sometimes, we need to test an Actor with real-life dependencies (accessing a DB, a production web service, etc). We don‚Äôt want to do testing with these, so the solution is to use dependency injection, or overridable factory methods.</p>

<p>When testing hierarchies, it‚Äôs good practice to verify the leaves, and working your way up.</p>

<h3 id="failure-handling-with-actors">Failure Handling with Actors</h3>
<p>Resilience demands:</p>

<ul>
  <li><em>Containment of failure</em>: failure is isolated, can‚Äôt spread to other components. This happens by design of the model, since actors are fully encapsulated objects</li>
  <li><em>Delegation of failure</em>: failure cannot be handled by the failed component, since it is presumably compromised, so the failure must be handled by another actor.</li>
</ul>

<p>This means that another Actor needs to decide whether the failed Actor is terminated or restarted. If it needs to be able to restart the failed Actor, then it is both the supervisor and the parent. In other words, the supervision and parental hierarchy are the same, which means failure is passed to the parent. In Akka, we call this <em>mandatory parental supervision</em>.</p>

<p>How does this supervision hierarchy translate to code?</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Manager</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">val</span> <span class="nv">supervisorStrategy</span> <span class="k">=</span> <span class="nc">OneForOneStrategy</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// val not def (define it once)</span>
        <span class="k">case</span> <span class="k">_:</span> <span class="kt">DBException</span> <span class="o">=&gt;</span> <span class="nc">Restart</span> <span class="c1">// reconnect to DB</span>
        <span class="k">case</span> <span class="k">_:</span> <span class="kt">ActorKilledException</span> <span class="o">=&gt;</span> <span class="nc">Stop</span>
        <span class="k">case</span> <span class="k">_:</span> <span class="kt">ServiceDownException</span> <span class="o">=&gt;</span> <span class="nc">Escalate</span> <span class="c1">// can't fix it itself, so escalate</span>
    <span class="o">}</span>
    <span class="o">...</span>
    <span class="nv">context</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">DBActor</span><span class="o">],</span> <span class="s">"db"</span><span class="o">)</span>
    <span class="nv">context</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">ImportantServiceActor</span><span class="o">],</span> <span class="s">"service"</span><span class="o">)</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that failure is sent and processed like a message, so we can do everything we usually can with it. However, to fix the problem <code class="highlighter-rouge">Stop</code>, <code class="highlighter-rouge">Restart</code> and <code class="highlighter-rouge">Escalate</code> are the only available tools.</p>

<h4 id="strategies">Strategies</h4>
<p>There are two strategies:</p>

<ul>
  <li><code class="highlighter-rouge">OneForOneStrategy</code>: always deal with each child Actor in isolation</li>
  <li><code class="highlighter-rouge">AllForOneStrategy</code>: decision applies to all children (children need to live and die together (that‚Äôs dark)).</li>
</ul>

<p>Each strategy can be configured to include a simple rate trigger:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="nc">OneForOneStrategy</span><span class="o">(</span><span class="n">maxNrOfRestarts</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">withinTimeRange</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">minute</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">DBException</span> <span class="o">=&gt;</span> <span class="nc">Restart</span> <span class="c1">// will turn into Stop</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="restarts">Restarts</h4>
<p>In Akka, the <code class="highlighter-rouge">ActorRef</code> stays valid after a restart (this is not the case in Erlang, for instance). This means other Actors can keep interacting with the failed Actor once the failure has been dealt with.</p>

<p>What does a restart <em>really</em> mean?</p>

<ul>
  <li>Expected error conditions are typically handled explicitly within the Actor</li>
  <li>Unexpected errors indicate invalidated actor state. In this case, a restart restores the initial state.</li>
</ul>

<h4 id="lifecycle-hooks">Lifecycle Hooks</h4>
<p>When an Actor starts, restarts and stops, we can define different hooks to be run, whose defaults are:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{}</span>
    <span class="c1">// reason is the thrown exception.</span>
    <span class="c1">// message is what was being processed at the time.</span>
    <span class="k">def</span> <span class="nf">preRestart</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// Default behavior is to stop all children, since they are</span>
        <span class="c1">// considered part of the Actor's state:</span>
        <span class="nv">context</span><span class="o">.</span><span class="py">children</span> <span class="nf">foreach</span> <span class="o">(</span><span class="nv">context</span><span class="o">.</span><span class="py">stop</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
        <span class="nf">postStop</span><span class="o">()</span>
    <span class="o">}</span>
    <span class="k">def</span> <span class="nf">postRestart</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="nf">preStart</span><span class="o">()</span>
    <span class="o">}</span>
    <span class="k">def</span> <span class="nf">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Any Actor can of course override these methods. If, when overriding <code class="highlighter-rouge">preRestart</code>, we do not stop child actors, the context will recursively restart them.</p>

<h4 id="lifecycle-monitoring">Lifecycle Monitoring</h4>
<p>From the outside, the only observable transition occurs when an Actor stops. After a stop, there will be no more responses ‚Äî but how do we distinguish an Actor that has been terminated from one that just doesn‚Äôt respond anymore? In Akka, there exists a feature called DeathWatch:</p>

<ul>
  <li>An Actor registers its interest using <code class="highlighter-rouge">context.watch(target)</code></li>
  <li>It will receive a <code class="highlighter-rouge">Terminated(target)</code> message when the target stops</li>
  <li>It will not receive any direct messages from <code class="highlighter-rouge">target</code> thereafter (indirect messages going through intermediate actors may still be en route, but not direct ones)</li>
</ul>

<p>The DeathWatch API provides two methods:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">ActorContext</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">watch</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">ActorRef</span>
    <span class="k">def</span> <span class="nf">unwatch</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">ActorRef</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Terminated</span> <span class="k">private</span><span class="o">[</span><span class="kt">akka</span><span class="o">]</span> <span class="o">(</span><span class="n">actor</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span>
    <span class="o">(</span><span class="k">val</span> <span class="nv">existenceConfirmed</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="k">val</span> <span class="nv">addressTerminated</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">AutoReceiveMessage</span> <span class="k">with</span> <span class="nc">PossiblyHarmful</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">Terminated</code> is a special message. You can‚Äôt declare it yourself as it‚Äôs private to Akka. If you‚Äôre watch an existing Actor, Akka will send <code class="highlighter-rouge">Terminated(...)(true)</code> when it stops. If you try to watch a non-existing (or no-longer existing) Actor, Akka will reply immediately with <code class="highlighter-rouge">Terminated(...)(false)</code>.</p>

<p><code class="highlighter-rouge">Terminated</code> extends <code class="highlighter-rouge">AutoReceiveMessage</code> which means that they‚Äôre handled by the Actor context, and that <code class="highlighter-rouge">Terminated</code> messages cannot be forwarded.</p>

<p><code class="highlighter-rouge">Terminated</code> messages are <code class="highlighter-rouge">PossiblyHarmful</code>.</p>

<h4 id="the-chlidren-list">The Chlidren List</h4>
<p>Each actor maintains a list of the actors it created:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">ActorContext</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">children</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">ActorRef</span><span class="o">]</span> <span class="c1">// list of all</span>
    <span class="k">def</span> <span class="nf">child</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">ActorRef</span><span class="o">]</span> <span class="c1">// query for one</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>When <code class="highlighter-rouge">context.actorOf</code> returns, the child has been entered into the list</li>
  <li>When <code class="highlighter-rouge">Terminated</code> is received, the child has been removed from the list</li>
  <li>Even if we don‚Äôt use DeathWatch, the child is removed (but no <code class="highlighter-rouge">Terminated</code> is sent)</li>
</ul>

<h4 id="the-error-kernel">The Error Kernel</h4>
<p>It‚Äôs good practice to keep important data near the root, and delegate risk to the leaves. This way, when an Actor restarts, the effect will be rather localized (it won‚Äôt have to restart children). This is called the Error Kernel pattern.</p>

<h4 id="eventstream">EventStream</h4>
<p>So far, we‚Äôve stated that Actors can direct messages only at known addresses. But the reality is that another option exists: it‚Äôs the equivalent of shouting something in a room full of people. The <code class="highlighter-rouge">EventStream</code> allows publication of messages to an unknown audience. Every Actor can optionally subscribe to (parts of) the EventStream.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">EventStream</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">topic</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="c1">// topic is a Java class object</span>
    <span class="k">def</span> <span class="nf">unsubscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">topic</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="k">def</span> <span class="nf">unsubscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
    <span class="k">def</span> <span class="nf">publish</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>An example in code:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Listener</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="nv">context</span><span class="o">.</span><span class="py">system</span><span class="o">.</span><span class="py">eventStream</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">LogEvent</span><span class="o">])</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">LogEvent</span> <span class="o">=&gt;</span> <span class="o">...</span>
    <span class="o">}</span>
    <span class="c1">// It is good practice to unsubscribe from all events in postStop:</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="nv">context</span><span class="o">.</span><span class="py">system</span><span class="o">.</span><span class="py">eventStream</span><span class="o">.</span><span class="py">unsubscribe</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="unhandled-messages">Unhandled Messages</h4>
<p><code class="highlighter-rouge">Actor.Receive</code> is a partial function, so the behavior may not apply. Unhandled messages are passed into the <code class="highlighter-rouge">unhandled</code> method, whose default behavior is:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">unhandled</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">message</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Terminated</span><span class="o">(</span><span class="n">target</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">DeathPactException</span><span class="o">(</span><span class="n">target</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">system</span><span class="o">.</span><span class="py">eventStream</span><span class="o">.</span><span class="py">publish</span><span class="o">(</span><span class="nc">UnhandledMessage</span><span class="o">(</span><span class="n">ms</span><span class="o">,</span> <span class="n">sender</span><span class="o">,</span> <span class="n">self</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The supervisor‚Äôs default response to a <code class="highlighter-rouge">DeathPactException</code> is to send a <code class="highlighter-rouge">Stop</code> command. All other messages are published, so we could for example register a listener to log unhandled messages.</p>

<h4 id="persistent-actor-state">Persistent Actor State</h4>
<p>The Error Kernel pattern allows us to keep important Actors relatively safe, but there are cases where we cannot lose data at all. Losing state due to a restart is not the only thing that can happen: we could also lose data due to buggy software or hardware, or due to a system failure. If we need to keep state across all these failure scenarios, then we need to make sure it‚Äôs stored on a harddrive for instance.</p>

<p>There are two possibilites for persisting state:</p>

<ul>
  <li>Have the Actor mirror a persistent storage location, and do in-place updates (replacements) of both.
    <ul>
      <li>Recovery of latest state in constant time</li>
      <li>Data volume depends on number of records, not their change rate</li>
    </ul>
  </li>
  <li>Save the chain of changes that are applied to state, in an append-only fashion (this is like an event log)
    <ul>
      <li>History can be replayed, audited or restored</li>
      <li>Some processing errors (bugs) can be corrected retroactively</li>
      <li>Additional insight can be gained on the process (a user‚Äôs behavior on a shopping site, for example)</li>
      <li>Writing an append-only stream optimizes IO bandwidth</li>
      <li>Changes are immutable and can freely be replicated</li>
    </ul>
  </li>
</ul>

<p>If you only want to persist the state of an actor, and put an upper bound on the time recovery may take, you can use snapshots. Snapshots combine both of the above methods by tying a current state to a change. That way you don‚Äôt have to replay all changes to find the final state, you can just recover from the latest saved state and replay the few changes that happened after that snapshot.</p>

<p>How do Actors actually persist changes? There are two ways of doing it:</p>

<ul>
  <li><strong>Command-Sourcing</strong>: We make sure that the Actor doesn‚Äôt lose any command by persisting the command before processing it (same goes for acknowledgements). During recovery, all commands are replayed to recover the state. During this replay, the Actor may send messages in response, but those are rerouted through a persistent <code class="highlighter-rouge">Channel</code> which discards messages that have already been sent to other actors.</li>
  <li><strong>Event-Sourcing</strong>: The focus isn‚Äôt on replaying the commands, but instead on saving and applying the change requests (‚Äúevents‚Äù). We don‚Äôt save what we want to happen (commands) to the log, we save what <em>has happened</em> (events). During a replay, the Actor doesn‚Äôt need to see the commands again, just the events.</li>
</ul>

<p>Here‚Äôs an example of this ‚Äî an actor which processes blog posts, with a daily quota for each user:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Event</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">PostCreated</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">QuotaReached</span> <span class="k">extends</span> <span class="nc">Event</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">State</span><span class="o">(</span><span class="n">posts</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">disabled</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">updated</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Event</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">PostCreated</span><span class="o">(</span><span class="n">text</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">copy</span><span class="o">(</span><span class="n">posts</span> <span class="k">=</span> <span class="n">posts</span> <span class="o">:+</span> <span class="n">text</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">QuotaReached</span>      <span class="k">=&gt;</span> <span class="nf">copy</span><span class="o">(</span><span class="n">disabled</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">UserProcessor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">state</span> <span class="k">=</span> <span class="nc">State</span><span class="o">(</span><span class="nv">Vector</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">NewPost</span><span class="o">(</span><span class="n">text</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nf">if</span> <span class="o">(!</span><span class="nv">state</span><span class="o">.</span><span class="py">disabled</span><span class="o">)</span>
                <span class="nf">emit</span><span class="o">(</span><span class="nc">PostCreated</span><span class="o">(</span><span class="n">text</span><span class="o">),</span> <span class="nc">QuotaReached</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Event</span> <span class="o">=&gt;</span>
            <span class="n">state</span> <span class="k">=</span> <span class="nv">state</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">emit</span><span class="o">(</span><span class="n">events</span><span class="k">:</span> <span class="kt">Event*</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span> <span class="c1">// send to log</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There‚Äôs a problem with this, though: we might get a new post while we‚Äôre sending the previous one to the log (writing to disk does take some time), in which case it will pass the condition in the <code class="highlighter-rouge">if</code> statement, and will be added anyway. This is a general problem with applying and <em>then</em> persisting: it leaves the actor in a stale state.</p>

<p>If we persist and <em>then</em> apply, then we don‚Äôt have that problem, but we might have trouble regenerating after a system-wide crash, as the last state may not have been fully persisted yet.</p>

<p>So it seems like we need to choose between correct persistence and correct behavior ‚Äî but there is a third option: do not process new messages while waiting for persistance. However this option comes at a performance cost, as we reduce performance, augment latency and lower throughtput.</p>

<p>The ability to postpone messages which cannot yet be handled is provided by the <code class="highlighter-rouge">Stash</code> trait in Akka:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">UserProcessor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Stash</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">state</span><span class="k">:</span> <span class="kt">State</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">NewPost</span><span class="o">(</span><span class="nc">Text</span><span class="o">)</span> <span class="k">if</span> <span class="o">!</span><span class="nv">state</span><span class="o">.</span><span class="py">disabled</span> <span class="k">=&gt;</span>
            <span class="nf">emit</span><span class="o">(</span><span class="nc">PostCreated</span><span class="o">(</span><span class="n">text</span><span class="o">),</span> <span class="nc">QuotaReached</span><span class="o">)</span>
            <span class="c1">// Then, it changes it behavior:</span>
            <span class="c1">// it waits for the 2 events to be persisted</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">waiting</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="n">discardOld</span> <span class="k">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">waiting</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span> <span class="c1">// while we're waiting, we:</span>
        <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Event</span> <span class="o">=&gt;</span> <span class="c1">// we process only events</span>
            <span class="n">state</span> <span class="k">=</span> <span class="nv">state</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
            <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// if it's the last one we were waiting for:</span>
                <span class="nv">context</span><span class="o">.</span><span class="py">unbecome</span><span class="o">()</span> <span class="c1">// pop behavior from stack</span>
                <span class="nf">unstashAll</span><span class="o">()</span> <span class="c1">// allow all messages that in the meantime to be reprocessed.</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">waiting</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nf">stash</span><span class="o">()</span> <span class="c1">// anything that isn't an event is stashed.</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>What about when we need to interact with some outside service that isn‚Äôt based on actors? Say we charge money from a credit card for each post, do we first charge the card (<em>perform</em>) and then persist? Or the other way?</p>

<ul>
  <li>If we perform before persisting, we get at least one bank payment (the user may be charged again if the system crashes before the persisting happened).</li>
  <li>If we persist before performing, we get at most one bank payment</li>
</ul>

<p>There‚Äôs no ‚Äúbetter option‚Äù ‚Äî what to choose depends on the application and business model.</p>

<p>In summary:</p>

<ul>
  <li>Actors can persist incoming messages or generated events.</li>
  <li>Events are immutable, so they can be replicated, and used to inform other components since they can be read many times</li>
  <li>Recovery replays past commands or events; snapshots reduce this cost</li>
  <li>Actors can defer handling certain messages by using the <code class="highlighter-rouge">Stash</code> trait</li>
</ul>

<h3 id="actors-are-distributed">Actors are Distributed</h3>
<p>Actors are inherently distributed. Normally, we run them on different CPUs on the same system, but nothing stops us from running them on different network-connected hosts. But it does take some effort to make Actors agree on a common truth. We call this <strong>eventual consistency</strong>.</p>

<h4 id="the-impact-of-network-communication">The Impact of Network Communication</h4>
<p>Compared to running the code locally, running it on a network means:</p>

<ul>
  <li>Data can only be shared by value (not by name), since a copy has to be made.</li>
  <li>Bandwidth is lower</li>
  <li>Latency is higher</li>
  <li>Partial failures may happen: packets may get lost in transfer</li>
  <li>Data corruption can also happen (think 1 corruption by TB sent)</li>
</ul>

<p>Distributed computing breaks many assumptions made by the synchronous programming model.</p>

<p>Some things still hold, though. Actors are model a network locally (instead of modelling local mechanisms on the network), so message loss is a part of what we deal with, and they are so isolated that they act like different hosts on a network would.</p>

<p>All of this means that the effort of writing a distributed program using Actors is basically the same of writing a local variant (!!). The code itself won‚Äôt look much different.</p>

<h4 id="actor-path">Actor Path</h4>
<p>Actors are <em>Location Transparent</em>, which means that their location simply is hidden behind an <code class="highlighter-rouge">ActorRef</code>. We know that Actors form a hierarchy. Behind the hood, they have a path corresponding to the <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax">URI format</a>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ref</span> <span class="k">=</span> <span class="nv">system</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Greeter</span><span class="o">],</span> <span class="s">"greeter"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">ref</span><span class="o">.</span><span class="py">path</span><span class="o">)</span> <span class="c1">// prints: akka://HelloWorld/user/greeter</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Every Actor is like a folder in this URI. <code class="highlighter-rouge">akka://HelloWorld/</code> is called the <em>authority</em>, and <code class="highlighter-rouge">user/greeter</code> is the <em>path</em>. Let‚Äôs look at a remote address example: <code class="highlighter-rouge">akka.tcp://HelloWorld@10.2.4.6:6564/user/greeter</code> is a <code class="highlighter-rouge">/user/greeter</code> Actor. It‚Äôs in an Akka system using the TCP protocol, also named <code class="highlighter-rouge">HelloWorld</code>, accessible at <code class="highlighter-rouge">10.2.4.6</code> at port <code class="highlighter-rouge">6565</code>. An Actor has <em>at least</em> one such URI (but can have multiple, i.e. if it‚Äôs reachable on multiple IP addresses or ports).</p>

<p>It is worth noting that an <code class="highlighter-rouge">ActorPath</code> is not an <code class="highlighter-rouge">ActorRef</code>:</p>

<ul>
  <li><code class="highlighter-rouge">ActorPath</code> is the full name, whether the Actor exists or not
    <ul>
      <li>Can only optimistically send a message</li>
      <li>Cannot be watched (we don‚Äôt know if it exists)</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">ActorRef</code> points to one Actor which was started (an <em>incarnation</em>).
    <ul>
      <li>Can be watched</li>
      <li>Example: <code class="highlighter-rouge">akka://HelloWorld/user/greeter#43428347</code>. It looks like a path, but has an extra UID</li>
    </ul>
  </li>
</ul>

<p>To resolve an <code class="highlighter-rouge">ActorPath</code> in remote system, it is necessary to talk to Actors that we haven‚Äôt created ourselves, and for which you have no means to acquire an <code class="highlighter-rouge">ActorRef</code>. You just know which the <code class="highlighter-rouge">ActorPath</code> (host, port, etc.). To resolve an Actor, we can just send a <code class="highlighter-rouge">Resolve(path)</code> message to a <code class="highlighter-rouge">Resolver</code> Actor, which is defined as:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Identify</span><span class="o">,</span> <span class="nc">ActorIdentity</span> <span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Resolve</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">ActorPath</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Resolved</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">ActorPath</span><span class="o">,</span> <span class="n">ref</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">NotResolved</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">ActorPath</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Resolver</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Resolve</span><span class="o">(</span><span class="n">path</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">actorSelection</span><span class="o">(</span><span class="n">path</span><span class="o">)</span> <span class="o">!</span> <span class="nc">Identify</span><span class="o">((</span><span class="n">path</span><span class="o">,</span> <span class="n">sender</span><span class="o">))</span>
            <span class="c1">// context.actorSelection constructs something we can send to</span>
        <span class="k">case</span> <span class="nc">ActorIdentity</span><span class="o">((</span><span class="n">path</span><span class="o">,</span> <span class="n">client</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ref</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="c1">// actor alive</span>
            <span class="n">client</span> <span class="o">!</span> <span class="nc">Resolved</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="n">ref</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">ActorIdentity</span><span class="o">((</span><span class="n">path</span><span class="o">,</span> <span class="n">client</span><span class="o">),</span> <span class="nc">None</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// no such actor alive</span>
            <span class="n">client</span> <span class="o">!</span> <span class="nc">NotResolved</span><span class="o">(</span><span class="n">path</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Every Actor automatically supports <code class="highlighter-rouge">akka.actor.Identify</code>, and reply with an <code class="highlighter-rouge">ActorIdentity</code>.</p>

<p>Relative actor paths also exist:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="nv">context</span><span class="o">.</span><span class="py">actorSelection</span><span class="o">(</span><span class="s">"child/grandchild"</span><span class="o">)</span> <span class="c1">// going down in the hierarchy</span>
<span class="nv">context</span><span class="o">.</span><span class="py">actorSelection</span><span class="o">(</span><span class="s">"../sibling"</span><span class="o">)</span> <span class="c1">// going up in the hierarchy</span>
<span class="nv">context</span><span class="o">.</span><span class="py">actorSelection</span><span class="o">(</span><span class="s">"/user/controllers/*"</span><span class="o">)</span> <span class="c1">// from the root, and wildcard</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="clusters">Clusters</h4>
<p>A cluster is a set of nodes about which <em>all members are in agreement</em>. These nodes can then collaborate on a common task. A single node can declare itself a cluster (join itself). It can then join a cluster:</p>

<ul>
  <li>A request is sent to any member</li>
  <li>Once all current members know about the new node, it is declared part of the cluster</li>
</ul>

<p>Information is spread using a gossip/epidemic protocol, each Actor spreading the message to its neighbors.</p>

<p>To set up a cluster, there are a few prerequisites. First, we have an SBT dependency:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="s">"com.typesafe.akka"</span> <span class="o">%%</span> <span class="s">"akka-cluster"</span> <span class="o">%</span> <span class="s">"2.2.1"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Then, we need some configuration enabling the cluster module, in <code class="highlighter-rouge">application.conf</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="n">akka</span> <span class="o">{</span>
    <span class="n">actor</span> <span class="o">{</span>
        <span class="n">provider</span> <span class="k">=</span> <span class="nv">akka</span><span class="o">.</span><span class="py">cluster</span><span class="o">.</span><span class="py">ClusterActorRefProvider</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Alternatively, we can use<code class="highlighter-rouge"> -Dakka.actor.provider=...</code>. Now onto some code; this is the only full example I‚Äôve included, as I think it covers the whole subject pretty well. We‚Äôll take a look at how to implement work routing to different <code class="highlighter-rouge">Controller</code> workers, again to grab some URLs. The following will start a single-node cluster on port 2552:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">ClusterMain</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">cluster</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="nv">context</span><span class="o">.</span><span class="py">system</span><span class="o">)</span>
    <span class="nv">cluster</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">ClusterEvent.MemberUp</span><span class="o">])</span> <span class="c1">// new members</span>
    <span class="nv">cluster</span><span class="o">.</span><span class="py">join</span><span class="o">(</span><span class="nv">cluster</span><span class="o">.</span><span class="py">selfAddress</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nv">ClusterEvent</span><span class="o">.</span><span class="py">MemberUp</span><span class="o">(</span><span class="n">member</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nf">if</span> <span class="o">(</span><span class="nv">member</span><span class="o">.</span><span class="py">address</span> <span class="o">!=</span> <span class="nv">cluster</span><span class="o">.</span><span class="py">selfAddress</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// someone joined</span>
            <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we code a second node, we need a seperate port, using <code class="highlighter-rouge">akka.remote.netty.tcp.port = 0</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">ClusterWorker</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">cluster</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="nv">context</span><span class="o">.</span><span class="py">system</span><span class="o">)</span>
    <span class="nv">cluster</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">ClusterEvent.MemberRemoved</span><span class="o">])</span>
    <span class="k">val</span> <span class="nv">main</span> <span class="k">=</span> <span class="nv">cluster</span><span class="o">.</span><span class="py">selfAddress</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">port</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2552</span><span class="o">))</span>
    <span class="nv">cluster</span><span class="o">.</span><span class="py">join</span><span class="o">(</span><span class="n">main</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nv">ClusterEvent</span><span class="o">.</span><span class="py">MemeberRemoved</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// main program shuts down</span>
            <span class="nf">if</span> <span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">address</span> <span class="o">==</span> <span class="n">main</span><span class="o">)</span> <span class="nv">context</span><span class="o">.</span><span class="py">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span> <span class="c1">// shut this down as well</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>How do we route work to cluster members? We create a Receptionist:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">ClusterReceptionist</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">cluster</span> <span class="k">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="nv">context</span><span class="o">.</span><span class="py">system</span><span class="o">)</span>
    <span class="nv">cluster</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberUp</span><span class="o">])</span>
    <span class="nv">cluster</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="n">self</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberRemoved</span><span class="o">])</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">postStop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="nv">cluster</span><span class="o">.</span><span class="py">unsubscribe</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="n">awaitingMembers</span>

    <span class="k">val</span> <span class="nv">awaitingMembers</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// Check if there are other nodes, and change to active if yes:</span>
        <span class="k">case</span> <span class="n">current</span><span class="k">:</span> <span class="kt">ClusterEvent.CurrentClusterState</span> <span class="o">=&gt;</span>
            <span class="k">val</span> <span class="nv">addresses</span> <span class="k">=</span> <span class="nv">current</span><span class="o">.</span><span class="py">members</span><span class="o">.</span><span class="py">toVector</span> <span class="nf">map</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">address</span><span class="o">)</span>
            <span class="k">val</span> <span class="nv">notMe</span> <span class="k">=</span> <span class="n">addresses</span> <span class="nf">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">!=</span> <span class="nv">cluster</span><span class="o">.</span><span class="py">selfAddress</span><span class="o">)</span>
            <span class="nf">if</span> <span class="o">(</span><span class="nv">notMe</span><span class="o">.</span><span class="py">nonEmpty</span><span class="o">)</span> <span class="c1">// if there's another node in the cluster</span>
                <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">notMe</span><span class="o">))</span> <span class="c1">// change to active mode</span>
        
        <span class="c1">// Typically though, there are no other nodes in the beginning,</span>
        <span class="c1">// so we must wait for new ones:</span>
        <span class="c1">// If we get a new member, different from ourself:</span>
        <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">member</span><span class="o">)</span> <span class="k">if</span> <span class="nv">member</span><span class="o">.</span><span class="py">address</span> <span class="o">!=</span> <span class="nv">cluster</span><span class="o">.</span><span class="py">selfAddress</span> <span class="k">=&gt;</span>
            <span class="c1">// change to active state with new member:</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="nv">member</span><span class="o">.</span><span class="py">addresses</span><span class="o">)))</span>
        <span class="k">case</span> <span class="nc">Get</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="nc">Failed</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="s">"no nodes available"</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">active</span><span class="o">(</span><span class="n">addresses</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Address</span><span class="o">])</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// New member that isn't ourself:</span>
        <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">member</span><span class="o">)</span> <span class="k">if</span> <span class="nv">member</span><span class="o">.</span><span class="py">address</span> <span class="o">!=</span> <span class="nv">cluster</span><span class="o">.</span><span class="py">selfAddress</span> <span class="k">=&gt;</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">addresses</span> <span class="o">:+</span> <span class="nv">member</span><span class="o">.</span><span class="py">address</span><span class="o">))</span> <span class="c1">// add him</span>

        <span class="c1">// Member removed:</span>
        <span class="k">case</span> <span class="nc">MemberRemoved</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="c1">// Filter the removed member out:</span>
            <span class="k">val</span> <span class="nv">next</span> <span class="k">=</span> <span class="n">addresses</span> <span class="nf">filterNot</span> <span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="nv">member</span><span class="o">.</span><span class="py">address</span><span class="o">)</span>
            <span class="nf">if</span> <span class="o">(</span><span class="nv">next</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="c1">// if it was the last one, go back to awaiting</span>
                <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="n">awaitingMembers</span><span class="o">)</span>
            <span class="k">else</span> <span class="c1">// otherwise, stay active (with the reduced list)</span>
                <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="nf">active</span><span class="o">(</span><span class="n">next</span><span class="o">))</span>
        
        <span class="c1">// Get request comes in, and we have enough resources to handle it:</span>
        <span class="k">case</span> <span class="nc">Get</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="k">if</span> <span class="nv">context</span><span class="o">.</span><span class="py">children</span><span class="o">.</span><span class="py">size</span> <span class="o">&lt;</span> <span class="nv">addresses</span><span class="o">.</span><span class="py">size</span> <span class="k">=&gt;</span>
            <span class="k">val</span> <span class="nv">client</span> <span class="k">=</span> <span class="n">sender</span> <span class="c1">// COPY client, since Customer will be async</span>
            <span class="k">val</span> <span class="nv">address</span> <span class="k">=</span> <span class="nf">pick</span><span class="o">(</span><span class="n">addresses</span><span class="o">)</span> <span class="c1">// pick one randomly from the list</span>
            <span class="c1">// create new Customer Actor:</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">client</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="n">address</span><span class="o">)))</span>
        <span class="c1">// Get request comes in, and we don't have the resources to handle it:</span>
        <span class="k">case</span> <span class="nc">Get</span><span class="o">(</span><span class="n">url</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="n">sender</span> <span class="o">!</span> <span class="nc">Failed</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="s">"too many parallel queries"</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There‚Äôs a <code class="highlighter-rouge">Customer</code> Actor that makes sure the given <code class="highlighter-rouge">url</code> is retrieved, but the work is supposed to be performed at a remote <code class="highlighter-rouge">node</code>. For that, it creates a <code class="highlighter-rouge">Controller</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">client</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> <span class="n">url</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">node</span><span class="k">:</span> <span class="kt">Address</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
    <span class="c1">// self is implicitly sent as sender.</span>
    <span class="c1">// From the outside, we want to make it look like the sender is</span>
    <span class="c1">// Receptionist, not this intermediary Actor.</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">context</span><span class="o">.</span><span class="py">parent</span>

    <span class="k">override</span> <span class="k">val</span> <span class="nv">supervisorStrategy</span> <span class="k">=</span> <span class="nv">SupervisorStrategy</span><span class="o">.</span><span class="py">stoppingStrategy</span>
    <span class="c1">// Deploy with remote scope on the given node, not locally:</span>
    <span class="k">val</span> <span class="nv">props</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">Controller</span><span class="o">].</span><span class="py">withDeploy</span><span class="o">(</span><span class="nc">Deploy</span><span class="o">(</span><span class="n">scope</span> <span class="k">=</span> <span class="nc">RemoteScope</span><span class="o">(</span><span class="n">node</span><span class="o">)))</span>
    <span class="k">val</span> <span class="nv">controller</span> <span class="k">=</span> <span class="nv">context</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="s">"controller"</span><span class="o">)</span>
    <span class="nv">context</span><span class="o">.</span><span class="py">watch</span><span class="o">(</span><span class="n">controller</span><span class="o">)</span>

    <span class="nv">context</span><span class="o">.</span><span class="py">setReceiveTimeout</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
    <span class="n">controller</span> <span class="o">!</span> <span class="nv">Controller</span><span class="o">.</span><span class="py">Check</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">({</span> <span class="c1">// supervise Controller</span>
        <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">=&gt;</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">unwatch</span><span class="o">(</span><span class="n">controller</span><span class="o">)</span>
            <span class="n">client</span> <span class="o">!</span> <span class="nv">Receptrionist</span><span class="o">.</span><span class="py">Failed</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="s">"controller timed out"</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Terminated</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="n">client</span> <span class="o">!</span> <span class="nv">Receptionist</span><span class="o">.</span><span class="py">Failed</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="s">"controller died"</span><span class="o">)</span>
        <span class="k">case</span> <span class="nv">Controller</span><span class="o">.</span><span class="py">Result</span><span class="o">(</span><span class="n">links</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nv">context</span><span class="o">.</span><span class="py">unwatch</span><span class="o">(</span><span class="n">controller</span><span class="o">)</span>
            <span class="n">client</span> <span class="o">!</span> <span class="nv">Receptionist</span><span class="o">.</span><span class="py">Result</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">links</span><span class="o">)</span>
    <span class="o">}</span><span class="k">:</span> <span class="kt">Receive</span><span class="o">)</span> <span class="nf">andThen</span> <span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">context</span><span class="o">.</span><span class="py">stop</span><span class="o">(</span><span class="n">self</span><span class="o">))</span> <span class="c1">// recursive stop, controller stops too</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">Controller</code> is the worker; its parent is the <code class="highlighter-rouge">Customer</code>.</p>

<h4 id="eventual-consistency">Eventual Consistency</h4>
<p>We‚Äôve now seen how Clusters work. What‚Äôs evident is that everything <em>takes time</em>: node joining takes time to disseminate the information among the rest of the cluster, it takes time until the welcome message arrives, etc. The decisions aren‚Äôt taken immediately, they‚Äôre taken eventually.</p>

<p>When we made a bank account thread safe, we made it <strong>strongly consistent</strong>: after an update, all subsequent reads will return the updated value.</p>

<p>We can also define <strong>weak consistency</strong>: after an update, certain conditions need to be met before the update is visible ‚Äî in other words, it takes a little while before our update can be read. This is the <em>inconsistency window</em>.</p>

<p><strong>Eventual consistency</strong> is a special kind of weak consistency. It states that once no more updates are made to an object, after a while (once everyone has communicated the value) reads will all return the last written value.</p>

<p>Let‚Äôs try it out with a simple Actor.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Update</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// gives a new value</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Get</span> <span class="c1">// get request</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Result</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// result reply type</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Sync</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">timestamp</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="c1">// synchronization messages</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Hello</span> <span class="c1">// to learn of other actors' existence</span>

<span class="k">class</span> <span class="nc">DistributedStore</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="c1">// eventually consistent</span>
    <span class="k">var</span> <span class="n">peers</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">ActorRef</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
    <span class="k">var</span> <span class="n">field</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="n">lastUpdate</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">currentTimeMillis</span><span class="o">()</span>

    <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Update</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="n">field</span> <span class="k">=</span> <span class="n">x</span>
            <span class="n">lastUpdate</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">currentTimeMillis</span><span class="o">()</span>
            <span class="n">peers</span> <span class="nf">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="o">!</span> <span class="nc">Sync</span><span class="o">(</span><span class="n">field</span><span class="o">,</span> <span class="n">lastUpdate</span><span class="o">))</span>
        <span class="k">case</span> <span class="nc">Get</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="nc">Result</span><span class="o">(</span><span class="n">field</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Sync</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">)</span> <span class="k">if</span> <span class="n">timestamp</span> <span class="o">&gt;</span> <span class="n">lastUpdate</span> <span class="k">=&gt;</span>
            <span class="n">field</span> <span class="k">=</span> <span class="n">x</span>
            <span class="n">lastUpdate</span> <span class="k">=</span> <span class="n">timestamp</span>
        <span class="k">case</span> <span class="nc">Hello</span> <span class="k">=&gt;</span>
            <span class="n">peers</span> <span class="o">::=</span> <span class="n">sender</span> <span class="c1">// append new sender</span>
            <span class="n">sender</span> <span class="o">!</span> <span class="nc">Sync</span><span class="o">(</span><span class="n">field</span><span class="o">,</span> <span class="n">lastUpdate</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This should clarify the concept of eventual consistency a bit. Updates are taken into account, but eventually the ‚Äútruth‚Äù propagates throughout the peer network.</p>

<p>Actors and eventual consistency are closely tied:</p>

<ul>
  <li>An actor forms an island of consistency, surrounded by an ocean of non-determinism</li>
  <li>Collaborating actors can at most be eventually consistent ‚Äî they can‚Äôt be strongly consistent, since messages take time to be sent. Note that eventual consistency isn‚Äôt a given, it doesn‚Äôt come automatically: some work still needs to be done to ensure this.</li>
  <li>Event consistency requires us to disseminate all updates to interested parties eventually (there needs to be a resend mechanism).</li>
  <li>The shared data structures need to be suitable for that. We can for instance use CRDTs (Commutative Replicated Data Types, a class of data types)
.</li>
</ul>

<h2 id="part-4-big-data-analysis-with-scala-and-spark">Part 4: Big Data Analysis with Scala and Spark</h2>
<p>This part focuses on how to map some of the abstractions that we‚Äôve learned so far to computations on multiple machines over massive datasets. Why Scala, why Spark? The alternatives for data processing, like R, Python and MATLAB don‚Äôt scale when our datasets get too large to fit into memory. Once we get more than a few gigabytes, we have to re-implement everything in some other language or system, like Spark or Hadoop.</p>

<p>Why Spark over Hadoop?</p>

<ul>
  <li>The functional paradigm scales very well</li>
  <li>Spark is more expressive: APIs are modeled after Scala collections, they look like functional lists.</li>
  <li>Spark is performant, in terms of running time (sometimes x120), but also in terms of dev productivity. It‚Äôs also interactive, which Hadoop isn‚Äôt</li>
  <li>Good for data science, since it enables iteration (most data science problems involve iteration). Once data is in memory, Spark applies all functional iterations, instead of spending time needlessly doing IO.</li>
</ul>

<p>Throughout this part, we‚Äôll use the <strong>Apache Spark</strong> framework for distributed data-parallel programming. Spark implements a data model called <strong>Resilient Distributed Datasets (RDDs)</strong>, the distributed counterpart of a parallel collection.</p>

<h3 id="data-parallel-to-distributed-data-parallel">Data-Parallel to Distributed Data-Parallel</h3>
<p>In this section, we‚Äôll bridge the gap between parallelism with shared memory and distributed data parallelism. Let‚Äôs look at an example for shared memory:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">res</span> <span class="k">=</span> <span class="nv">jar</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">jellyBean</span> <span class="k">=&gt;</span> <span class="nf">doSomething</span><span class="o">(</span><span class="n">jellyBean</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We‚Äôve seen before that we have a sort of collection abstraction going on, where if <code class="highlighter-rouge">jar</code> is a parallel array, then the data is split up between workers/threads, which combine when they‚Äôre done (if necessary) ‚Äî but this is done under the hood. In the distributed case, we need to split the data over several nodes (instead of several workers), which independently operate on data shards in parallel, and combine when done, and we now have to worry about network latency between workers. What would that look like?</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">res</span> <span class="k">=</span> <span class="nv">jar</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">jellyBean</span> <span class="k">=&gt;</span> <span class="nf">doSomething</span><span class="o">(</span><span class="n">jellyBean</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>It‚Äôs the same! Just like before, we can keep collections abstraction over <em>distributed</em> data-parallel execution. So a lot of what we‚Äôve learned can now be applied (including problems, i.e. with non-associative reduction operations), but we also have latency as an extra problem.</p>

<h4 id="latency">Latency</h4>
<p>Latency cannot be masked completely, we always have to think about it. It will be an important aspect that also impacts the programming model. Latency of a packet from the US to Europe and back to the US is approximately 150ms, compared to 100ns for reading from memory, so it‚Äôs about a million times slower. Network is <em>super</em> slow, so slow that it changes how we must work.</p>

<p>Hadoop has <strong>fault-tolerance</strong> (this is important because once you have 1000 nodes, crashes and network faults happen), but it comes at a cost: between each map and reduce step, in order to recover from potential failures, Hadoop/MapReduce shuffles its data and writes intermediate data to disk. This is also very slow. Spark manages to keep fault-tolerance, but reduces latency by keeping all data <strong>immutable and in-memory</strong>. Then fault tolerance is achieved by replaying functional transformations over the original dataset.</p>

<h3 id="rdds-sparks-distributed-collections">RDDs, Spark‚Äôs Distributed Collections</h3>
<p>RDDs look a lot like <strong>immutable</strong> sequential or parallel Scala collections, and make a lot of use of higher-order functions.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">RDD</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">TraversableOnce</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">fold</span><span class="o">(</span><span class="n">z</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">aggregate</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="n">seqop</span><span class="k">:</span> <span class="o">(</span><span class="kt">U</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">U</span><span class="o">,</span> <span class="n">combop</span><span class="k">:</span> <span class="o">(</span><span class="kt">U</span><span class="o">,</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">distinct</span><span class="o">()</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span> <span class="c1">// duplicates removed</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Every definition closely resembles the regular Scala Collection definition, except for <code class="highlighter-rouge">aggregate</code>, which takes <code class="highlighter-rouge">z</code> by value instead of CBN like in normal Scala. This is because copies need to be made, we can‚Äôt send a reference to <code class="highlighter-rouge">z</code> since it may be sent over the network to another node.</p>

<p>Let‚Äôs try an example. Given <code class="highlighter-rouge">val encyclopedia: RDD[String]</code>, say we want to search all of <code class="highlighter-rouge">encyclopedia</code> for mentions of EPFL, and count the number of pages mentioning it:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">res</span> <span class="k">=</span> <span class="nv">encyclopedia</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">page</span> <span class="k">=&gt;</span> <span class="nv">page</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="s">"EPFL"</span><span class="o">)).</span><span class="py">count</span><span class="o">()</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Let‚Äôs try word counting (this is like ‚ÄúHello World‚Äù for large-scale data):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">// Create RDD:</span>
<span class="k">val</span> <span class="nv">rdd</span> <span class="k">=</span> <span class="nv">spark</span><span class="o">.</span><span class="py">textFile</span><span class="o">(</span><span class="s">"hdfs://..."</span><span class="o">)</span> <span class="c1">// more on this later</span>

<span class="k">val</span> <span class="nv">count</span> <span class="k">=</span> <span class="nv">rdd</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="nv">line</span><span class="o">.</span><span class="py">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span> <span class="c1">// separate lines into words</span>
               <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">word</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>           <span class="c1">// include something to count</span>
               <span class="o">.</span><span class="py">reduceByKey</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>               <span class="c1">// sum up the 1s in the pairs</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">reduceByKey</code> is a special Spark method that we‚Äôll talk more about later.</p>

<h4 id="creating-rdds">Creating RDDs</h4>
<p>RDDs can be created in two ways:</p>

<ul>
  <li><em>Transforming an existing RDD</em>: using higher order functions, for instance</li>
  <li><em>From a</em> <code class="highlighter-rouge">SparkContext</code> <em>or</em> <code class="highlighter-rouge">SparkSession</code> <em>object</em>: <code class="highlighter-rouge">SparkContext</code> (now renamed to <code class="highlighter-rouge">SparkSession</code>) is how we handle the Spark cluster. It represents the connection between the Spark cluster and our running application, and uses a handful of methods to create and populate a new RDD:
    <ul>
      <li><code class="highlighter-rouge">parallelize</code>: convert local Scala collection to an RDD</li>
      <li><code class="highlighter-rouge">textFile</code>: read a text file from HDFS or local file system and return <code class="highlighter-rouge">RDD[String]</code></li>
    </ul>
  </li>
</ul>

<h4 id="transformations-and-actions">Transformations and Actions</h4>
<p>A reminder of <em>transformers</em> and <em>accessors</em>:</p>

<ul>
  <li><strong>Transformers</strong>: return new collections as results (<code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">groupBy</code>, ‚Ä¶)</li>
  <li><strong>Accessors</strong>: return single value as result (<code class="highlighter-rouge">reduce</code>, <code class="highlighter-rouge">fold</code>, <code class="highlighter-rouge">aggregate</code>)</li>
</ul>

<p>In Spark, we have <strong>transformations</strong> instead of transformers, and <strong>actions</strong> instead of accessors. Why do we use a different name, when there‚Äôs seemingly no difference? Because there‚Äôs a new, enormous difference: <strong>Transformations are lazy, actions are eager</strong>: for transformations, the resulting RDD is not immediately computed, while the result of actions are. Laziness/eagerness is how we can limit network communication using the programming model, so this is important.</p>

<p>Let‚Äôs look at an example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="c1">// Let sc be a SparkContext</span>
<span class="k">val</span> <span class="nv">largeList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">wordsRdd</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">sc</span><span class="o">.</span><span class="py">parallelize</span><span class="o">(</span><span class="n">largeList</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">lengthsRdd</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">wordsRdd</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">length</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>At this point, the RDD hasn‚Äôt changed! This is because the transformations are deferred; all we get back is an address to an RDD that doesn‚Äôt yet exist. To kick off the computation and wait for its result, we can add an action:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">totalChars</span> <span class="k">=</span> <span class="nv">lengthsRdd</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is important to remember: nothing happens until we call an action.</p>

<p>A few common transformations:</p>

<ul>
  <li><code class="highlighter-rouge">map[B](f: A =&gt; B): RDD[B]</code>: apply <code class="highlighter-rouge">f</code> to each element in the RDD and return RDD of the result</li>
  <li><code class="highlighter-rouge">flatMap[B](f: A =&gt; TraversableOnce[B]): RDD[B]</code>: apply <code class="highlighter-rouge">f</code> to each element in the RDD and return an RDD of the contents of what the iterators returned.</li>
  <li><code class="highlighter-rouge">filter(pred: A =&gt; Boolean): RDD[A]</code>: Apply <code class="highlighter-rouge">pred</code> to each element and return <code class="highlighter-rouge">RDD</code> of elements passing the predicate condition</li>
  <li><code class="highlighter-rouge">distinct(): RDD[B]</code>: return RDD with duplicates removed</li>
</ul>

<p>Transformations on two RDDs:</p>

<ul>
  <li><code class="highlighter-rouge">union(other: RDD[T]): RDD[T]</code>: return an RDD containing elements from both RDDs</li>
  <li><code class="highlighter-rouge">intersection(other: RDD[T]): RDD[T]</code>: return an RDD containing elements only found in both RDDs</li>
  <li><code class="highlighter-rouge">subtract(other: RDD[T]): RDD[T]</code>: return an RDD containing elements only found in both RDDs</li>
  <li><code class="highlighter-rouge">cartesian[U](other: RDD[U]): RDD[(T, U)]</code>: Cartesian product with other RDD</li>
</ul>

<p>Here are a few common actions:</p>

<ul>
  <li><code class="highlighter-rouge">collect(): Array[T]</code>: return all elements from RDD</li>
  <li><code class="highlighter-rouge">count(): Long</code>: return the number of elements in the RDD</li>
  <li><code class="highlighter-rouge">take(num: Int): Array[T]</code>: return the first <code class="highlighter-rouge">num</code> elements of the <code class="highlighter-rouge">RDD</code></li>
  <li><code class="highlighter-rouge">reduce(op: (A, A) =&gt; A): A</code>: combine the elements in the RDD together using <code class="highlighter-rouge">op</code> and return result</li>
  <li><code class="highlighter-rouge">foreach(f: T =&gt; Unit): Unit</code>: apply <code class="highlighter-rouge">f</code> to each element in the RDD</li>
  <li><code class="highlighter-rouge">takeSample(withRepl: Boolean, num: Int): Array[T]</code>: return array with a random sample of num elements of the dataset, with or without replacement</li>
  <li><code class="highlighter-rouge">takeOrdered(num: Int)(implicit ord: Ordering[T]): Array[T]</code>: return first n elements of the RDD using either their natural order or a custom comparator</li>
  <li><code class="highlighter-rouge">saveAsTextFile(path: String): Unit</code>: write elements of the dataset as a textr file in the local filesystem or HDFS</li>
  <li><code class="highlighter-rouge">saveAsSequenceFile(path: String): Unit</code>: write the elements of the dataset as a Hadoop SequenceFile in the local filesystem or HDFS</li>
</ul>

<p>Let‚Äôs do another example. Assume that we have an <code class="highlighter-rouge">RDD[String]</code> which contains gigabytes of logs collected over the previous years. Dates come in the form <code class="highlighter-rouge">YYYY-MM-DD:HH:MM:SS</code>, errors are logged with a prefix including the word ‚Äúerror‚Äù. To determine the number of errors that were logged in December 2016:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">lastYearsLogs</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">numDecErrorLogs</span> <span class="k">=</span> 
    <span class="nv">lastYearsLogs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">lg</span> <span class="k">=&gt;</span> <span class="nv">lg</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="s">"2016-12"</span> <span class="o">&amp;&amp;</span> <span class="nv">lg</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="s">"error"</span><span class="o">)))</span>
                 <span class="o">.</span><span class="py">count</span><span class="o">()</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="benefits-of-laziness-for-large-scale-data">Benefits of laziness for Large-Scale Data</h4>
<p>Consider the following examples:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">lastYearsLogs</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">firstLogsWithErrors</span> <span class="k">=</span> <span class="nv">lastYearsLogs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="s">"ERROR"</span><span class="o">)).</span><span class="py">take</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Spark can leverage the fact that <code class="highlighter-rouge">filter</code> is deferred until <code class="highlighter-rouge">take</code> by <strong>analyzing and optimizing</strong> the chain of operations <em>before</em> executing it to reduce the number of iterations. Spark will not compute intermediate RDDs. Instead, in this case, as soon as 10 elements of the filtered RDD have been computed, it is done.</p>

<h4 id="caching-and-persistence">Caching and Persistence</h4>
<p>Let‚Äôs look at an example. A logistic regression follows the following formula:</p>

\[w \leftarrow w - \alpha \sum_{i=1}^n{g(w; x_i, y_i)}\]

<p>Let‚Äôs try to implement it in a straightforward way:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">points</span> <span class="k">=</span> <span class="nv">sc</span><span class="o">.</span><span class="py">textFile</span><span class="o">(...).</span><span class="py">map</span><span class="o">(</span><span class="n">parsePoint</span><span class="o">)</span>
<span class="k">var</span> <span class="n">w</span> <span class="k">=</span> <span class="nv">Vector</span><span class="o">.</span><span class="py">zeros</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="c1">// initialize weights to 0</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">numIterations</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">gradient</span> <span class="k">=</span> <span class="nv">points</span><span class="o">.</span><span class="py">map</span> <span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span> 
        <span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">exp</span><span class="o">(-</span><span class="nv">p</span><span class="o">.</span><span class="py">y</span> <span class="o">*</span> <span class="nv">w</span><span class="o">.</span><span class="py">dot</span><span class="o">(</span><span class="nv">p</span><span class="o">.</span><span class="py">x</span><span class="o">)))</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="nv">p</span><span class="o">.</span><span class="py">y</span> <span class="o">*</span> <span class="nv">p</span><span class="o">.</span><span class="py">y</span>
    <span class="o">}.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
    <span class="n">w</span> <span class="o">-=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">gradient</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We use a <code class="highlighter-rouge">reduce</code>, so we call <code class="highlighter-rouge">numIterations</code> actions. Notice how the reduce is done on <code class="highlighter-rouge">points</code>: this is problematic, because Spark recomputes an RDD every time we call an action on it. In our example above, we‚Äôre calling <code class="highlighter-rouge">parsePoint</code> waaaay too many times! To tell Spark to cache an RDD in memory (say if we need to use it multiple times), we can call <code class="highlighter-rouge">.persist()</code> or <code class="highlighter-rouge">.cache()</code> on them.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">points</span> <span class="k">=</span> <span class="nv">sc</span><span class="o">.</span><span class="py">textFile</span><span class="o">(...).</span><span class="py">map</span><span class="o">(</span><span class="n">parsePoint</span><span class="o">).</span><span class="py">persist</span><span class="o">()</span> <span class="c1">// huge perf improvement</span>
<span class="k">var</span> <span class="n">w</span> <span class="k">=</span> <span class="nv">Vector</span><span class="o">.</span><span class="py">zeros</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="c1">// initialize weights to 0</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">numIterations</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">gradient</span> <span class="k">=</span> <span class="nv">points</span><span class="o">.</span><span class="py">map</span> <span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span> 
        <span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">exp</span><span class="o">(-</span><span class="nv">p</span><span class="o">.</span><span class="py">y</span> <span class="o">*</span> <span class="nv">w</span><span class="o">.</span><span class="py">dot</span><span class="o">(</span><span class="nv">p</span><span class="o">.</span><span class="py">x</span><span class="o">)))</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="nv">p</span><span class="o">.</span><span class="py">y</span> <span class="o">*</span> <span class="nv">p</span><span class="o">.</span><span class="py">y</span>
    <span class="o">}.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
    <span class="n">w</span> <span class="o">-=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">gradient</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are many ways to configure how your data is persisted:</p>

<ul>
  <li>In memory as regular Java objects</li>
  <li>On disk as regular Java objects</li>
  <li>In memory as serialized Java objects (more compact)</li>
  <li>On disk as serialized Java objects</li>
  <li>Both in memory and on disk (spill over to disk to avoid re-computation)</li>
</ul>

<p><code class="highlighter-rouge">.cache()</code> is a shorthand for the default, which is in memory only, as regular Java objects. <code class="highlighter-rouge">.persist()</code> can be customized.</p>

<h3 id="reductions">Reductions</h3>
<p>Remember that <code class="highlighter-rouge">fold</code> and <code class="highlighter-rouge">aggregate</code> are parallelizable, but <code class="highlighter-rouge">foldLeft</code> isn‚Äôt. Therefore, Spark implements <code class="highlighter-rouge">fold</code>, <code class="highlighter-rouge">reduce</code>, <code class="highlighter-rouge">aggregate</code> on RDDs, but not <code class="highlighter-rouge">foldLeft</code> or <code class="highlighter-rouge">foldRight</code>. Why can‚Äôt it just implement it sequentially? Well, it takes a lot of synchronization to do things serially across a cluster, which is difficult, and it doesn‚Äôt make a lot of sense on a cluster.</p>

<p>So since those aren‚Äôt an option, we‚Äôll have to use <code class="highlighter-rouge">aggregate</code> is we need to change the return type of our reduction operation.</p>

<h3 id="distributed-key-value-pairs-pair-rdds">Distributed Key-Value Pairs (Pair RDDs)</h3>
<p>In single-node Scala, we had <strong>maps</strong>. In Spark, we think of those as key-value pairs, or <strong>Pair RDDs</strong>. In practice, this is a data structure that is used very often for big data analysis; most computations <em>map</em> data to a key-value pair, and reduce it to a final result.</p>

<p>Pair RDDs have <a href="https://spark.apache.org/docs/2.0.0/api/scala/index.html#org.apache.spark.rdd.PairRDDFunctions">additional, specialized methods</a> for working with data associated with keys.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="nc">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">)]</span> <span class="c1">// Treated specially by Spark!!</span>

<span class="c1">// Methods include: </span>
<span class="k">def</span> <span class="nf">groupByKey</span><span class="o">()</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">Iterable</span><span class="o">[</span><span class="kt">V</span><span class="o">])]</span>
<span class="k">def</span> <span class="nf">reduceByKey</span><span class="o">(</span><span class="n">func</span><span class="k">:</span> <span class="o">(</span><span class="kt">V</span><span class="o">,</span> <span class="kt">V</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">V</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">)]</span>
<span class="k">def</span> <span class="nf">join</span><span class="o">[</span><span class="kt">W</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">W</span><span class="o">)])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="o">(</span><span class="kt">V</span>, <span class="kt">W</span><span class="o">))]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="creating-a-pair-rdd">Creating a Pair RDD</h4>
<p>Pair RDDs are most often created from already-existing non-pair RDDs, for example by using the <code class="highlighter-rouge">map</code> operation:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">rdd</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">WikipediaPage</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">pairRdd</span> <span class="k">=</span> <span class="nv">rdd</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">page</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nv">page</span><span class="o">.</span><span class="py">title</span><span class="o">,</span> <span class="nv">page</span><span class="o">.</span><span class="py">text</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="groupbykey"><code class="highlighter-rouge">groupByKey</code></h4>
<p>In regular Scala, we had <code class="highlighter-rouge">groupBy</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="c1">// Partitions this traversabel collection into a map of traversable</span>
<span class="c1">// collections according to some discriminator function</span>
<span class="k">def</span> <span class="nf">groupBy</span><span class="o">[</span><span class="kt">K</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">K</span><span class="o">)</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In English: it breaks up a collection into two or more collections according to a function that we pass to it.</p>

<ul>
  <li><strong>Key</strong>: The result of the function</li>
  <li><strong>Value</strong>: The collection of elements that return that key when the function is applied to it</li>
</ul>

<p>Spark‚Äôs <code class="highlighter-rouge">groupByKey</code> can be thought of as a <code class="highlighter-rouge">groupBy</code> on Pair RDDs that is specialized in grouping all values that have the same key. As a result, it takes no argument, no discriminator function.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">groupByKey</span><span class="o">()</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">Iterable</span><span class="o">[</span><span class="kt">V</span><span class="o">])]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In English:</p>

<ul>
  <li><strong>Key</strong>: Key</li>
  <li><strong>Value</strong>: The collection of values with the given key</li>
</ul>

<h4 id="reducebykey"><code class="highlighter-rouge">reduceByKey</code></h4>
<p><code class="highlighter-rouge">reduceByKey</code> can be thought of as a combination of <code class="highlighter-rouge">groupByKey</code> and <code class="highlighter-rouge">reduce</code> on all the values per key. It‚Äôs more efficient though, than using each separately.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">reduceByKey</span><span class="o">(</span><span class="n">func</span><span class="k">:</span> <span class="o">(</span><span class="kt">V</span><span class="o">,</span> <span class="kt">V</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">V</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">)]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The function only cares about the <em>values</em>: we assume that the elements are already grouped by key, and now we apply this reduction function.</p>

<h4 id="mapvalues"><code class="highlighter-rouge">mapValues</code></h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">mapValues</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">V</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">U</span><span class="o">)]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Can be thought of as a short-hand for:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nv">rdd</span><span class="o">.</span><span class="py">map</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">x</span><span class="o">,</span> <span class="kt">f</span><span class="o">(</span><span class="kt">y</span><span class="o">))</span> <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>That is, it simply applies a function to the values in a Pair RDD.</p>

<h4 id="countbykey"><code class="highlighter-rouge">countByKey</code></h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">countByKey</span><span class="o">()</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">Long</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Simply counts the number of elements per key in a Pair RDD, returning a normal Scala <code class="highlighter-rouge">Map</code> (this is an action) mapping keys to counts.</p>

<h4 id="keys"><code class="highlighter-rouge">keys</code></h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">keys</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">K</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This returns a RDD with the keys of each tuple (this is a transformation).</p>

<h4 id="example">Example</h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">intermediate</span> <span class="k">=</span> 
    <span class="nv">eventsRdd</span><span class="o">.</span><span class="py">mapValues</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>  <span class="c1">// (org, (budget, 1))</span>
             <span class="o">.</span><span class="py">reduceByKey</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nv">a</span><span class="o">.</span><span class="py">_1</span> <span class="o">+</span> <span class="nv">b</span><span class="o">.</span><span class="py">_1</span><span class="o">,</span> <span class="nv">a</span><span class="o">.</span><span class="py">_2</span> <span class="o">+</span> <span class="nv">b</span><span class="o">.</span><span class="py">_2</span><span class="o">))</span> <span class="c1">// (org, (totalBudget, total#events))</span>

<span class="k">val</span> <span class="nv">avgBudgets</span> <span class="k">=</span> <span class="nv">intermediate</span><span class="o">.</span><span class="py">mapValues</span> <span class="o">{</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">budget</span><span class="o">,</span> <span class="n">numberEvents</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">budget</span> <span class="o">/</span> <span class="n">numberOfEvents</span>
<span class="o">}</span>
<span class="nv">avgBudgets</span><span class="o">.</span><span class="py">collect</span><span class="o">().</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span> <span class="c1">// (org, avgBudget)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="joins">Joins</h3>
<p>Joins are unique to Pair RDDs. They‚Äôre used to combine multiple datasets. There are 2 kinds of joins:</p>

<ul>
  <li>Inner joins (<code class="highlighter-rouge">join</code>)</li>
  <li>Outer joins (<code class="highlighter-rouge">leftOuterJoin</code>, <code class="highlighter-rouge">rightOuterJoin</code>)</li>
</ul>

<p>The key difference between the two is what happens to the keys when both RDDs don‚Äôt contain the same key.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="c1">// Returns a new RDD containing combined pairs whose</span>
<span class="c1">// keys are present in BOTH RDDs</span>
<span class="k">def</span> <span class="nf">join</span><span class="o">[</span><span class="kt">W</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">W</span><span class="o">])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="o">(</span><span class="kt">V</span>, <span class="kt">W</span><span class="o">))]</span>

<span class="c1">// Outer joins return a new RDD containing combined pairs</span>
<span class="c1">// whose key don't have to be present in both input RDDs</span>
<span class="k">def</span> <span class="nf">leftOuterJoin</span><span class="o">[</span><span class="kt">W</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">W</span><span class="o">)])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="o">(</span><span class="kt">V</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">W</span><span class="o">]))]</span>
<span class="k">def</span> <span class="nf">rightOuterJoin</span><span class="o">[</span><span class="kt">W</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">W</span><span class="o">)])</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">K</span>, <span class="o">(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">V</span><span class="o">]</span>, <span class="kt">W</span><span class="o">))]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The choice between <code class="highlighter-rouge">leftOuterJoin</code> and <code class="highlighter-rouge">rightOuterJoin</code> should be made by deciding which data is optional.</p>

<h3 id="shuffles">Shuffles</h3>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">pairs</span> <span class="k">=</span> <span class="nv">sc</span><span class="o">.</span><span class="py">parallelize</span><span class="o">(</span><span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="s">"one"</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"two"</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)))</span>
<span class="nv">pairs</span><span class="o">.</span><span class="py">groupByKey</span><span class="o">()</span>
<span class="c1">// res2: org.apache.spark.rdd.RDD[(Int, Iterable[String])]</span>
<span class="c1">//   = ShuffledRDD[16] at groupByKey at &lt;console&gt;:37</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We typically have to move data from one node to another to be grouped by key; doing this is called ‚Äúshuffling‚Äù. They are an enormous hit to performance because Spark must send data from one node to another over the network (latency costs!).</p>

<p>To minimize these latency costs, we can reduce the amount of data being sent over the network. This is why <code class="highlighter-rouge">reduceByKey</code> is more efficient than <code class="highlighter-rouge">groupByKey</code>: it does a <code class="highlighter-rouge">groupByKey</code> and <code class="highlighter-rouge">reduce</code> locally, then sends the reduced information around for a second round of <code class="highlighter-rouge">reduceByKey</code>. This means a non-trivial reduction of  data shuffling (in a simple example, we get a 3x speedup).</p>

<h4 id="partitioning">Partitioning</h4>
<p>How does Spark know which key to put on which machine? By default, it uses <em>hash</em> partitioning to determine which key-value pair should be sent to which machine.</p>

<p>The data within an RDD is split into several partitions.</p>

<ul>
  <li>Partitions never span multiple machines; tuples in the same partition are guaranteed to be on the same machine</li>
  <li>Each machine in the cluster contains one or more partitions</li>
  <li>The number of partitions to use is configurable. By default, it‚Äôs the total number of cores on all executor nodes</li>
</ul>

<p>There are two kinds of partitioning in Spark:</p>

<ul>
  <li>Hash partitioning: attempts to spread the data evenly across partitions <em>based on the keys</em> (<code class="highlighter-rouge">partition = k.hashCode() % numPartitions</code>)</li>
  <li>Range partitioning: when an <em>ordering</em> is defined on the keys, range partitioning may be more efficient. Keys are partitioned according to their ordering and a set of sorted ranges of keys.</li>
</ul>

<p>Customizing a partitioning is only possible on Pair RDDs. There are two ways to set partitioning for our data:</p>

<ul>
  <li>Call <code class="highlighter-rouge">partitionBy</code> on an RDD, providing an explicit <code class="highlighter-rouge">Partitioner</code></li>
  <li>Using transformations that return RDDs with specific <code class="highlighter-rouge">Partitioner</code>s
    <ul>
      <li>From parent RDD: the result of a transformation on a partitioned Pair RDD typically is configured to use the hash partitioner that was used to construct it</li>
      <li>Automatically-set partitioners: some operations result in an RDD with a known partitioner, for when it makes sense (<code class="highlighter-rouge">sortByKey</code> uses a <code class="highlighter-rouge">RangePartitioner</code>, <code class="highlighter-rouge">groupByKey</code> uses a <code class="highlighter-rouge">HashPartitioner</code>)</li>
    </ul>
  </li>
</ul>

<p>Let‚Äôs look at <code class="highlighter-rouge">partitionBy</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">pairs</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">tunedPartitioner</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RangePartitioner</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="n">pairs</span><span class="o">)</span> <span class="c1">// Spark will figure out the best partitioning</span>
<span class="k">val</span> <span class="nv">partitioned</span> <span class="k">=</span> <span class="nv">pairs</span><span class="o">.</span><span class="py">partitionBy</span><span class="o">(</span><span class="n">tunedPartitioner</span><span class="o">).</span><span class="py">persist</span><span class="o">()</span> <span class="c1">// persist so we don't have to shuffle data multiple times</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The result of <code class="highlighter-rouge">partitionBy</code> should always be persisted. Otherwise, the partitioning is repeatedly applied (involving shuffles) each time.</p>

<p>For partition resulting from transformations, the following operations on Pair RDDs hold on to (and propagate) a partitioner:</p>

<ul>
  <li><code class="highlighter-rouge">cogroup</code>, <code class="highlighter-rouge">groupWith</code>, <code class="highlighter-rouge">groupByKey</code></li>
  <li><code class="highlighter-rouge">join</code>, <code class="highlighter-rouge">leftOuterJoin</code>, <code class="highlighter-rouge">rightOuterJoin</code></li>
  <li><code class="highlighter-rouge">reduceByKey</code>, <code class="highlighter-rouge">foldByKey</code>, <code class="highlighter-rouge">combineByKey</code></li>
  <li><code class="highlighter-rouge">partitionBy</code></li>
  <li><code class="highlighter-rouge">sort</code></li>
  <li>If the parent has a partitioner: <code class="highlighter-rouge">mapValues</code>, <code class="highlighter-rouge">flapMapValues</code>, <code class="highlighter-rouge">filter</code></li>
</ul>

<p>All other operations will produce a result without a partitioner. Interestingly, <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code> aren‚Äôt on the list, since they can change the key; using them makes us lose our partitioning.</p>

<h4 id="optimizing-with-partitioners">Optimizing with Partitioners</h4>
<p>Using range partitioners we can optimize use of <code class="highlighter-rouge">reduceByKey</code> so that it doesn‚Äôt involve any shuffling over the network:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">pairs</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">tunedPartitioner</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RangePartitioner</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="n">pairs</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">partitioned</span> <span class="k">=</span> <span class="nv">pairs</span><span class="o">.</span><span class="py">partitionBy</span><span class="o">(</span><span class="n">tunedPartitioner</span><span class="o">).</span><span class="py">persist</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">purchasesPerCustomer</span> <span class="k">=</span> <span class="nv">partitioned</span><span class="o">.</span><span class="py">mapValues</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">purchasesPerMonth</span> <span class="k">=</span> <span class="nv">purchasesPerCustomer</span><span class="o">.</span><span class="py">reduceByKey</span><span class="o">{</span>
    <span class="nf">case</span> <span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span>
<span class="o">}.</span><span class="py">collect</span><span class="o">()</span> 
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is almost 9x faster than our initial examples.</p>

<p>As a <strong>rule of thumb</strong>, a shuffle <em>can</em> occur when the resulting RDD depends on other elements from the same RDD or another RDD. Here‚Äôs a list of operations that <em>might</em> cause a shuffle:</p>

<ul>
  <li><code class="highlighter-rouge">cogroup</code>, <code class="highlighter-rouge">groupWith</code>, <code class="highlighter-rouge">groupByKey</code></li>
  <li><code class="highlighter-rouge">join</code>, <code class="highlighter-rouge">leftOuterJoin</code>, <code class="highlighter-rouge">rightOuterJoin</code></li>
  <li><code class="highlighter-rouge">reduceByKey</code>, <code class="highlighter-rouge">combineByKey</code></li>
  <li><code class="highlighter-rouge">distinct</code>, <code class="highlighter-rouge">intersection</code></li>
  <li><code class="highlighter-rouge">repartition</code>, <code class="highlighter-rouge">coalesce</code></li>
</ul>

<p>There are ways to use these operations and still avoid much or all network shuffling. For instance, by running <code class="highlighter-rouge">reduceByKey</code> on a pre-partitioned RDD, or by running <code class="highlighter-rouge">join</code> on two RDDs that are pre-partitioned with the same partitioner and cached on the same machine, we avoid almost all network shuffling.</p>

<h4 id="wide-vs-narrow-dependencies">Wide vs Narrow Dependencies</h4>
<p>Computations on RDDs are represented as a <strong>lineage graph</strong>, a directed acyclic graph (DAG) representing the computations done on the RDD. Spark analyses the lineage graph to do optimizations.</p>

<p>Remember the rule of thumb above. Dependency information can tell us when a shuffle may occur. There are two kinds of dependencies:</p>

<ul>
  <li><strong>Narrow Dependencies</strong>: each partition of the parent RDD is used by at most one partition of the child RDD
    <ul>
      <li><code class="highlighter-rouge">join</code> (with co-partitioned inputs)</li>
      <li><code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">mapValues</code>, <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">union</code>, <code class="highlighter-rouge">mapPartitions</code>, <code class="highlighter-rouge">mapPartitionsWithIndex</code></li>
    </ul>
  </li>
  <li><strong>Wide Dependencies</strong>: each partition of the parent RDD may be depended on by <em>multiple</em> child partitions
    <ul>
      <li><code class="highlighter-rouge">join</code>, <code class="highlighter-rouge">leftOuterJoin</code>, <code class="highlighter-rouge">rightOuterJoin</code> (with inputs not co-partitioned)</li>
      <li><code class="highlighter-rouge">cogroup</code>, <code class="highlighter-rouge">groupWith</code> <code class="highlighter-rouge">groupByKey</code>, <code class="highlighter-rouge">groupBy</code>, <code class="highlighter-rouge">reduceByKey</code>, <code class="highlighter-rouge">combineByKey</code>, <code class="highlighter-rouge">distinct</code>, <code class="highlighter-rouge">intersection</code>, <code class="highlighter-rouge">repartition</code>, <code class="highlighter-rouge">coalesce</code>‚Ä¶</li>
    </ul>
  </li>
</ul>

<p>The former is fast! No shuffling is necessary, and optimizations like pipelining are possible. The latter is slow ‚Äî it requires some or all of the data to be shuffled over the network.</p>

<p>THere is a <code class="highlighter-rouge">dependencies</code> method on RDDs. It returns a sequence of <code class="highlighter-rouge">Dependency</code> objects, which are the dependencies used by Spark‚Äôs scheduler to know how this RDD depends on other RDDs.</p>

<p>The sorts of dependency objects it may return include:</p>

<ul>
  <li><strong>Narrow dependency objects</strong>: <code class="highlighter-rouge">OneToOneDependency</code>, <code class="highlighter-rouge">PruneDependency</code>, <code class="highlighter-rouge">RangeDependency</code></li>
  <li><strong>Wide dependency objects</strong>: <code class="highlighter-rouge">ShuffleDependency</code></li>
</ul>

<p>Another helpful method is <code class="highlighter-rouge">toDebugString</code>, which prints out a visualization of the RDD‚Äôs lineage, and other relevant scheduling information.</p>

<p>Lineage graphs are the key to fault tolerance in Spark: we can recover from failures by recomputing lost <em>partitions</em> from the lineage graphs (we can just recompute the <em>partition</em>, not the whole data set). This allows fault tolerance without writing to disk, which is why Spark is so fast.</p>

<p>Recomputing missing partitions is fast for narrow dependencies, but slow for wide dependencies.</p>

<h3 id="structured-and-unstructured-data">Structured and Unstructured Data</h3>
<p>In Spark, there are often multiple ways of achieving the same result, often with very different running times. For instance, filtering before joining is faster than joining before filtering, which itself is faster than computing a Cartesian product and then filtering.</p>

<p>Sometimes, the way we pick isn‚Äôt the fastest one; it would be great if Spark could optimize our commands to the fastest version! That‚Äôs what Spark SQL does: given a bit of extra structural information, Spark can do many optimizations for us!</p>

<p>All data isn‚Äôt created equal, structurally. It falls on a spectrum from unstructured (log files, images), to semi-structured (JSON, XML), to structured (database tables). With RDD, we‚Äôve been working with unstructed or semi-structured data, where we don‚Äôt know anything about the <strong>schema</strong> of the data we‚Äôre working with (we just have generic typing, without knowing what‚Äôs inside of the objects). The same can be said about <strong>computation</strong>; lambda operations are opaque to Spark (they‚Äôre not predefined like in SQL).</p>

<p>We‚Äôve got to give up some of the freedom, flexibility and generality of the functional collections API in order to give Spark more opportunities to optimize.</p>

<h3 id="spark-sql">Spark SQL</h3>
<p>Spark SQL is a Spark library with 3 main goals:</p>

<ol>
  <li>Support <strong>relational processing</strong> within Spark and on external data sources, so that we can mix SQL and functional APIs.</li>
  <li>High performance</li>
  <li>Support new data sources such as semi-structured data and external databases (it‚Äôs usually complicated to connect big data processing pipelines like Spark or Hadoop to an SQL database, but Spark SQL makes it easy).</li>
</ol>

<p>The three main APIs are:</p>

<ol>
  <li>SQL literal syntax</li>
  <li><code class="highlighter-rouge">DataFrames</code></li>
  <li><code class="highlighter-rouge">Datasets</code></li>
</ol>

<p>In the back-end, it adds:</p>

<ol>
  <li>Catalyst, a query optimizer</li>
  <li>Tungsten, off-heap serializer (encodes Scala objects efficiently off the heap, away from the garbage collector)</li>
</ol>

<h4 id="getting-started">Getting started</h4>
<p><code class="highlighter-rouge">DataFrame</code> is Spark SQL‚Äôs core abstraction. Conceptually, it‚Äôs equivalent to a table in a relational database. Conceptually, it‚Äôs an RDD full of records <strong>with a known schema</strong>. Unlike RDDs, DataFrames are untyped (no type paramater), but require schema information. One final terminological point: transformations on <code class="highlighter-rouge">DataFrames</code> are called untyped transformations.</p>

<p>To get started using Spark SQL, we‚Äôll start with <code class="highlighter-rouge">SparkSession</code> (the equivalent of <code class="highlighter-rouge">SparkContext</code>):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">org.apache.spark.sql.SparkSession</span>
<span class="k">val</span> <span class="nv">spark</span> <span class="k">=</span> <span class="nv">SparkSession</span><span class="o">.</span><span class="py">builder</span><span class="o">().</span><span class="py">appName</span><span class="o">(</span><span class="s">"My App"</span><span class="o">)</span>
    <span class="c1">// .config("spark.some.config.option", "some-value")</span>
    <span class="o">.</span><span class="py">getOrCreate</span><span class="o">()</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Data frames can be created in two ways. Either from an existing RDD:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">tupleRDD</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">tupleDF</span> <span class="k">=</span> <span class="nv">tupleRDD</span><span class="o">.</span><span class="py">toDF</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="s">"name"</span><span class="o">,</span> <span class="s">"city"</span><span class="o">,</span> <span class="s">"country"</span><span class="o">)</span> <span class="c1">// column names</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">city</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">peopleRDD</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">peopleDF</span> <span class="k">=</span> <span class="nv">peopleRDD</span><span class="o">.</span><span class="py">toDF</span> <span class="c1">// column names are automatically infered from Person</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Or, in another way, by defining a schema explicitly:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">peopleRDD</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// Step 1: create an RDD of rows from the original RDD</span>
<span class="k">val</span> <span class="nv">rowRDD</span> <span class="k">=</span> <span class="nv">peopleRDD</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">split</span><span class="o">(</span><span class="s">","</span><span class="o">))</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">attributes</span> <span class="k">=&gt;</span> <span class="nc">Row</span><span class="o">(</span><span class="nf">attributes</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="nf">attributes</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="py">trim</span><span class="o">))</span>

<span class="c1">// Step 2: create the schema represented by a StructType matching the structure of the rows</span>
<span class="k">val</span> <span class="nv">schemaString</span> <span class="k">=</span> <span class="s">"name age"</span>
<span class="k">val</span> <span class="nv">fields</span> <span class="k">=</span> <span class="nv">schemaString</span><span class="o">.</span><span class="py">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">fieldName</span> <span class="k">=&gt;</span> <span class="nc">StructField</span><span class="o">(</span><span class="n">fieldName</span><span class="o">,</span> <span class="nc">StringType</span><span class="o">,</span> <span class="n">nullable</span> <span class="k">=</span> <span class="kc">true</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">schema</span> <span class="k">=</span> <span class="nc">StructType</span><span class="o">(</span><span class="n">fields</span><span class="o">)</span>

<span class="c1">// Step 3: Apply the schema to the RDD of rows via createDataFrame</span>
<span class="k">val</span> <span class="nv">peopleDF</span> <span class="k">=</span> <span class="nv">spark</span><span class="o">.</span><span class="py">createDataFrame</span><span class="o">(</span><span class="n">rowRDD</span><span class="o">,</span> <span class="n">schema</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can also read from a source file (it supports JSON, CSV, <code class="highlighter-rouge">Parquet</code>, JDBC‚Ä¶ see <a href="https://spark.apache.org/docs/2.0.2/api/java/org/apache/spark/sql/DataFrameReader.html">the documentation</a>):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">df</span> <span class="k">=</span> <span class="nv">spark</span><span class="o">.</span><span class="py">read</span><span class="o">.</span><span class="py">json</span><span class="o">(</span><span class="s">"examples/src/main/resourceds/people.json"</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Once we have a <code class="highlighter-rouge">DataFrame</code>, we can freely write SQL syntax. We just have to register it as a temporary SQL view first:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="c1">// give it a name for the SQL FROM statement</span>
<span class="nv">peopleDF</span><span class="o">.</span><span class="py">createOrReplaceTempView</span><span class="o">(</span><span class="s">"people"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">adultsDF</span> <span class="k">=</span> <span class="nv">spark</span><span class="o">.</span><span class="py">sql</span><span class="o">(</span><span class="s">"SELECT * FROM people WHERE age &gt; 17"</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>See <a href="https://hortonworks.com/blog/hive-cheat-sheet-for-sql-users/">this cheat sheet</a> for supported SQL statements.</p>

<h4 id="dataframes">DataFrames</h4>
<p><code class="highlighter-rouge">DataFrames</code> are a relational API over Spark‚Äôs RDD, which can be aggressively optimized. Another thing to remember is that they‚Äôre untyped; the elements with <code class="highlighter-rouge">DataFrames</code> are <code class="highlighter-rouge">Rows</code>, which aren‚Äôt parameterized by a type, so the compiler cannot type check Spark SQL.</p>

<p>SQL does have types though; in order to access <em>any</em> of them, you must first import Spark SQL types:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">org.apache.spark.sql.types._</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">DataFrames</code> API contains operations that look similar to SQL, including, but not limited to, <code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">where</code>, <code class="highlighter-rouge">limit</code>, <code class="highlighter-rouge">orderBy</code>, <code class="highlighter-rouge">groupBy</code>, <code class="highlighter-rouge">join</code>, ‚Ä¶</p>

<p>To see what a <code class="highlighter-rouge">DataFrame</code> looks like, we can use <code class="highlighter-rouge">.show()</code>, which pretty prints the data‚Äôs first 20 elements in tabular form. <code class="highlighter-rouge">.printSchema()</code> prints the schema in tree format.</p>

<p>There are a few different ways to specify columns. The syntax is flexible, as it goes through an SQL parser, but the first two are often a little less error-prone:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="c1">// 1. Using $ notation</span>
<span class="c1">// requires import spark.implicits._</span>
<span class="nv">df</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">$</span><span class="s">"age"</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="o">)</span>

<span class="c1">// 2. Referring to the DataFrame</span>
<span class="nv">df</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="nf">df</span><span class="o">(</span><span class="s">"age"</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="o">)</span>

<span class="c1">// 3. Using SQL query string</span>
<span class="nv">df</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="s">"age &gt; 18"</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><em>Note:</em> <code class="highlighter-rouge">where</code> and <code class="highlighter-rouge">filter</code> are exactly equivalent. Use whichever looks/sounds best.</p>

<p>Like on RDDs, <strong>transformations</strong> on <code class="highlighter-rouge">DataFrames</code> are operations which return a <code class="highlighter-rouge">DataFrame</code> as a result, and are lazily evaluated. As an example, assume we have a dataset of homes currently for sale in an entire US state. We want the most expensive and the least expensive homes for sale per zip code.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">org.apache.spark.sql.functions._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Listing</span><span class="o">(</span><span class="n">street</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">zip</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">price</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">listingsDF</span> <span class="k">=</span> <span class="o">...</span> <span class="c1">// DataFrame of Listings</span>

<span class="k">val</span> <span class="nv">mostExpensiveDF</span> <span class="k">=</span> <span class="nv">listingsDF</span><span class="o">.</span><span class="py">groupBy</span><span class="o">(</span><span class="n">$</span><span class="s">"zip"</span><span class="o">).</span><span class="py">max</span><span class="o">(</span><span class="s">"price"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">leastExpensiveDF</span> <span class="k">=</span> <span class="nv">listingsDF</span><span class="o">.</span><span class="py">groupBy</span><span class="o">(</span><span class="n">$</span><span class="s">"zip"</span><span class="o">).</span><span class="py">min</span><span class="o">(</span><span class="s">"price"</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Another example: we want to find the person with the most posts in each subforum of a forum:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nn">org.apache.spark.sql.functions._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Post</span><span class="o">(</span><span class="n">authorID</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">subforum</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">likes</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">date</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">postsDF</span> <span class="k">=</span> <span class="o">...</span> <span class="c1">// DataFrame of Posts</span>

<span class="k">val</span> <span class="nv">rankedDF</span> <span class="k">=</span> <span class="nv">postsDF</span><span class="o">.</span><span class="py">groupBy</span><span class="o">(</span><span class="n">$</span><span class="s">"authorID"</span><span class="o">,</span> <span class="n">$</span><span class="s">"subforum"</span><span class="o">)</span>
                      <span class="o">.</span><span class="py">agg</span><span class="o">(</span><span class="nf">count</span><span class="o">(</span><span class="n">$</span><span class="s">"authorId"</span><span class="o">))</span> <span class="c1">// new DF with cols for authorId, subforum, count(authorId)</span>
                      <span class="o">.</span><span class="py">orderBy</span><span class="o">(</span><span class="n">$</span><span class="s">"subforum"</span><span class="o">,</span> <span class="n">$</span><span class="s">"count(authorId)"</span><span class="o">.</span><span class="py">desc</span><span class="o">)</span> <span class="c1">// desc for "descending order"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Some of the transformations return specific kinds of <code class="highlighter-rouge">DataFrames</code> on which we can only execute certain actions. <a href="https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.RelationalGroupedDataset">Here‚Äôs a list of methods</a> that can be called on a <code class="highlighter-rouge">RelationalGroupedDataset</code> (after a <code class="highlighter-rouge">groupBy</code>), and <a href="https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.functions$">here‚Äôs a list of methods</a> that can be called within <code class="highlighter-rouge">agg</code>.</p>

<h5 id="cleaning-data-with-dataframes">Cleaning Data with DataFrames</h5>
<p>Sometimes, data sets have <code class="highlighter-rouge">null</code> or <code class="highlighter-rouge">NaN</code> values. In these cases it‚Äôs often desirable to:</p>

<ul>
  <li>Drop rows with unwanted values:
    <ul>
      <li><code class="highlighter-rouge">drop()</code> drops rows that contain <code class="highlighter-rouge">null</code> or <code class="highlighter-rouge">NaN</code> values in <strong>any</strong> column and returns a new DataFrame</li>
      <li><code class="highlighter-rouge">drop("all")</code> drops rows that contain <code class="highlighter-rouge">null</code> or <code class="highlighter-rouge">NaN</code> values in <strong>all</strong> columns and returns a new DataFrame</li>
      <li><code class="highlighter-rouge">drop(Array("id", "name"))</code> drops rows that contain <code class="highlighter-rouge">null</code> or <code class="highlighter-rouge">NaN</code> values in the <strong>specified</strong> columns and returns a new DataFrame</li>
    </ul>
  </li>
  <li>Replace certains values with a constant:
    <ul>
      <li><code class="highlighter-rouge">fill(0)</code> replaces all occurrences of <code class="highlighter-rouge">null</code> or <code class="highlighter-rouge">NaN</code> in <strong>numeric columns</strong> with the <strong>specified value</strong> and returns a new DataFrame</li>
      <li><code class="highlighter-rouge">fill(Map("minBalance" -&gt; 0))</code> replaces all occurrences of <code class="highlighter-rouge">null</code> or <code class="highlighter-rouge">NaN</code> in <strong>specified column</strong> with the <strong>specified value</strong> and returns a new DataFrame</li>
      <li><code class="highlighter-rouge">replace(Array("id"), Map(1234 -&gt; 8923))</code> replaces the <strong>specified value</strong> (<code class="highlighter-rouge">1234</code>) in the <strong>specified column</strong> (<code class="highlighter-rouge">id</code>) with the  <strong>specified replacement value</strong> (<code class="highlighter-rouge">8923</code>) and returns a new DataFrame</li>
    </ul>
  </li>
</ul>

<h5 id="common-actions-on-dataframes">Common actions on DataFrames</h5>
<ul>
  <li><code class="highlighter-rouge">collect(): Array[Row]</code>: returns an array containing all rows in the DataFrame</li>
  <li><code class="highlighter-rouge">count(): Long</code>: returns the number of rows in the DataFrame</li>
  <li><code class="highlighter-rouge">first(): Row</code> or <code class="highlighter-rouge">head(): Row</code>: returns the first row in the DataFrame</li>
  <li><code class="highlighter-rouge">show(): Unit</code>: displays the top 20 rows in tabular form</li>
  <li><code class="highlighter-rouge">take(n: Int): Array[Row]</code>: returns the first <code class="highlighter-rouge">n</code> rows</li>
</ul>

<h5 id="joins-on-dataframes">Joins on DataFrames</h5>
<p>Joins on DataFrames are similar to those on Pair RDDs, but since DataFrames aren‚Äôt key/value pairs, we have to specify which columns to join on.</p>

<p>There are several types of joins available: <code class="highlighter-rouge">inner</code>, <code class="highlighter-rouge">outer</code>, <code class="highlighter-rouge">left_outer</code>, <code class="highlighter-rouge">right_outer</code>, <code class="highlighter-rouge">leftsemi</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">// Both df1 and df2 have a column called id</span>
<span class="c1">// Inner join is performed like this:</span>
<span class="nv">df1</span><span class="o">.</span><span class="py">join</span><span class="o">(</span><span class="n">df2</span><span class="o">,</span> <span class="n">$</span><span class="s">"df1.id"</span> <span class="o">===</span> <span class="n">$</span><span class="s">"df2.id"</span><span class="o">)</span>

<span class="c1">// Other types of joins are done like this:</span>
<span class="nv">df1</span><span class="o">.</span><span class="py">join</span><span class="o">(</span><span class="n">df2</span><span class="o">,</span> <span class="n">$</span><span class="s">"df1.id"</span> <span class="o">===</span> <span class="n">$</span><span class="s">"df2.id"</span><span class="o">,</span> <span class="s">"right_outer"</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="optimizations-on-dataframes">Optimizations on DataFrames</h5>
<p>The great advantage of working with DataFrames is that queries are automatically optimized. Revisiting our award example, we don‚Äôt have to put too much thought into performance, and we can just do what seems most natural and enjoy optimized performance:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nv">demographicsDF</span><span class="o">.</span><span class="py">join</span><span class="o">(</span><span class="n">financesDF</span><span class="o">,</span> <span class="nf">demographicsDF</span><span class="o">(</span><span class="s">"ID"</span><span class="o">)</span> <span class="o">===</span> <span class="nf">financesDF</span><span class="o">(</span><span class="s">"ID"</span><span class="o">),</span> <span class="s">"inner"</span><span class="o">)</span>
              <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">$</span><span class="s">"HasDebt"</span> <span class="o">&amp;&amp;</span> <span class="n">$</span><span class="s">"HasFinancialDependents"</span><span class="o">)</span>
              <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">$</span><span class="s">"CountryLive"</span> <span class="o">===</span> <span class="s">"Switzerland"</span><span class="o">)</span>
              <span class="o">.</span><span class="py">count</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In practice, compared to the previous Spark RDD version, the DataFrame version is even faster! How is this possible?</p>

<p>Recall that Spark comes with Catalyst, which is Spark SQL‚Äôs query optimizer, which compiles Spark SQL programs down to an RDD. It can:</p>

<ul>
  <li><strong>Reorder operations</strong>: The laziness and structure inherent to Catalyst gives it the ability to analyze and rearrange the DAG of the computation before it‚Äôs executed</li>
  <li><strong>Reduce the amount of data we must read</strong>: Catalyst can skip reading in, serializing and sending around parts of the data set that aren‚Äôt needed for our computation</li>
  <li><strong>Pruning unneeded partitioning</strong>: it analyzes DataFrames and filter operations to figure out and skip partitions that are unneeded in our computation</li>
  <li>And more!</li>
</ul>

<p>Tungsten in Spark SQL‚Äôs off-heap data encorder. It takes schema information and tightly packs serialized data into memory. This means more data can fit in memory, and faster serialization/deserialization can occur. Data is stored off-heap, where it‚Äôs free from garbage collection overhead.</p>

<h5 id="limitations">Limitations</h5>
<ul>
  <li><strong>Untyped</strong>: errors aren‚Äôt caught at compile time, they‚Äôre caught at execution time</li>
  <li><strong>Limited data types</strong>: data that can‚Äôt be expressed by <code class="highlighter-rouge">case class</code> or <code class="highlighter-rouge">Product</code> or standard Spark SQL data types is hard to encode with Tungsten; it doesn‚Äôt always play well with old codebases.</li>
  <li><strong>Requires semi-structured or structured data</strong>: some data doesn‚Äôt fit nicely in DataFrames (images, logs, etc).</li>
</ul>

<h4 id="datasets">Datasets</h4>
<p>Datasets provide an alternative framework to DataFrames. As an example, let‚Äôs say we we want the average price of home listings:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Listing</span><span class="o">(</span><span class="n">street</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">zip</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">price</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">listingsDF</span> <span class="k">=</span> <span class="o">...</span> <span class="c1">// DataFrame of Listings</span>

<span class="k">import</span> <span class="nn">org.apache.spark.sql.functions._</span>
<span class="k">val</span> <span class="nv">averagePricesDF</span> <span class="k">=</span> <span class="nv">listingsDF</span><span class="o">.</span><span class="py">groupBy</span><span class="o">(</span><span class="n">$</span><span class="s">"zip"</span><span class="o">).</span><span class="py">avg</span><span class="o">(</span><span class="s">"price"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">averagePrices</span> <span class="k">=</span> <span class="nv">averagePricesDF</span><span class="o">.</span><span class="py">collect</span><span class="o">()</span>
<span class="c1">// averagePrices: Array[org.apache.spark.sql.Row]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We wanted an <code class="highlighter-rouge">Array[Double]</code>, what is this <code class="highlighter-rouge">Row</code> thing? We have to cast things because <code class="highlighter-rouge">Row</code>s don‚Äôt have type information associated with them.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">averagePricesAgain</span> <span class="k">=</span> <span class="n">averagePrices</span> <span class="n">map</span> <span class="o">{</span>
    <span class="n">row</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nf">row</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="nf">row</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This gives us an exception. Well, what about looking at the <code class="highlighter-rouge">Row</code> API docs? That reveals that we can do this:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nv">averagePrices</span><span class="o">.</span><span class="py">head</span><span class="o">.</span><span class="py">schema</span><span class="o">.</span><span class="py">printTreeString</span><span class="o">()</span>
<span class="c1">// root</span>
<span class="c1">//  |-- zip: integer (nullable = true)</span>
<span class="c1">//  |-- avg(price): double (nullable = true)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Ah, so we had a mistake in our types! But rather than doing it that way, wouldn‚Äôt it be nice to have both Spark SQL and type safety? Enter Datasets: they combine type safety with Spark SQL. DataFrames are in fact Datasets themselves:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">type</span> <span class="kt">DataFrame</span> <span class="o">=</span> <span class="nc">Dataset</span><span class="o">[</span><span class="kt">Row</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">Dataset</code> API unifies the <code class="highlighter-rouge">DataFrame</code> and <code class="highlighter-rouge">RDD</code> APIs. We can mix and match relational and functional operators! Like <code class="highlighter-rouge">DataFrame</code>s, they require structured/semi-structured data. Schemas and Encoder are a core part of Datasets.</p>

<p>Recall the <code class="highlighter-rouge">Column</code> type from <code class="highlighter-rouge">DataFrame</code>s. On <code class="highlighter-rouge">Dataset</code>s, <em>typed</em> operations tend to act on <code class="highlighter-rouge">TypedColumn</code> instead. To create a <code class="highlighter-rouge">TypedColumn</code>, all you have to do is call <code class="highlighter-rouge">as[...]</code> on your untyped <code class="highlighter-rouge">Column</code>.</p>

<h5 id="creating-datasets">Creating Datasets</h5>
<p>First, see <a href="#getting-started">Getting Started</a> for general setup. Once that is done, there are a number of ways of creating a Dataset:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">// 1. From a DataFrame:</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>
<span class="k">val</span> <span class="nv">myDS</span> <span class="k">=</span> <span class="nv">myDF</span><span class="o">.</span><span class="py">toDS</span>

<span class="c1">// 2. Reading from JSON, using read on the SparkSession object and</span>
<span class="c1">// then converting to a Dataset:</span>
<span class="k">val</span> <span class="nv">myDS</span> <span class="k">=</span> <span class="nv">spark</span><span class="o">.</span><span class="py">read</span><span class="o">.</span><span class="py">json</span><span class="o">(</span><span class="s">"people.json"</span><span class="o">).</span><span class="py">as</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span>

<span class="c1">// 3. From an RDD:</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>
<span class="k">val</span> <span class="nv">myDS</span> <span class="k">=</span> <span class="nv">myRDD</span><span class="o">.</span><span class="py">toDS</span>

<span class="c1">// 4. From common Scala types:</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>
<span class="k">val</span> <span class="nv">myDS</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">).</span><span class="py">toDS</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="transformations-on-datasets">Transformations on Datasets</h5>
<p>The <code class="highlighter-rouge">Dataset</code> API includes:</p>

<ul>
  <li><strong>Typed transformations</strong> typed variants of many <code class="highlighter-rouge">DataFrame</code> transformations and additional transformations such as RDD-like higher-order function <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code>, etc.
    <ul>
      <li><code class="highlighter-rouge">map[U](f: T =&gt; U): Dataset[U]</code></li>
      <li><code class="highlighter-rouge">flatMap[U](f: T =&gt; TraversableOnce[U]): Dataset[U]</code></li>
      <li><code class="highlighter-rouge">filter(pred: T =&gt; Boolean): Dataset[T]</code></li>
      <li><code class="highlighter-rouge">distinct(): Dataset[T]</code></li>
      <li><code class="highlighter-rouge">groupByKey[K](f: T =&gt; K): KeyValueGroupedDataset[K, T]</code>: Like on <code class="highlighter-rouge">DataFrame</code>s, <code class="highlighter-rouge">Dataset</code>s have a special set of aggregation operations meant to be used after a call to <code class="highlighter-rouge">groupByKey</code>, hence the different return type. Operations include:
        <ul>
          <li><code class="highlighter-rouge">reduceGroups(f: (V, V) =&gt; V): Dataset[(K, V)]</code>: reduce on the elements of each group. The function must be commutative and associative.</li>
          <li><code class="highlighter-rouge">agg[U](col: TypedColumn[V, U]): Dataset[(K, U)]</code>: aggregates using the given Spark SQL function, for instance <code class="highlighter-rouge">someDS.agg(avg($"column").as[Double])</code>. We use the <code class="highlighter-rouge">.as</code> method to make it a <code class="highlighter-rouge">TypedColumn</code>, and then everything type checks.</li>
          <li><code class="highlighter-rouge">mapGroups[U](f: (K, Iterator[V]) =&gt; U): DataSet[U]</code>: maps on the collection of values for each group. A big disclaimer on it though: it does not suport partial aggregation, and as a result requires shuffling all the data in the Dataset. If an application intends to perform an aggregation over each key, it is best to use the <code class="highlighter-rouge">reduce</code> function or an Aggregator.</li>
          <li><code class="highlighter-rouge">flatMapGroups[U](f: (K, Iterator[V]) =&gt; TraversableOnce[U]): Dataset[U]</code></li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">coalesce(numPartitions: Int): Dataset[T]</code>: apply a function to each element in the Dataset and return a <code class="highlighter-rouge">Dataset</code> of the contents of the iterators returned</li>
      <li><code class="highlighter-rouge">repartition(numPartitions: Int): Dataset[T]</code></li>
    </ul>
  </li>
  <li><strong>Untyped transformations</strong> the transformations we learned on <code class="highlighter-rouge">DataFrame</code>s</li>
</ul>

<h5 id="aggregators">Aggregators</h5>
<p>A class that helps you generically aggregate data. Kind of like the <code class="highlighter-rouge">aggregate</code> method on <code class="highlighter-rouge">RDD</code>s</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">// Location:</span>
<span class="k">import</span> <span class="nn">org.apache.spark.sql.expressions.Aggregator</span>

<span class="c1">// Definition:</span>
<span class="k">class</span> <span class="nc">Aggregator</span><span class="o">[</span><span class="kt">-IN</span>, <span class="kt">BUF</span>, <span class="kt">OUT</span><span class="o">]</span>

<span class="c1">// Implementation idea:</span>
<span class="k">val</span> <span class="nv">myAgg</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Aggregator</span><span class="o">[</span><span class="kt">IN</span>, <span class="kt">BUF</span>, <span class="kt">OUT</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">BUF</span> <span class="o">=</span> <span class="o">...</span>                    <span class="c1">// Initial value</span>
    <span class="k">def</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BUF</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">IN</span><span class="o">)</span><span class="k">:</span> <span class="kt">BUF</span> <span class="o">=</span> <span class="o">...</span>   <span class="c1">// Add an element to the running total</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">b1</span><span class="k">:</span> <span class="kt">BUF</span><span class="o">,</span> <span class="n">b2</span><span class="k">:</span> <span class="kt">BUF</span><span class="o">)</span><span class="k">:</span> <span class="kt">BUF</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// Merge intermediate values</span>
    <span class="k">def</span> <span class="nf">finish</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BUF</span><span class="o">)</span><span class="k">:</span> <span class="kt">OUT</span> <span class="o">=</span> <span class="o">...</span>          <span class="c1">// Return final result</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">bufferEncoder</span><span class="k">:</span> <span class="kt">Encoder</span><span class="o">[</span><span class="kt">BUF</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span> <span class="c1">// disregard for now</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">outputEncoder</span><span class="k">:</span> <span class="kt">Encoder</span><span class="o">[</span><span class="kt">OUT</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span> <span class="c1">// disregard for now</span>
<span class="o">}.</span><span class="py">toColumn</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li><code class="highlighter-rouge">IN</code> is the input type to the aggreagtor. When using an aggregator after <code class="highlighter-rouge">groupByKey</code>, this is the type that represents the value in the key/value pair</li>
  <li><code class="highlighter-rouge">BUF</code> is the intermediate type during aggregation</li>
  <li><code class="highlighter-rouge">OUT</code> is the type of the output of the aggregation</li>
</ul>

<p>To use it, we have to define the types and methods:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">keyValues</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="mi">3</span><span class="o">,</span> <span class="s">"Me"</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"Thi"</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"Se"</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"ssa"</span><span class="o">),</span> <span class="o">...)</span>
<span class="k">val</span> <span class="nv">keyValuesDS</span> <span class="k">=</span> <span class="nv">keyValues</span><span class="o">.</span><span class="py">toDS</span>

<span class="k">val</span> <span class="nv">strConcat</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Aggregator</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)</span>, <span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">def</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">String</span><span class="o">))</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="nv">a</span><span class="o">.</span><span class="py">_2</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">b1</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">b2</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">b2</span>
    <span class="k">def</span> <span class="nf">finish</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">r</span>
<span class="o">}.</span><span class="py">toColumn</span>

<span class="nv">keyValuesDS</span><span class="o">.</span><span class="py">groupByKey</span><span class="o">(</span><span class="n">pair</span> <span class="k">=&gt;</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_1</span><span class="o">)</span>
           <span class="o">.</span><span class="py">agg</span><span class="o">(</span><span class="nv">strConcat</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>But this gives us an error telling us to define <code class="highlighter-rouge">bufferEncoder</code> and <code class="highlighter-rouge">outputEncoder</code>. To understand this, we first need to understand what an <code class="highlighter-rouge">Encoder</code> is. They are what convert your data between JVM objects and Spark SQL‚Äôs specialized internal tabular representation. They‚Äôre required by all <code class="highlighter-rouge">Dataset</code>s! There are two ways to introduce encoders:</p>

<ul>
  <li><strong>Automatically</strong> (generally the case) via implicits from a <code class="highlighter-rouge">SparkSession</code> (<code class="highlighter-rouge">import spark.implicits._</code>)</li>
  <li><strong>Explicitly</strong> via <code class="highlighter-rouge">org.apache.spark.sql.Encoder</code> which contains a large selection of methods for creating <code class="highlighter-rouge">Encoders</code> from Scala primitive types and <code class="highlighter-rouge">Product</code>s. Some example of <code class="highlighter-rouge">Encoder</code> creation methods in <code class="highlighter-rouge">Encoders</code>:
    <ul>
      <li><code class="highlighter-rouge">INT</code>, <code class="highlighter-rouge">LONG</code>, <code class="highlighter-rouge">STRING</code> for nullable primitives</li>
      <li><code class="highlighter-rouge">scalaInt</code>, <code class="highlighter-rouge">scalaLong</code>, <code class="highlighter-rouge">scalaByte</code> for Scala primitives</li>
      <li><code class="highlighter-rouge">product</code>, <code class="highlighter-rouge">tuple</code> for Scala‚Äôs <code class="highlighter-rouge">Product</code> and <code class="highlighter-rouge">tuple</code> types</li>
    </ul>
  </li>
</ul>

<p>Example of explicitily creating <code class="highlighter-rouge">Encoders</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="nv">Encoders</span><span class="o">.</span><span class="py">scalaInt</span> <span class="c1">// Encoder[Int]</span>
<span class="nv">Encoders</span><span class="o">.</span><span class="py">STRING</span> <span class="c1">// Encoder[String]</span>
<span class="nv">Encoder</span><span class="o">.</span><span class="py">product</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="c1">// Encoder[Person], where "Person extends Product" is a case class</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>So we actually also need to define the encoders for our example. This is pretty straightforward once we‚Äôve replaced the <code class="highlighter-rouge">IN</code>, <code class="highlighter-rouge">BUF</code> and <code class="highlighter-rouge">OUT</code> types:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">strConcat</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Aggregator</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)</span>, <span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">def</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">String</span><span class="o">))</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="nv">a</span><span class="o">.</span><span class="py">_2</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">b1</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">b2</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">b2</span>
    <span class="k">def</span> <span class="nf">finish</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">bufferEncoder</span><span class="k">:</span> <span class="kt">Encoder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Encoders</span><span class="o">.</span><span class="py">STRING</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">outputEncoder</span><span class="k">:</span> <span class="kt">Encoder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Encoders</span><span class="o">.</span><span class="py">STRING</span>
<span class="o">}.</span><span class="py">toColumn</span>

<span class="nv">keyValuesDS</span><span class="o">.</span><span class="py">groupByKey</span><span class="o">(</span><span class="n">pair</span> <span class="k">=&gt;</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_1</span><span class="o">)</span>
           <span class="o">.</span><span class="py">agg</span><span class="o">(</span><span class="nv">strConcat</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="py">show</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="dataset-actions">Dataset Actions</h5>
<p>All the actions are exactly the same as we‚Äôve previously seen <a href="#transformations-and-actions">on RDDs</a> and <a href="#common-actions-on-dataframes">on DataFrames</a>.</p>

<ul>
  <li><code class="highlighter-rouge">collect(): Array[T]</code></li>
  <li><code class="highlighter-rouge">count(): Long</code></li>
  <li><code class="highlighter-rouge">first(): T</code> or <code class="highlighter-rouge">head(): T</code></li>
  <li><code class="highlighter-rouge">foreach(f: T =&gt; Unit): Unit</code></li>
  <li><code class="highlighter-rouge">reduce(f: (T, T) =&gt; T): T</code></li>
  <li><code class="highlighter-rouge">show(): Unit</code></li>
  <li><code class="highlighter-rouge">take(n: Int): Array[T]</code></li>
</ul>

<h5 id="limitations-of-datasets">Limitations of Datasets</h5>
<p>Catalyst can‚Äôt optimize all operations. Lambda functions can‚Äôt be optimized as they are opaque to the optimizer; equivalent relational calls can however be optimized.</p>

<ul>
  <li>When using Datasets with higher-order functions like <code class="highlighter-rouge">map</code>, you miss out on many Catalyst optimizations</li>
  <li>When using Datasets with relational operations like <code class="highlighter-rouge">select</code>, you get all of Catalysts‚Äôs optimizations</li>
  <li>Thoough not all operations can be optimized by Catalyst, Tungsten is still running under the hood to serialize data in a highly optimized way</li>
</ul>

<p>If the data can‚Äôt be expressed by <code class="highlighter-rouge">case class</code>es or <code class="highlighter-rouge">Product</code>s and standard Spark SQL data types, it may be difficult to ensure that a Tungsten encoder exists (this is often a problem for legacy code using regular Scala <code class="highlighter-rouge">class</code>).</p>

<p>If your unstructured data cannot be reformulated to adhere to some kind of schema it would be better to use RDDs.</p>

<h4 id="datasets-vs-dataframes-vs-rdds">Datasets vs DataFrames vs RDDs</h4>
<p>To finish this course on Spark, a bit of discussion on when to use the different technologies:</p>

<p>Use Datasets when:</p>

<ul>
  <li>you have structured or semi-structured data (JSON, XML, CSV, ‚Ä¶)</li>
  <li>you want type safety</li>
  <li>you need to work with functional APIs</li>
  <li>you need good performance, but it doesn‚Äôt have to be the best</li>
</ul>

<p>Use DataFrames when:</p>

<ul>
  <li>you have structured or semi-structured data</li>
  <li>you want the best possible performance, automatically optimized for you</li>
</ul>

<p>Use RDDs when:</p>

<ul>
  <li>you have unstructured data</li>
  <li>you need to fine-tune and manage low-level details of RDD computations</li>
  <li>you have complex data types that cannot be serialized with <code class="highlighter-rouge">Encoder</code>s</li>
</ul>
:ET