I"Öi<ul>
  <li><a href="http://dcl.epfl.ch/site/education/da">Course website</a></li>
  <li>The course follows the book <a href="https://www.springer.com/gp/book/9783642152597"><em>Introduction to Reliable (and Secure) Distributed Programming</em></a> (available from the library or through SpringerLink)</li>
  <li>Final exam is 60%</li>
  <li>Projects in teams of 2-3 are 40%. The project is the implementation of various broadcast algorithms</li>
  <li>No midterm</li>
</ul>

<!-- More -->

<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a>    <ul>
      <li><a href="#links" id="markdown-toc-links">Links</a>        <ul>
          <li><a href="#fair-loss-link-fll" id="markdown-toc-fair-loss-link-fll">Fair loss link (<abbr title="Fair Loss Link">FLL</abbr>)</a></li>
          <li><a href="#stubborn-link-sl" id="markdown-toc-stubborn-link-sl">Stubborn link (<abbr title="Stubborn Link">SL</abbr>)</a></li>
          <li><a href="#perfect-link-pl" id="markdown-toc-perfect-link-pl">Perfect link (<abbr title="Perfect Link">PL</abbr>)</a></li>
        </ul>
      </li>
      <li><a href="#impossibility-of-consensus" id="markdown-toc-impossibility-of-consensus">Impossibility of consensus</a>        <ul>
          <li><a href="#solvable-atomicity-problem" id="markdown-toc-solvable-atomicity-problem">Solvable atomicity problem</a></li>
          <li><a href="#unsolvable-atomicity-problem" id="markdown-toc-unsolvable-atomicity-problem">Unsolvable atomicity problem</a></li>
        </ul>
      </li>
      <li><a href="#timing-assumptions" id="markdown-toc-timing-assumptions">Timing assumptions</a></li>
      <li><a href="#failure-detection" id="markdown-toc-failure-detection">Failure detection</a></li>
    </ul>
  </li>
  <li><a href="#reliable-broadcast" id="markdown-toc-reliable-broadcast">Reliable broadcast</a>    <ul>
      <li><a href="#best-effort-broadcast-beb" id="markdown-toc-best-effort-broadcast-beb">Best-effort broadcast (<abbr title="Best Effort Broadcast">BEB</abbr>)</a>        <ul>
          <li><a href="#properties" id="markdown-toc-properties">Properties</a></li>
          <li><a href="#algorithm" id="markdown-toc-algorithm">Algorithm</a></li>
          <li><a href="#correctness" id="markdown-toc-correctness">Correctness</a></li>
        </ul>
      </li>
      <li><a href="#reliable-broadcast-rb" id="markdown-toc-reliable-broadcast-rb">Reliable broadcast (<abbr title="Reliable Broadcast">RB</abbr>)</a>        <ul>
          <li><a href="#properties-1" id="markdown-toc-properties-1">Properties</a></li>
          <li><a href="#algorithm-1" id="markdown-toc-algorithm-1">Algorithm</a></li>
          <li><a href="#correctness-1" id="markdown-toc-correctness-1">Correctness</a></li>
        </ul>
      </li>
      <li><a href="#uniform-reliable-broadcast-urb" id="markdown-toc-uniform-reliable-broadcast-urb">Uniform reliable broadcast (<abbr title="Uniform Reliable Broadcast">URB</abbr>)</a>        <ul>
          <li><a href="#properties-2" id="markdown-toc-properties-2">Properties</a></li>
          <li><a href="#algorithm-2" id="markdown-toc-algorithm-2">Algorithm</a></li>
          <li><a href="#correctness-2" id="markdown-toc-correctness-2">Correctness</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#causal-order-broadcast-cb" id="markdown-toc-causal-order-broadcast-cb">Causal order broadcast (<abbr title="Causal Broadcast">CB</abbr>)</a>    <ul>
      <li><a href="#causal-order" id="markdown-toc-causal-order">Causal order</a></li>
      <li><a href="#properties-3" id="markdown-toc-properties-3">Properties</a></li>
      <li><a href="#no-waiting-algorithm" id="markdown-toc-no-waiting-algorithm">No-waiting Algorithm</a></li>
      <li><a href="#garbage-collection" id="markdown-toc-garbage-collection">Garbage collection</a></li>
      <li><a href="#waiting-algorithm" id="markdown-toc-waiting-algorithm">Waiting Algorithm</a></li>
    </ul>
  </li>
  <li><a href="#total-order-broadcast-tob" id="markdown-toc-total-order-broadcast-tob">Total order broadcast (<abbr title="Total Order Broadcast">TOB</abbr>)</a>    <ul>
      <li><a href="#properties-4" id="markdown-toc-properties-4">Properties</a></li>
      <li><a href="#consensus-based-algorithm" id="markdown-toc-consensus-based-algorithm">Consensus-based Algorithm</a></li>
    </ul>
  </li>
  <li><a href="#consensus-cons" id="markdown-toc-consensus-cons">Consensus (CONS)</a>    <ul>
      <li><a href="#properties-5" id="markdown-toc-properties-5">Properties</a></li>
      <li><a href="#algorithm-1-fail-stop-consensus" id="markdown-toc-algorithm-1-fail-stop-consensus">Algorithm 1: Fail-Stop Consensus</a></li>
      <li><a href="#algorithm-2-fail-stop-uniform-consensus" id="markdown-toc-algorithm-2-fail-stop-uniform-consensus">Algorithm 2: Fail-Stop Uniform Consensus</a></li>
      <li><a href="#algorithm-3-uniform-consensus-with-eventually-perfect-failure-detector" id="markdown-toc-algorithm-3-uniform-consensus-with-eventually-perfect-failure-detector">Algorithm 3: Uniform Consensus with Eventually Perfect Failure Detector</a></li>
    </ul>
  </li>
  <li><a href="#atomic-commit" id="markdown-toc-atomic-commit">Atomic commit</a>    <ul>
      <li><a href="#non-blocking-atomic-commit-nbac" id="markdown-toc-non-blocking-atomic-commit-nbac">Non-Blocking Atomic Commit (<abbr title="Non-Blocking Atomic Commit">NBAC</abbr>)</a></li>
      <li><a href="#2-phase-commit-2pc" id="markdown-toc-2-phase-commit-2pc">2-Phase Commit (<abbr title="Two-Phase Commit">2PC</abbr>)</a></li>
    </ul>
  </li>
  <li><a href="#terminating-reliable-broadcast-trb" id="markdown-toc-terminating-reliable-broadcast-trb">Terminating reliable broadcast (<abbr title="Terminating Reliable Broadcast">TRB</abbr>)</a>    <ul>
      <li><a href="#properties-6" id="markdown-toc-properties-6">Properties</a></li>
      <li><a href="#algorithm-3" id="markdown-toc-algorithm-3">Algorithm</a></li>
      <li><a href="#failure-detector" id="markdown-toc-failure-detector">Failure detector</a></li>
    </ul>
  </li>
  <li><a href="#group-membership-gm" id="markdown-toc-group-membership-gm">Group membership (<abbr title="Group Membership">GM</abbr>)</a>    <ul>
      <li><a href="#properties-7" id="markdown-toc-properties-7">Properties</a></li>
      <li><a href="#algorithm-4" id="markdown-toc-algorithm-4">Algorithm</a></li>
    </ul>
  </li>
  <li><a href="#view-synchronous-broadcast-vs" id="markdown-toc-view-synchronous-broadcast-vs">View-Synchronous broadcast (<abbr title="View-Synchronous broadcast">VS</abbr>)</a>    <ul>
      <li><a href="#properties-8" id="markdown-toc-properties-8">Properties</a></li>
      <li><a href="#algorithm-1-trb-based-vs" id="markdown-toc-algorithm-1-trb-based-vs">Algorithm 1: <abbr title="Terminating Reliable Broadcast">TRB</abbr>-based <abbr title="View-Synchronous broadcast">VS</abbr></a></li>
      <li><a href="#algorithm-2-consensus-based-vs" id="markdown-toc-algorithm-2-consensus-based-vs">Algorithm 2: Consensus-based <abbr title="View-Synchronous broadcast">VS</abbr></a></li>
      <li><a href="#algorithm-3-consensus-based-uniform-vs" id="markdown-toc-algorithm-3-consensus-based-uniform-vs">Algorithm 3: Consensus-based Uniform <abbr title="View-Synchronous broadcast">VS</abbr></a></li>
    </ul>
  </li>
  <li><a href="#shared-memory-sm" id="markdown-toc-shared-memory-sm">Shared Memory (<abbr title="Shared Memory">SM</abbr>)</a>    <ul>
      <li><a href="#1-n-regular-register" id="markdown-toc-1-n-regular-register">(1, N) Regular register</a>        <ul>
          <li><a href="#properties-9" id="markdown-toc-properties-9">Properties</a></li>
          <li><a href="#algorithm-1-fail-stop-with-perfect-failure-detection" id="markdown-toc-algorithm-1-fail-stop-with-perfect-failure-detection">Algorithm 1: fail-stop with perfect failure detection</a></li>
          <li><a href="#algorithm-2-fail-silent-without-failure-detectors" id="markdown-toc-algorithm-2-fail-silent-without-failure-detectors">Algorithm 2: Fail-silent without failure detectors</a></li>
        </ul>
      </li>
      <li><a href="#1-n-atomic-register" id="markdown-toc-1-n-atomic-register">(1, N) Atomic register</a>        <ul>
          <li><a href="#properties-10" id="markdown-toc-properties-10">Properties</a></li>
          <li><a href="#from-1-n-regular-to-1-1-atomic" id="markdown-toc-from-1-n-regular-to-1-1-atomic">From (1, N) regular to (1, 1) atomic</a></li>
          <li><a href="#algorithm-1-from-1-1-atomic-to-1-n-atomic" id="markdown-toc-algorithm-1-from-1-1-atomic-to-1-n-atomic">Algorithm 1: From (1, 1) atomic to (1, N) atomic</a></li>
          <li><a href="#algorithm-2-read-impose-write-all-1-n-atomic" id="markdown-toc-algorithm-2-read-impose-write-all-1-n-atomic">Algorithm 2: Read-impose Write-all (1, N) atomic</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="introduction">Introduction</h2>
<p>In terms of abstraction layers, distributed algorithms are sandwiched between the application layer (processes) the network layer (channels). We have a few commonly used abstractions in this course:</p>

<ul>
  <li><strong>Processes</strong> abstract computers</li>
  <li><strong>Channels</strong> (or communication <em>links</em>) abstract networks</li>
  <li><strong>Failure detectors</strong> abstract time</li>
</ul>

<p>We consider that a distributed system is composed of $N$ processes making up a static set $\Pi$ (i.e. it doesn‚Äôt change over time). These processes communicate by sending messages over the network channel. The distributed algorithm consists of a set of distributed automata, one for each process. All processes implement the same automaton.</p>

<p>When defining a problem, there are two important properties that we care about:</p>

<ul>
  <li><strong>Safety</strong> states that nothing bad should happen</li>
  <li><strong>Liveness</strong> states that something good should happen eventually</li>
</ul>

<p>Safety is trivially implemented by doing nothing, so we also need liveness to make sure that the correct things actually happen.</p>

<h3 id="links">Links</h3>
<p>Two nodes can communicate through a link by passing messages. However, this message passing can be faulty: it can drop messages or repeat them. How can we ensure correct and reliable message passing under such conditions?</p>

<p>A link has two basic types of events:</p>

<ul>
  <li><strong>Send</strong>: we place a message on the link</li>
  <li><strong>Deliver</strong>: the link gives us a message</li>
</ul>

<h4 id="fair-loss-link-fll">Fair loss link (<abbr title="Fair Loss Link">FLL</abbr>)</h4>
<p>A fair loss link is a link that may lose or repeat some packets. This is the weakest type of link we can assume. In practice, it corresponds to UDP.</p>

<p>Deliver can be thought of as a reception event on the receiver end. The terminology used here (‚Äúdeliver‚Äù) implies that the link delivers to the client, but this can equally be thought of as the client receiving from the link.</p>

<p>For a link to be considered a fair-loss link, we must respect the following three properties:</p>

<ul>
  <li><strong>FLL1. Fair loss</strong>: If a correct process $p$ infinitely often sends a message $m$ to a correct process $q$, then $q$ delivers $m$ an infinite number of times.</li>
  <li><strong>FLL2. Finite duplication</strong>: If a correct process $p$ sends a message $m$ a finite number of times to process $q$, then $m$ cannot be delivered an infinite number of times by $q$.</li>
  <li><strong>FLL3. No creation</strong>: If some process $q$ delivers a message $m$ with sender $p$, then $m$ was previously sent to $q$ by process $p$.</li>
</ul>

<p>Let‚Äôs try to get some intuition for what these properties mean:</p>

<ul>
  <li>FLL1 does not guarantee that all messages get through, but at least ensures that some messages get through.</li>
  <li>FLL2 means that message can only be repeated by the link a finite number of times.</li>
  <li>FLL3 means that every delivery must be the result of a send; no message must be created out of the blue.</li>
</ul>

<p>There‚Äôs no real algorithm to implement here; we have only placed assumptions on the link itself. Still, let‚Äôs take a look at the interface.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="n">Module</span><span class="p">:</span><span class="err">
</span>    <span class="n">Name</span><span class="p">:</span> <span class="n">FairLossLinks</span> <span class="p">(</span><span class="n">flp2p</span><span class="p">)</span><span class="err">

</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">flp2pSend</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">requests</span> <span class="n">to</span> <span class="n">send</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">process</span> <span class="n">dest</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">flp2pDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">messages</span> <span class="n">m</span> <span class="n">sent</span> <span class="n">by</span> <span class="n">src</span><span class="err">

</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">FLL1</span><span class="p">,</span> <span class="n">FLL2</span><span class="p">,</span> <span class="n">FLL3</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="stubborn-link-sl">Stubborn link (<abbr title="Stubborn Link">SL</abbr>)</h4>
<p>A stubborn link is one that stubbornly delivers messages; that is, it ensures that the message is received. Here, we‚Äôll disregard performance, and just keep sending the message.</p>

<p>The properties that we look for in a stubborn link are:</p>

<ul>
  <li><strong>SL1. Stubborn delivery</strong>: If a correct process $p$ sends a message $m$ once to a correct process $q$, then $q$ delivers $m$ an infinite number of times.</li>
  <li><strong>SL2. No creation</strong>: If some process $q$ delivers a message $m$ with sender $p$, then $m$ was previously sent to $q$ by $p$.</li>
</ul>

<p>A stubborn link can be implemented with a <abbr title="Fair Loss Link">FLL</abbr> as the following algorithm, which we could call ‚Äúretransmit forever‚Äù. We could probably make it more efficient with the use of timeouts, but since we‚Äôre mainly concerned with correctness for now, we‚Äôll just keep it simple.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="s">""" 
    Keep sending the same message
    over and over again on the <abbr title="Fair Loss Link">FLL</abbr> 
    """</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n"><abbr title="Fair Loss Link">FLL</abbr></span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="c1"># When the underlying <abbr title="Fair Loss Link">FLL</abbr> delivers, deliver to the layer above
</span><span class="n"><abbr title="Fair Loss Link">FLL</abbr></span><span class="p">.</span><span class="n">on_delivery</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">deliver</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The above is written in Python, but the syntax we‚Äôll use in this course is as follows:</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span> <span class="err">
</span>    <span class="n">StubbornLinks</span> <span class="p">(</span><span class="n">sp2p</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">FairLossLinks</span> <span class="p">(</span><span class="n">flp2p</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">sp2pSend</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">requests</span> <span class="n">to</span> <span class="n">send</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">dest</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">sp2pDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">message</span> <span class="n">m</span> <span class="n">sent</span> <span class="n">by</span> <span class="n">src</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">SL1</span><span class="p">,</span> <span class="n">SL2</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">sp2pSend</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">while</span> <span class="p">(</span><span class="bp">true</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">flp2p</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">flp2pDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">sp2pDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that this piece of code is meant to sit between two abstraction levels; it is between the channel and the application. As such, it receives sends from the application and forwards them to the link, and receives delivers from the link and forwards them to the application. It must respect the interface of the underlying <abbr title="Fair Loss Link">FLL</abbr>, and as such, only specifies send and receive hooks.</p>

<p>Note that a stubborn link will deliver the same message infinitely many times, according to SL1. Wanting to only deliver once will lead us to perfect links.</p>

<h4 id="perfect-link-pl">Perfect link (<abbr title="Perfect Link">PL</abbr>)</h4>
<p>Here again, we respect the send/deliver interface. The properties are:</p>

<ul>
  <li><strong>PL1. Reliable delivery</strong>: If a correct process $p$ sends a message $m$ to a correct process $q$, then $q$ eventually delivers $m$</li>
  <li><strong>PL2. No duplication</strong>: No message is delivered by a process more than once</li>
  <li><strong>PL3. No creation</strong>: If some process $q$ delivers a message $m$ with sender $p$, then $m$ was previously sent to $q$ by $p$.</li>
</ul>

<p>This is the type of link that we usually use: TCP is a perfect link, although it also has more guarantees (notably on message ordering, which this definition of a perfect link does not have). TCP keeps retransmitting a message stubbornly, until it gets an acknowledgment, which means that it can stop transmitting. Acknowledgments aren‚Äôt actually needed <em>in theory</em>, it would still work without them, but we would also completely flood the network, so acknowledgments are a practical consideration for performance; just note that the theorists don‚Äôt care about them.</p>

<p>Compared to the stubborn link, the perfect link algorithm could be called ‚Äúeliminate duplicates‚Äù. In addition to what the stubborn links do, it keeps track of messages that</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span> <span class="err">
</span>    <span class="n">PerfectLinks</span> <span class="p">(</span><span class="n">pp2p</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">StubbornLinks</span> <span class="p">(</span><span class="n">sp2p</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pSend</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">requests</span> <span class="n">to</span> <span class="n">send</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">process</span> <span class="n">q</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">message</span> <span class="n">m</span> <span class="n">sent</span> <span class="n">by</span> <span class="n">src</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">PL1</span><span class="p">,</span> <span class="n">PL2</span><span class="p">,</span> <span class="n">PL3</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2p</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pSend</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">sp2pSend</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">sp2pDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">:</span><span class="err">
</span>        <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Throughout the course, we‚Äôll use perfect links as the underlying link (unless otherwise specified).</p>

<h3 id="impossibility-of-consensus">Impossibility of consensus</h3>
<p>Suppose we‚Äôd like to compute prime numbers on a distributed system. Let <em>P</em> be the producer of prime numbers. Whenever it finds one, it notifies two servers, <em>S1</em> and <em>S2</em> about it. A client <em>C</em> may request the full list of known prime numbers from either server.</p>

<p>As in any distributed system, we want the servers to behave as a single (abstract) machine.</p>

<h4 id="solvable-atomicity-problem">Solvable atomicity problem</h4>
<p><em>P</em> finds 1013 as a new prime number, and sends it to <em>S1</em>, which receives it immediately, and <em>S2</em>, which receives it after a long delay. In the meantime, before both servers have received the update, we have an atomicity problem: one server has a different list from the other. In this time window, <em>C</em> will get different results from <em>S1</em> (which has numbers up to 1013) and <em>S2</em> (which only has numbers up to 1009, which is the previous prime).</p>

<p>A simple way to solve this is to have <em>C</em> send the new number (1013) to the other servers; if it requested from <em>S1</em> it‚Äôll send the update to <em>S2</em> as a kind of write back, to make sure that <em>S2</em> also has it for the next request. We haven‚Äôt strictly defined the problem or its requirements, but this may need to assume a link that guarantees delivery and order (i.e. TCP, not UDP).</p>

<h4 id="unsolvable-atomicity-problem">Unsolvable atomicity problem</h4>
<p>Now assume that we have two prime number producers <em>P1</em> and <em>P2</em>. This introduces a new atomicity problem: the updates may not reach all servers atomically in order, and the servers cannot agree on the order.</p>

<p>This is <strong>impossible</strong> to solve; we won‚Äôt prove it, but universality of Turing is lost (unless we make very strong assumptions). This is known as the <a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf"><em>impossibility of consensus</em></a>.</p>

<h3 id="timing-assumptions">Timing assumptions</h3>
<p>An important element for describing distributed algorithms is how the system behaves with respect to the passage of time. Often, we need to be able to make assumptions about time bounds.</p>

<p>Measuring time in absolute terms with a physical clock (measuring seconds, minutes and hours) is a bit of a dead end for discussing algorithms. Instead, we‚Äôll use the concept of <em>logical time</em>, which is defined with respect to communications. This clock is just an abstraction we use to reason about algorithms; it isn‚Äôt accessible to the processes or algorithms.</p>

<p>The three time-related models are:</p>

<ul>
  <li><strong>Synchronous</strong>: assuming a synchronous system comes down to assuming the following properties:
    <ul>
      <li><strong>Synchronous computation</strong>: receiving a message can imply a local computation, and this computation can result in sending back a message. This assumption simply states that all the time it takes to do this is bounded and known.</li>
      <li><strong>Synchronous communication</strong>: there is a known upper bound limit on message transmission delays; the time between sending and delivering a message on the other end of the link is smaller that the bound</li>
      <li><strong>Synchronous clocks</strong>: the drift between a local clock and the global, real-time clock is bounded and known</li>
    </ul>
  </li>
  <li><strong>Eventually synchronous</strong>: the above assumptions hold eventually</li>
  <li><strong>Asynchronous</strong>: no assumptions</li>
</ul>

<p>We can easily see how a distributed system would be synchronous: placing bounds on computation and message transmission delays should be possible most of the time. But network overload and message loss may lead the system to become partially synchronous, which is why we have the concept of eventually synchronous.</p>

<p>To abstract these timing assumptions, we will introduce failure detectors in the following section.</p>

<h3 id="failure-detection">Failure detection</h3>
<p>A <strong>failure detector</strong> is a distributed oracle that provides processes with suspicions about crashed processes. There are two kinds of failure detectors, with the following properties</p>

<ul>
  <li><strong>Perfect failure detector</strong> $\mathcal{P}$
    <ul>
      <li><strong>PFD1. Strong completeness</strong>: eventually, every process that crashes is permanently suspected by every correct process</li>
      <li><strong>PFD2. Strong accuracy</strong>: if a process $p$ is detected by any process, then $p$ has crashed</li>
    </ul>
  </li>
  <li><strong>Eventually perfect failure detector</strong> $\diamond\mathcal{P}$
    <ul>
      <li><strong>EPFD1. Strong completeness = PFD1</strong></li>
      <li><strong>EPFD2. Eventual strong accuracy</strong>: eventually, no correct process is ever suspected by any correct process</li>
    </ul>
  </li>
</ul>

<p>A perfect failure detector tells us when a process $p$ has crashed by emitting a <code class="highlighter-rouge">&lt;Crash, p&gt;</code> event. It never makes mistakes, never changes its mind; decisions are permanent and accurate.</p>

<p>An eventually perfect detector may make mistakes, falsely suspecting a correct process to be crashed. If it does so, it will eventually change its mind and tell us the truth. When it suspects a process $p$, it emits a <code class="highlighter-rouge">&lt;Suspect, p&gt;</code> event; if it changes its mind, it emits a <code class="highlighter-rouge">&lt;Restore, p&gt;</code> event. In aggregate, eventually perfect failure detectors are accurate.</p>

<p>A failure detector can be implemented by the following algorithm:</p>

<ol>
  <li>Processes periodically send heartbeat messages</li>
  <li>A process sets a timeout based on worst case round trip of a message exchange</li>
  <li>A process suspects another process has failed if it timeouts that process</li>
  <li>A process that delivers a message from a suspected process revises its suspicion and doubles the time-out</li>
</ol>

<h2 id="reliable-broadcast">Reliable broadcast</h2>
<p>Broadcast is useful for applications with pubsub-like mechanisms, where some processes subscribe to events published by others (e.g. stock prices).</p>

<p>The subscribers might need some reliability guarantees from the publisher (these guarantees are called ‚Äúquality of service‚Äù, or QoS). These quality guarantees are typically not offered by the underlying network, so we‚Äôll see different broadcasting algorithms with different guarantees.</p>

<p>A broadcast operation is an operation in which a process sends a message to all processes in a system, including itself. We consider broadcasting to be a single operation, but it of course may take time to send all the messages over the network.</p>

<h3 id="best-effort-broadcast-beb">Best-effort broadcast (<abbr title="Best Effort Broadcast">BEB</abbr>)</h3>
<p>In best-effort broadcast (<abbr title="Best Effort Broadcast">BEB</abbr>), the sender is the one ensuring the reliability; the receivers do not have to be concerned with enforcing the reliability. On the other hand, if the sender fails, all guarantees go out the window.</p>

<h4 id="properties">Properties</h4>
<p>The guarantees of <abbr title="Best Effort Broadcast">BEB</abbr> are as follows:</p>

<ul>
  <li><strong>BEB1. Validity</strong>: if $p$ and $q$ are correct, then every message broadcast by $p$ is eventually delivered by $q$</li>
  <li><strong>BEB2. No duplication</strong>: no message is delivered more than once</li>
  <li><strong>BEB3. No creation</strong>: if a process delivers a message $m$ with sender $p$, then $m$ was previously broadcast by $p$</li>
</ul>

<p>BEB1 is a liveness property, while no BEB2 and BEB3 are safety properties.</p>

<p>As we said above, the broadcasting machine may still crash in the middle of a broadcast, where it hasn‚Äôt broadcast the message to everyone yet, and it‚Äôs important to note that <abbr title="Best Effort Broadcast">BEB</abbr> offers no guarantee against that.</p>

<h4 id="algorithm">Algorithm</h4>
<p>The algorithm for <abbr title="Best Effort Broadcast">BEB</abbr> is fairly straightforward: it just sends the message to all processes in the network using perfect links (remember that perfect links use stubborn links, sending the same message continuously). Perfect links already guarantees no duplication (PL2), so we can just forward delivered messages to the application layer above <abbr title="Best Effort Broadcast">BEB</abbr>.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span> <span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span> <span class="err">
</span>    <span class="n">PerfectLinks</span> <span class="p">(</span><span class="n">pp2p</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">sent</span> <span class="n">by</span> <span class="n">src</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">forall</span> <span class="n">q</span> <span class="o">‚àà</span> <span class="err">Œ†</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pSend</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="correctness">Correctness</h4>
<p>This is not the most efficient algorithm, but we‚Äôre not concerned about that. We just care about whether it‚Äôs correct, which we‚Äôll sketch out a proof for:</p>

<ul>
  <li><strong>Validity</strong>: By PL1 (the validity property of perfect links), and the very facts that:
    <ul>
      <li>the sender <code class="highlighter-rouge">pp2Send</code>s the message to all processes in $\Pi$</li>
      <li>every correct process that <code class="highlighter-rouge">pp2pDeliver</code>s a message <code class="highlighter-rouge">bebDeliver</code>s it too</li>
    </ul>
  </li>
  <li><strong>No duplication</strong>: by PL2 (the no duplication property of perfect links)</li>
  <li><strong>No creation</strong>: by PL3 (the no creation property of perfect links)</li>
</ul>

<h3 id="reliable-broadcast-rb">Reliable broadcast (<abbr title="Reliable Broadcast">RB</abbr>)</h3>
<p>As we said above, <abbr title="Best Effort Broadcast">BEB</abbr> offers no guarantees if the sender crashes while sending. If it does fail while sending, we may end up in a situation where some processes deliver the messages, and others don‚Äôt. In other words, not all processes <em>agree</em> on the delivery.</p>

<p>As it turns out, it‚Äôs even more subtle than that: the sender may already have done a <code class="highlighter-rouge">bebSend</code> and <code class="highlighter-rouge">pp2pSend</code>, and so on, placed all messages on the wire, and then crash. Because the underlying perfect link do not guarantee delivery when the sender crashes, we have no guarantee that the messages have been delivered.</p>

<h4 id="properties-1">Properties</h4>
<p>To address this, we want an additional property compared to <abbr title="Best Effort Broadcast">BEB</abbr>, <em>agreement</em>:</p>

<ul>
  <li><strong>RB1. Validity = BEB1</strong></li>
  <li><strong>RB2. No duplication = BEB2</strong></li>
  <li><strong>RB3. No creation = BEB3</strong></li>
  <li><strong>RB4. Agreement</strong>: for any message $m$, if a <strong>correct</strong> process delivers $m$, then every correct process delivers $m$</li>
</ul>

<p>RB4 tells us that even if the broadcaster crashes in the middle of a broadcast and is unable to send to other processes, we‚Äôll honor the agreement property. This is done by distinguishing receiving and delivering; the broadcaster may not have sent to everyone, but in that case, reliable broadcast makes sure that no one delivers.</p>

<h4 id="algorithm-1">Algorithm</h4>
<p>For the first time, we‚Äôll use a perfect failure detector $\mathcal{P}$ in our implementation of <abbr title="Reliable Broadcast">RB</abbr>. Since we‚Äôre aiming to do the same as <abbr title="Best Effort Broadcast">BEB</abbr> but with the added agreement property, we‚Äôll use <abbr title="Best Effort Broadcast">BEB</abbr> as the underlying link.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">ReliableBroadcast</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEfforBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">sent</span> <span class="n">by</span> <span class="n">src</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">RB1</span><span class="p">,</span> <span class="n">RB2</span><span class="p">,</span> <span class="n">RB3</span><span class="p">,</span> <span class="n">RB4</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rb</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span><span class="err">
</span>    <span class="n">from</span> <span class="p">:</span><span class="o">=</span> <span class="p">[];</span><span class="err">
</span>    <span class="k">forall</span> <span class="n">p</span> <span class="o">‚àà</span> <span class="err">Œ†</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>        <span class="n">from</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span> <span class="c1"># deliver to self
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span> <span class="c1"># broadcast to others using beb
</span><span class="err">
</span><span class="c1"># Here, it's important to distinguish the sender (at the other 
# side of the link) from the src (original broadcaster):
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">:</span><span class="err">
</span>        <span class="c1"># deliver m from src:
</span>        <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>        <span class="c1"># echo to others if src no longer correct:
</span>        <span class="k">if</span> <span class="n">src</span> <span class="o">‚àâ</span> <span class="n">correct</span><span class="p">:</span><span class="err">
</span>            <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span><span class="err">
</span>        <span class="k">else</span><span class="p">:</span><span class="err">
</span>            <span class="n">from</span><span class="p">[</span><span class="n">sender</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">from</span><span class="p">[</span><span class="n">sender</span><span class="p">]</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]};</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="n">correct</span> <span class="o">\</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">
</span>    <span class="c1"># echo all previous messages from crashed p:
</span>    <span class="k">forall</span> <span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">‚àà</span> <span class="n">from</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The idea is to echo all messages from a process that has crashed. From the moment we get the crash message from the perfect failure predictor $\mathcal{P}$, we forward all subsequent messages from the crashed sender to all nodes. But we  may also have received messages from the sender before knowing that it was crashed. To solve this, we keep track of all broadcasts, and rebroadcast all old messages when we find out the sender crashed.</p>

<h4 id="correctness-1">Correctness</h4>
<p>We‚Äôll sketch a proof for the properties:</p>

<ul>
  <li><strong>Validity</strong>: as for <abbr title="Reliable Broadcast">RB</abbr></li>
  <li><strong>No duplication</strong>: as for <abbr title="Reliable Broadcast">RB</abbr></li>
  <li><strong>No creation</strong>: as for <abbr title="Reliable Broadcast">RB</abbr></li>
  <li><strong>Agreement</strong>: Assume some correct process $p$ <code class="highlighter-rouge">rbDelivers</code> a message $m$ that was <code class="highlighter-rouge">rbBroadcast</code> by some process $q$.
    <ul>
      <li>If $q$ is correct, then by BEB1 (<abbr title="Best Effort Broadcast">BEB</abbr> validity), all correct processes will <code class="highlighter-rouge">bebDeliver</code> $m$, and according to the algorithm (<abbr title="According To The Algorithm">ATTA</abbr>), deliver $m$ through <code class="highlighter-rouge">rbDeliver</code>.</li>
      <li>If $q$ crashes, then by PFD1 (strong completeness of $\mathcal{P}$), $p$ detects the crash and <abbr title="According To The Algorithm">ATTA</abbr> echoes $m$ with <code class="highlighter-rouge">bebBroadcast</code> to all. Since $p$ is correct, then by BEB1 (<abbr title="Best Effort Broadcast">BEB</abbr> validity), all correct processes <code class="highlighter-rouge">bebDeliver</code> and then, <abbr title="According To The Algorithm">ATTA</abbr>, <code class="highlighter-rouge">rbDeliver</code> $m$.</li>
    </ul>
  </li>
</ul>

<p>Note that the proof only uses the completeness property of the failure detector (PFD1), not the accuracy property (PFD2). Therefore, the predictor can either be perfect $\mathcal{P}$ or eventually perfect $\diamond\mathcal{P}$.</p>

<h3 id="uniform-reliable-broadcast-urb">Uniform reliable broadcast (<abbr title="Uniform Reliable Broadcast">URB</abbr>)</h3>
<p>In <abbr title="Reliable Broadcast">RB</abbr>, we only required that <em>correct</em> processes should agree on the set of messages to deliver. We made no requirements on what messages we allow faulty processes to deliver.</p>

<p>For instance, a scenario possible under <abbr title="Reliable Broadcast">RB</abbr> is that we want to <code class="highlighter-rouge">rbBroadcast</code> from a process $p$. It could <code class="highlighter-rouge">rbDeliver</code> it to itself, and then crash before it had time to <code class="highlighter-rouge">bebBroadcast</code> it to others (see lines 24 and 25 of the <abbr title="Reliable Broadcast">RB</abbr> algorithm). In this scenario, all <em>correct</em> nodes still agree not to deliver the message (after all, none of them have received it), but $p$ has already delivered it.</p>

<h4 id="properties-2">Properties</h4>
<p>Uniform reliable broadcast solves this problem, by ensuring that <em>all</em> processes agree. Its properties are:</p>

<ul>
  <li><strong>URB1. Validity = BEB1</strong></li>
  <li><strong>URB2. No duplication = BEB2</strong></li>
  <li><strong>URB3. No creation = BEB3</strong></li>
  <li><strong>URB4. Uniform agreement</strong>: for any message $m$, if a process delivers $m$, then every correct process delivers $m$</li>
</ul>

<p>We‚Äôve removed the word ‚Äúcorrect‚Äù in agreement, and this changes things quite a bit. Uniform agreement is a stronger assertion, which ensures that the set of messages delivered by faulty processes is a <em>subset</em> of those delivered by correct processes.</p>

<h4 id="algorithm-2">Algorithm</h4>
<p>The algorithm is given by:</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span> <span class="err">
</span>    <span class="n">uniformBroadcast</span> <span class="p">(</span><span class="n">urb</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">sent</span> <span class="n">by</span> <span class="n">src</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">URB1</span><span class="p">,</span> <span class="n">URB2</span><span class="p">,</span> <span class="n">URB3</span><span class="p">,</span> <span class="n">URB4</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">urb</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span> <span class="c1"># set of [src, msg] that we have sent (broadcast or echoed)
</span>    <span class="n">ack</span><span class="p">[</span><span class="n">Message</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span> <span class="c1"># set of nodes that have acknowledged Message
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="n">correct</span> <span class="o">\</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">

</span><span class="c1"># before broadcasting, save message in pending
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">urbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="n">pending</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">]};</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span><span class="err">

</span><span class="c1"># If I haven't sent the message, echo it
# If I've already sent it, don't do it again
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">sender</span><span class="p">};</span><span class="err">
</span>    <span class="k">if</span> <span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">‚àâ</span> <span class="n">pending</span><span class="p">:</span><span class="err">
</span>        <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="n">pending</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]};</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span><span class="err">

</span><span class="c1"># Deliver the message when we know that all correct processes
# have delivered (and if we haven't delivered already)
</span><span class="k">upon</span> <span class="k">event</span> <span class="p">(</span><span class="k">exists</span> <span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">‚àà</span> <span class="n">pending</span><span class="p">)</span> <span class="err">
</span>  <span class="k">such</span> <span class="k">that</span> <span class="p">(</span><span class="n">can_deliver</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">urbDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># We can deliver if all correct nodes have acknowledged m:
</span><span class="k">def</span><span class="w"> </span><span class="nf">can_deliver</span><span class="p">(</span><span class="n">m</span><span class="p">):</span><span class="err">
</span>    <span class="n">return</span> <span class="n">correct</span> <span class="o">‚äÜ</span> <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>When a process sees a message (that is, <code class="highlighter-rouge">bebDeliver</code>s it), it relays it once; this relay serves as an acknowledgment, but also as a way to forward the message to other nodes. All processes keep track of who they have received messages from (either acks or the original message). Once all correct nodes have sent it the message (again, either an ack or the original), it can <code class="highlighter-rouge">urbDeliver</code>.</p>

<p>Because all nodes all echo the message to each other once, the number of messages sent is $N^2$.</p>

<p>Because the algorithm waits for confirmation from all correct nodes, it only <code class="highlighter-rouge">urbDeliver</code>s messages that it knows that all correct nodes have seen.</p>

<h4 id="correctness-2">Correctness</h4>
<p>To prove the correctness, we must first have a simple lemma: if a correct process $p$ <code class="highlighter-rouge">bebDeliver</code>s a message $m$, then $p$ eventually <code class="highlighter-rouge">urbDeliver</code>s the message $m$.</p>

<p>This can be proven as follows: <abbr title="According To The Algorithm">ATTA</abbr>, any process that <code class="highlighter-rouge">bebDeliver</code>s $m$ <code class="highlighter-rouge">bebBroadcast</code>s $m$. By the PFD1 (completeness of $\mathcal{P}$), and BEB1 (validity of <abbr title="Best Effort Broadcast">BEB</abbr>), there is a time at which $p$ <code class="highlighter-rouge">bebDeliver</code>s $m$ from every correct process and hence, <abbr title="According To The Algorithm">ATTA</abbr>, <code class="highlighter-rouge">urbDeliver</code>s it.</p>

<p>The proof is then:</p>

<ul>
  <li><strong>Validity</strong>: If a correct process $p$ <code class="highlighter-rouge">urbBroadcast</code>s a message $m$, then $p$ eventually <code class="highlighter-rouge">bebBroadcast</code>s and <code class="highlighter-rouge">bebDeliver</code>s $m$. Then, by our lemma, $p$ <code class="highlighter-rouge">urbDeliver</code>s it.</li>
  <li><strong>No duplication</strong>: as <abbr title="Best Effort Broadcast">BEB</abbr></li>
  <li><strong>No creation</strong>: as <abbr title="Best Effort Broadcast">BEB</abbr></li>
  <li><strong>Uniform agreement</strong>: Assume some process $p$ <code class="highlighter-rouge">urbDeliver</code>s a message $m$. <abbr title="According To The Algorithm">ATTA</abbr>, and by PFD1 and PFD2 (completeness <em>and</em> accuracy of $\mathcal{P}$), every correct process <code class="highlighter-rouge">bebDeliver</code>s $m$. By our lemma, every correct process will therefore <code class="highlighter-rouge">urbDeliver</code> $m$.</li>
</ul>

<p>Unlike previous algorithms, this relies on perfect failure detection. But under the assumption that the majority of processes stay correct, we can do with an eventually perfect failure detector $\diamond\mathcal{P}$. To do so, we remove the crash event above, and replace the <code class="highlighter-rouge">can_deliver</code> method with the following:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">can_deliver</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">N</span><span class="o">/</span><span class="mi">2</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="causal-order-broadcast-cb">Causal order broadcast (<abbr title="Causal Broadcast">CB</abbr>)</h2>
<p>So far, we didn‚Äôt consider ordering among messages. In particular, we considered messages to be independent.</p>

<p>Two messages from the same process might not be delivered in the order they were broadcast. This could be problematic: imagine a message board implemented with (uniform) reliable broadcast. For instance, in a message board application, a broadcaster $p$ could send out a message $m_1$, immediately change its mind and send out a rectification $m_2$. But due to network delays, messages may come out of order, and $m_2$ may be delivered before $m_1$ by the receiving node $q$. This is problematic, because the modification $m_2$ won‚Äôt make sense to $q$ as long as it hasn‚Äôt delivered $m_1$.</p>

<p>A nice property to have in these cases is <em>causal order</em>, where we don‚Äôt necessarily impose a total ordering constraint, but do want certain groups of messages to be ordered in a way that makes sense for the applications.</p>

<h3 id="causal-order">Causal order</h3>
<p>We say that  $m_1$ <em>causally precedes</em> $m_2$, denoted as $m_1 \longrightarrow m_2$, if any of the properties below hold:</p>

<ul>
  <li><strong><abbr title="First In First Out">FIFO</abbr> Order</strong>: Some process $p$ broadcasts $m_1$ before broadcasting $m_2$</li>
  <li><strong>Causal Order</strong>: Some process $p$ delivers $m_1$ and then broadcasts $m_2$</li>
  <li><strong>Transitivity</strong>: There is a message $m_3$ such that $m_1 \longrightarrow m_3$ and $m_3 \longrightarrow m_2$.</li>
</ul>

<p>Note that $m_1 \longrightarrow m_2$ doesn‚Äôt mean that $m_1$ <em>caused</em> $m_2$; it only means that it <em>may potentially have caused</em> $m_2$. But without any input from the application layer about what messages are logically dependent on each other, we can still enforce the above causal order.</p>

<h3 id="properties-3">Properties</h3>
<p>The <strong>causal order property (<abbr title="Causal Order">CO</abbr>)</strong> guarantees that messages are delivered in a way that respects all causality relations. It is respected when we can guarantee that any process $p$ delivering a message $m_2$ has already delivered every message $m_1$ such that $m_1 \longrightarrow m_2$.</p>

<p>So all in all, the properties we want from <abbr title="Causal Broadcast">CB</abbr> are:</p>

<ul>
  <li><strong>CB1. Validity = RB1 = BEB1</strong></li>
  <li><strong>CB2. No duplication = RB2 = BEB2</strong></li>
  <li><strong>CB3. No creation = RB3 = BEB3</strong></li>
  <li><strong>CB4. Agreement = RB4</strong></li>
  <li><strong>CB5. Causal order</strong>: if $m_1 \longrightarrow m_2$ then any process $p$ delivering $m_2$ has already delivered $m_1$.</li>
</ul>

<h3 id="no-waiting-algorithm">No-waiting Algorithm</h3>
<p>The following uses reliable broadcast, but we could also use <a href="#uniform-reliable-broadcast-urb">uniform reliable broadcast</a> to obtain uniform causal broadcast.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span> <span class="err">
</span>    <span class="n">ReliableCausalOrderBroadcast</span> <span class="p">(</span><span class="n">rcb</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span> <span class="err">
</span>    <span class="n">ReliableBroadcast</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbDeliver</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">sent</span> <span class="n">by</span> <span class="n">sender</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">RB1</span><span class="p">,</span> <span class="n">RB2</span><span class="p">,</span> <span class="n">RB3</span><span class="p">,</span> <span class="n">RB4</span><span class="p">,</span> <span class="n"><abbr title="Causal Order">CO</abbr></span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcb</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span> <span class="c1"># contains all past [src, m] pairs
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">past</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span><span class="err">
</span>    <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="n">past</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">]};</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="n">src_m</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">past_m</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">:</span><span class="err">
</span>        <span class="c1"># Deliver all undelivered, past messages that caused m:
</span>        <span class="k">forall</span> <span class="p">[</span><span class="n">src_n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">‚àà</span> <span class="n">past_m</span> <span class="k">do</span><span class="p">:</span> <span class="c1"># in list order
</span>            <span class="k">if</span> <span class="n">n</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">:</span><span class="err">
</span>                <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbDeliver</span><span class="p">,</span> <span class="n">src_n</span><span class="p">,</span> <span class="n">n</span><span class="p">&gt;;</span><span class="err">
</span>                <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">n</span><span class="p">};</span><span class="err">
</span>                <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="n">past</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="n">src_n</span><span class="p">,</span> <span class="n">n</span><span class="p">]};</span><span class="err">
</span>        <span class="c1"># Then deliver m:
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbDeliver</span><span class="p">,</span> <span class="n">src_m</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>        <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>        <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="n">past</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="n">src_m</span><span class="p">,</span> <span class="n">m</span><span class="p">]};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This algorithm ensures causal reliable broadcast. The idea is to re-broadcast all past messages every time, making sure we don‚Äôt deliver twice. This is obviously not efficient, but it works in theory.</p>

<p>An important point to note here is that this algorithm doesn‚Äôt wait. At no point is the <code class="highlighter-rouge">rcbDeliver</code>y delayed in order to respect causal order.</p>

<h3 id="garbage-collection">Garbage collection</h3>
<p>A problem with this algorithm is that the size of the <code class="highlighter-rouge">past</code> grows linearly. A simple optimization is to add a kind of distributed garbage collection to clean the <code class="highlighter-rouge">past</code>.</p>

<p>The idea is that we can delete the <code class="highlighter-rouge">past</code> when all other processes have delivered. To do this, whenever a process <code class="highlighter-rouge">rcbDelivers</code>, we also need to send an acknowledgment to all other processes. When we have received an acknowledgment from all correct processes, then we can purge the corresponding message $m$ from the <code class="highlighter-rouge">past</code>.</p>

<p>This implies using a perfect failure detector, as the implementation below shows.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">GarbageCollection</span><span class="p">,</span> <span class="n">ReliableCausalOrderBroadcast</span> <span class="p">(</span><span class="n">rcb</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">ReliableBroadcast</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbBroadcast</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">sent</span> <span class="n">by</span> <span class="n">sender</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">RB1</span><span class="p">,</span> <span class="n">RB2</span><span class="p">,</span> <span class="n">RB3</span><span class="p">,</span> <span class="n">RB4</span><span class="p">,</span> <span class="n"><abbr title="Causal Order">CO</abbr></span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcb</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span><span class="err">
</span>    <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span> <span class="c1"># for all possible messages m
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="n">correct</span> <span class="o">\</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">

</span><span class="c1"># Broadcast as before:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">past</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span><span class="err">
</span>    <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="n">past</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">]};</span><span class="err">

</span><span class="c1"># Deliver messages as before:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="n">src_m</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">past_m</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">:</span><span class="err">
</span>        <span class="c1"># Deliver all undelivered, past messages that caused m:
</span>        <span class="k">forall</span> <span class="p">[</span><span class="n">src_n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">‚àà</span> <span class="n">past_m</span> <span class="k">do</span><span class="p">:</span> <span class="c1"># (in list order)
</span>            <span class="k">if</span> <span class="n">n</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">:</span><span class="err">
</span>                <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbDeliver</span><span class="p">,</span> <span class="n">src_n</span><span class="p">,</span> <span class="n">n</span><span class="p">&gt;;</span><span class="err">
</span>                <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">n</span><span class="p">};</span><span class="err">
</span>                <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="n">past</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="n">src_n</span><span class="p">,</span> <span class="n">n</span><span class="p">]};</span><span class="err">
</span>        <span class="err">
</span>        <span class="c1"># Then deliver m:
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbDeliver</span><span class="p">,</span> <span class="n">src_m</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>        <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>        <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="n">past</span> <span class="o">‚à™</span> <span class="p">{[</span><span class="n">src_m</span><span class="p">,</span> <span class="n">m</span><span class="p">]};</span><span class="err">

</span><span class="c1"># Ack delivered messages that haven't been acked yet:
</span><span class="k">upon</span> <span class="k">event</span> <span class="p">(</span><span class="k">exists</span> <span class="n">m</span> <span class="o">‚àà</span> <span class="n">delivered</span><span class="p">)</span> <span class="k">such</span> <span class="k">that</span> <span class="p">(</span><span class="bp">self</span> <span class="o">‚àâ</span> <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">‚à™</span> <span class="p">{</span><span class="bp">self</span><span class="p">};</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n"><abbr title="Acknowledgment">ACK</abbr></span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span><span class="err">

</span><span class="c1"># Register delivered acks:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="p">[</span><span class="n"><abbr title="Acknowledgment">ACK</abbr></span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">sender</span><span class="p">};</span><span class="err">

</span><span class="c1"># Delete past once everybody has acked:
</span><span class="k">upon</span> <span class="k">event</span> <span class="n">correct</span> <span class="o">‚äÜ</span> <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">forall</span> <span class="p">[</span><span class="n">src_n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">‚àà</span> <span class="n">past</span> <span class="k">such</span> <span class="k">that</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">:</span><span class="err">
</span>        <span class="n">past</span> <span class="p">:</span><span class="o">=</span> <span class="n">past</span> <span class="o">\</span> <span class="p">{[</span><span class="n">src_n</span><span class="p">,</span> <span class="n">m</span><span class="p">]};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We need the perfect failure detector‚Äôs strong accuracy property to prove the causal order property.</p>

<p>However, we don‚Äôt need the failure detector‚Äôs completeness property; if we don‚Äôt know that a process is crashed, it has no impact on correctness, only on performance, since it just means that we won‚Äôt delete the past.</p>

<h3 id="waiting-algorithm">Waiting Algorithm</h3>
<p>Another algorithm is given below. It uses a <a href="https://en.wikipedia.org/wiki/Vector_clock">‚Äúvector clock‚Äù (<abbr title="Vector Clock">VC</abbr>)</a> as an alternative, more efficient encoding of the past.</p>

<p>A <abbr title="Vector Clock">VC</abbr> is simply a vector with one entry for each process in $\Pi$. Each entry is a sequence number (also called <em>logical clock</em>) for the corresponding process. Each process $p$ maintains its own <abbr title="Vector Clock">VC</abbr>. Its own <abbr title="Vector Clock">VC</abbr> entry counts the number of times it has <code class="highlighter-rouge">rcbBroadcast</code>. The entries for other processes $q$ count the number of times $p$ has <code class="highlighter-rouge">rcbDeliver</code>ed from $q$.</p>

<p>A <abbr title="Vector Clock">VC</abbr> is updated under the following rules:</p>

<ul>
  <li>Initially all clocks are empty</li>
  <li>Each time a process sends a message, it increments its own logical clock in the vector by one, and sends a copy of its own vector.</li>
  <li>Each time a process receives a message, it increments its own logical clock in the vector by one and updates each element in its vector by taking the maximum of the value in its own vector clock and the value in the vector in the received message (for every element).</li>
</ul>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">ReliableCausalOrderBroadcast</span> <span class="p">(</span><span class="n">rcb</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">ReliableBroadcast</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcb</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="k">for</span> <span class="n">all</span> <span class="n">p</span> <span class="o">‚àà</span> <span class="err">Œ†</span><span class="p">:</span><span class="err">
</span>        <span class="n"><abbr title="Vector Clock">VC</abbr></span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbDeliver</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n"><abbr title="Vector Clock">VC</abbr></span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span> <span class="err">
</span>    <span class="n"><abbr title="Vector Clock">VC</abbr></span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n"><abbr title="Vector Clock">VC</abbr></span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">VC_m</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">src</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span><span class="err">
</span>        <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="n">pending</span> <span class="o">‚à™</span> <span class="p">{(</span><span class="n">src</span><span class="p">,</span> <span class="n">VC_m</span><span class="p">,</span> <span class="n">m</span><span class="p">)};</span><span class="err">
</span>        <span class="c1"># Deliver pending:
</span>        <span class="k">while</span> <span class="k">exists</span> <span class="p">(</span><span class="n">src_n</span><span class="p">,</span> <span class="n">VC_n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">‚àà</span> <span class="n">pending</span><span class="err">
</span>          <span class="k">such</span> <span class="k">that</span> <span class="n">VC_n</span> <span class="o">&lt;=</span> <span class="n"><abbr title="Vector Clock">VC</abbr></span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>            <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="n">pending</span> <span class="o">\</span> <span class="p">{(</span><span class="n">src_n</span><span class="p">,</span> <span class="n">VC_n</span><span class="p">,</span> <span class="n">n</span><span class="p">)};</span><span class="err">
</span>            <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rcbDeliver</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">&gt;;</span> <span class="c1"># self, can this be true?
</span>            <span class="n"><abbr title="Vector Clock">VC</abbr></span><span class="p">[</span><span class="n">src_n</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n"><abbr title="Vector Clock">VC</abbr></span><span class="p">[</span><span class="n">src_n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The $\le$ comparison operation on vector clocks is defined as follows: $VC_a \le VC_b$ iff it is less or equal in all positions, and at least one position is strictly less.</p>

<h2 id="total-order-broadcast-tob">Total order broadcast (<abbr title="Total Order Broadcast">TOB</abbr>)</h2>
<p>In <a href="#reliable-broadcast">reliable broadcast</a>, the processes are free to deliver in any order they wish. In <a href="#causal-order-broadcast-cb">causal broadcast</a>, we restricted this a little: the processes must deliver in causal order. But causal order is only partial: some messages are causally unrelated, and may therefore be delivered in a different order by the processes.</p>

<p>In <strong>total order broadcast</strong> (<abbr title="Total Order Broadcast">TOB</abbr>), the processes must deliver all messages according to the same order. Note that this is orthogonal to causality, or even <abbr title="First In First Out">FIFO</abbr> ordering. It can be <em>made</em> to respect causal or <abbr title="First In First Out">FIFO</abbr> ordering, but at its core, it is only concerned with all processes delivering in the same order, no matter the actual ordering of messages.</p>

<p><abbr title="Total Order Broadcast">TOB</abbr> is also sometimes called <em>atomic broadcast</em>, as the delivery occurs as if broadcast was an indivisible, atomic action</p>

<p>An application using <abbr title="Total Order Broadcast">TOB</abbr> would be Bitcoin; for the blockchain, we want to make sure that everybody gets messages in the same order, for consistency. More generally though, total ordering is useful for any replicated state machine where replicas need to treat requests in the same order to preserve consistency.</p>

<h4 id="properties-4">Properties</h4>
<p>The properties are the same as those of (uniform) reliable broadcast, but with an added total order property.</p>

<ul>
  <li><strong>TOB1. Validity = RB1 = BEB1</strong></li>
  <li><strong>TOB2. No duplication = RB2 = BEB2</strong></li>
  <li><strong>TOB3. No creation = RB3 = BEB3</strong></li>
  <li><strong>(U)TOB4. (Uniform) Agreement = (U)RB4</strong></li>
  <li><strong>(U)TOB5. (Uniform) Total Order</strong>: Let $m$ and $m‚Äô$ be any two messages. Let $p$ be any (correct) process that delivers $m$ without having delivered $m‚Äô$ before. Then no (correct) process delivers $m‚Äô$ before $m$.</li>
</ul>

<h4 id="consensus-based-algorithm">Consensus-based Algorithm</h4>
<p>The algorithm can be implemented with consensus, which is the next section<sup id="fnref:read-both" role="doc-noteref"><a href="#fn:read-both" class="footnote">1</a></sup>.</p>

<p>The intuition of the algorithm is that we first disseminate messages using <abbr title="Reliable Broadcast">RB</abbr>. This imposes no particular order, so the processes simply store the messages in <code class="highlighter-rouge">unordered</code>. At this point, we have no guarantees of dissemination or ordering; it‚Äôs even possible that no processes have the same sets.</p>

<p>To solve this, we use consensus to decide on a single set; we order the messages in that set, and then deliver.</p>

<p>There are multiple rounds of this consensus, which we count in the <code class="highlighter-rouge">round</code> variable. The consensus helps us decide on a set of messages to <em>deliver</em> in that round. We use the <code class="highlighter-rouge">wait</code> variable to make sure that we only hold one instance of consensus at once.</p>

<p>Note that while one consensus round is ongoing, we may amass multiple messages in <code class="highlighter-rouge">unordered</code>. This means that consensus may lead us to decide on multiple messages to deliver at once.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">TotalOrderBroadcast</span> <span class="p">(</span><span class="n">tob</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">ReliableBroadcast</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span><span class="err">
</span>    <span class="n">Consensus</span> <span class="p">(</span><span class="n">cons</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">tobBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">tobDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">broadcast</span> <span class="n">by</span> <span class="n">src</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">TOB1</span><span class="p">,</span> <span class="n">TOB2</span><span class="p">,</span> <span class="n">TOB3</span><span class="p">,</span> <span class="n">TOB4</span><span class="p">,</span> <span class="n">TOB5</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">tob</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;:</span><span class="err">
</span>    <span class="n">unordered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">wait</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">round</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">tobBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span><span class="err">

</span><span class="c1"># Save received broadcasts for later:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">rbDeliver</span><span class="p">,</span> <span class="n">src_m</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">unordered</span> <span class="p">:</span><span class="o">=</span> <span class="n">unordered</span> <span class="o">‚à™</span> <span class="p">{(</span><span class="n">src_m</span><span class="p">,</span> <span class="n">m</span><span class="p">)};</span><span class="err">

</span><span class="c1"># When no consensus is ongoing and we have 
# unordered messages to propose:
</span><span class="k">upon</span> <span class="p">(</span><span class="n">unordered</span> <span class="o">!=</span> <span class="err">‚àÖ</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">wait</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">wait</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>    <span class="n">initialize</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">consensus</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">propose</span><span class="p">,</span> <span class="n">unordered</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># When consensus is done:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">decide</span><span class="p">,</span> <span class="n">decided</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">unordered</span> <span class="p">:</span><span class="o">=</span> <span class="n">unordered</span> <span class="o">\</span> <span class="p">{</span><span class="n">decided</span><span class="p">};</span><span class="err">
</span>    <span class="n">ordered</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">decided</span><span class="p">);</span><span class="err">
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">src_m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">tobDeliver</span><span class="p">,</span> <span class="n">src_m</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>        <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>    <span class="n">round</span> <span class="p">:</span><span class="o">=</span> <span class="n">round</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span>    <span class="n">wait</span> <span class="o">=</span> <span class="bp">false</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We assume that the <code class="highlighter-rouge">sort</code> function is deterministic and that all processes run the exact same sorting routine. We run this function to be sure that all processes traverse and deliver the decided set in the same order (usually, sets do not offer any ordering guarantees, though this is somewhat of an implementation detail).</p>

<p>Our total order broadcast is based on consensus, which we describe below.</p>

<h2 id="consensus-cons">Consensus (CONS)</h2>
<p>In the (uniform) consensus problem, the processes all propose values, and need to agree on one of these propositions. This gives rise to two basic events: a proposition (<code class="highlighter-rouge">&lt;propose, v&gt;</code>), and a decision (<code class="highlighter-rouge">&lt;decide, v&gt;</code>). Solving consensus is key to solving many problems in distributed computing (total order broadcast, atomic commit, ‚Ä¶).</p>

<p>Blockchain is based on consensus. Bitcoin mining is actually about solving consensus: a leader is chosen to decide on the broadcast order, and this leader gains 50 bitcoin. Seeing that this is a lot of money, many people want to be the leader; but we only want a single leader. Nakamoto‚Äôs solution is to choose the leader by giving out a hard problem. The computation can only be done with brute-force, there are no smart tricks or anything. So people put <a href="https://digiconomist.net/bitcoin-energy-consumption">enormous amounts of energy</a> towards solving this. Usually, only a single person will win the mining block; the probability is small, but the <a href="https://bitcoin.org/bitcoin.pdf">original Bitcoin paper</a> specifies that we should wait a little before rewarding the winner, in case there are two winners.</p>

<h3 id="properties-5">Properties</h3>

<p>The properties that we would like to see are:</p>

<ul>
  <li><strong>C1. Validity</strong>: if a value is decided, it has been proposed</li>
  <li><strong>(U)C2. (Uniform) Agreement</strong>: no two correct (any) processes decide differently</li>
  <li><strong>C3. Termination</strong>: every correct process eventually decides</li>
  <li><strong>C4. Integrity</strong>: every process decides at most once</li>
</ul>

<p>Termination and integrity together imply that every correct process decides exactly once. Validity ensures that the consensus may not invent a value by itself. Agreement is the main feature of consensus, that every two correct processes decide on the same value.</p>

<p>When we have uniform agreement (UC2), we want no processes to decide differently, no matter if they are faulty or correct. In this case, we talk about <em>uniform consensus</em>.</p>

<p>We can build consensus using total order broadcast, which is described above. But total broadcast can be built with consensus. It turns out that <strong>consensus and total order broadcast are equivalent problems in a system with reliable channels</strong>.</p>

<h3 id="algorithm-1-fail-stop-consensus">Algorithm 1: Fail-Stop Consensus</h3>
<p>Suppose that there are $N$ processes in $\Pi$, with IDs $1, \dots, N$. At the beginning, every process proposes a value; to decide, the processes go through $N$ rounds incrementally. At each round, the process with the ID corresponding to the round number is the leader of the round.</p>

<p>The leader decides its current proposal and broadcasts it to all. A process that is not the leader waits. This means that in a given round $i$, only the leader process $i$ is broadcasting. Additionally, a process only decides when it is the leader.</p>

<p>The non-leader processes can either deliver the proposal of the leader to adopt it, or detect that the leader has crashed. In any case, we can move on to the next round at that moment.</p>

<p>Now that we understand the properties of the algorithm, let‚Äôs take a look at an example run.</p>

<p>Process 1 is the first to be the leader. Once it gets a proposal from the application layer, it decides on it, and broadcasts it to the others. However, let‚Äôs suppose it crashes before getting to broadcast (<abbr title="Best Effort Broadcast">BEB</abbr> fails in this case). Then, the other processes will detect the crash with $\mathcal{P}$, and go to the next round.</p>

<p>Process 2 is now the leader. Since it doesn‚Äôt have a proposal from process 1, it will have to get one from the application layer. Once it has it, it can broadcast it to the others. Let‚Äôs assume this goes smoothly, and all processes receive it. They can all go to the next round; from now on, whatever the application layer proposes, they have to obey the decision from the previous leader.</p>

<p>This should make it clear why the algorithm is also known as ‚Äúhierarchical consensus‚Äù: every process must obey the decisions of the process above it (with a smaller index), as long as they don‚Äôt crash. We can think of this as a sort of line to the throne: we use the proposal of whoever is on the throne. If they die, number 2 in line decides, and so on.</p>

<p>Note that the rounds are not global time; we may make them so in examples for the sake of simplicity, but rounds are simply a local thing, which are somewhat synchronized by message passing from the leader.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">Consensus</span> <span class="p">(</span><span class="n">cons</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">propose</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">proposes</span> <span class="n">value</span> <span class="n">v</span> <span class="k">for</span> <span class="n">consensus</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">decide</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">outputs</span> <span class="n">a</span> <span class="n">decided</span> <span class="n">value</span> <span class="n">v</span> <span class="n">of</span> <span class="n">consensus</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">cons</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">suspected</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span>     <span class="c1"># list of suspected processes
</span>    <span class="n">round</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>         <span class="c1"># current round number
</span>    <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span>    <span class="c1"># current proposal
</span>    <span class="n">broadcast</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span> <span class="c1"># whether we've already broadcast
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="p">[];</span>    <span class="c1"># whether we've received a proposal from a process
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">suspected</span> <span class="p">:</span><span class="o">=</span> <span class="n">suspected</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">

</span><span class="c1"># If we don't already have a decision from the leader,
# take our own proposal
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">Propose</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">proposal</span> <span class="o">=</span> <span class="bp">nil</span><span class="p">:</span><span class="err">
</span>        <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="n">v</span><span class="p">;</span><span class="err">

</span><span class="c1"># When we receive a decision from the leader, use that:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">leader</span><span class="p">,</span> <span class="p">[</span><span class="n">Decided</span><span class="p">,</span> <span class="n">v</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="n">v</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span><span class="p">[</span><span class="n">leader</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">

</span><span class="c1"># If we've received a proposal from the leader, 
# or if the leader has crashed, go to the next round:
</span><span class="k">upon</span> <span class="k">event</span> <span class="n">delivered</span><span class="p">[</span><span class="n">round</span><span class="p">]</span> <span class="o">=</span> <span class="bp">true</span> <span class="ow">or</span> <span class="n">round</span> <span class="o">‚àà</span> <span class="n">suspected</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">round</span> <span class="p">:</span><span class="o">=</span> <span class="n">round</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">

</span><span class="c1"># When we are the leader and we have a value to propose
# (which may be ours, or one that we have from the previous leader),
# we broadcast it, and deliver the decision to the application layer
</span><span class="k">upon</span> <span class="k">event</span> <span class="n">round</span> <span class="o">=</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">broadcast</span> <span class="o">=</span> <span class="bp">false</span> <span class="ow">and</span> <span class="n">proposal</span> <span class="o">!=</span> <span class="bp">nil</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">decide</span><span class="p">,</span> <span class="n">proposal</span><span class="p">&gt;;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Decided</span><span class="p">,</span> <span class="n">proposal</span><span class="p">]&gt;;</span><span class="err">
</span>    <span class="n">broadcast</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Since this algorithm doesn‚Äôt aim for <em>uniform</em> consensus (but only regular consensus), it can tolerate $f &lt; N$ failures; as long as one process remains correct, it will decide on a value.</p>

<p>Let‚Äôs formulate a short correctness argument for the algorithm:</p>

<ul>
  <li><em>Validity</em> follows from the algorithm and BEB1 (validity)</li>
  <li><em>Agreement</em> can be proven as follows. Let $p_i$ with ID $i$ be the correct process with the smallest ID in a run. Suppose it decides on some value $v$.
    <ul>
      <li>If $i = N$, then $p_i$ is the only correct process</li>
      <li>Otherwise, in round $i$, <abbr title="According To The Algorithm">ATTA</abbr>, all correct processes $p_j$ with $j &gt; i$ receive $v$ and will not decide differently from $v$</li>
    </ul>
  </li>
  <li><em>Termination</em> follows from PFD1 (strong completeness) and BEB1 (validity): no process will remain indefinitely blocked in a round; every correct process $p$ will eventually reach round $p$ and decide in that round</li>
  <li><em>Integrity</em> follows from the algorithm and BEB1 (validity)</li>
</ul>

<h3 id="algorithm-2-fail-stop-uniform-consensus">Algorithm 2: Fail-Stop Uniform Consensus</h3>
<p>The previous algorithm does not guarantee <em>uniform</em> agreement. The problem is that that some of the processes decide too early, without making sure that their decision has been seen by enough processes (remember that if the broadcaster fails in <abbr title="Best Effort Broadcast">BEB</abbr>, then we have no guarantee that all processes receive the broadcast). It could therefore decide on a value, and then crash before anybody receives it, which would violate uniform agreement (UC2). The other processes might then have no choice but to decide on a different value.</p>

<p>To fix this, the idea is to do the same thing as before, but instead of $p_i$ deciding at round $i$, we wait until the last round $N$. The resulting algorithm is simply called ‚Äúhierarchical uniform consensus‚Äù.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">UniformConsensus</span> <span class="p">(</span><span class="n">ucons</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">propose</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">proposes</span> <span class="n">value</span> <span class="n">v</span> <span class="k">for</span> <span class="n">consensus</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">decide</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">outputs</span> <span class="n">a</span> <span class="n">decided</span> <span class="n">value</span> <span class="n">v</span> <span class="n">of</span> <span class="n">consensus</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">C1</span><span class="p">,</span> <span class="n">UC2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ucons</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">suspected</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span>     <span class="c1"># list of suspected processes
</span>    <span class="n">round</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>         <span class="c1"># current round number
</span>    <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span>    <span class="c1"># current proposal
</span>    <span class="n">broadcast</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span> <span class="c1"># whether we've already broadcast
</span>    <span class="n">decided</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span>   <span class="c1"># whether we've already decided
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="p">[];</span>    <span class="c1"># whether we've received a proposal from a process
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">suspected</span> <span class="p">:</span><span class="o">=</span> <span class="n">suspected</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">

</span><span class="c1"># If we don't already have a decision from the leader,
# take our own proposal
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">Propose</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">proposal</span> <span class="o">=</span> <span class="bp">nil</span><span class="p">:</span><span class="err">
</span>        <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="n">v</span><span class="p">;</span><span class="err">

</span><span class="c1"># When we receive a decision from the leader, use that:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">leader</span><span class="p">,</span> <span class="p">[</span><span class="n">Decided</span><span class="p">,</span> <span class="n">v</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="n">v</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span><span class="p">[</span><span class="n">leader</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">

</span><span class="c1"># If we've received a proposal from the leader,  
# or if the leader has crashed, go to the next round.
# If it's the last round, we can deliver the decision 
# to the application layer.
</span><span class="k">upon</span> <span class="k">event</span> <span class="n">delivered</span><span class="p">[</span><span class="n">round</span><span class="p">]</span> <span class="o">=</span> <span class="bp">true</span> <span class="ow">or</span> <span class="n">round</span> <span class="o">‚àà</span> <span class="n">suspected</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">round</span> <span class="o">=</span> <span class="n">N</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">decided</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">decide</span><span class="p">,</span> <span class="n">proposal</span><span class="p">&gt;;</span><span class="err">
</span>        <span class="n">decided</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>    <span class="k">else</span><span class="p">:</span><span class="err">
</span>        <span class="n">round</span> <span class="p">:</span><span class="o">=</span> <span class="n">round</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">

</span><span class="c1"># When we are the leader and we have a value to propose
# (which may be ours, or one that we have from the previous leader),
# we broadcast it
</span><span class="k">upon</span> <span class="k">event</span> <span class="n">round</span> <span class="o">=</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">broadcast</span> <span class="o">=</span> <span class="bp">false</span> <span class="ow">and</span> <span class="n">proposal</span> <span class="o">!=</span> <span class="bp">nil</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Decided</span><span class="p">,</span> <span class="n">proposal</span><span class="p">]&gt;;</span><span class="err">
</span>    <span class="n">broadcast</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>For the correctness argument, we‚Äôll need to introduce a short lemma: if $p_j$ completes round $i$ without receiving any message from $p_i$, and $j &gt; i$, then $p_i$ crashes by the end of round $j$.</p>

<details><summary><p>Proof of the lemma</p>
</summary><div class="details-content">
<p>We‚Äôll do a proof by contradiction: suppose $p_j$ completes round $i$ without receiving a message from $p_i$, $j&gt;i$ and $p_i$ completes round $j$.</p>

<p>Since $p_j$ completed round $i$ without hearing from $p_i$, <abbr title="According To The Algorithm">ATTA</abbr>, it must be because $p_j$ suspects $p_i$ in round $i$. We‚Äôre using a perfect failure detector $\mathcal{P}$. So in round $j$, we either have:</p>

<ul>
  <li>$p_i$ suspects $p_j$, which is impossible because $p_i$ crashes before $p_j$</li>
  <li>$p_i$ receives the round $j$ message from $p_j$, which is also impossible because $p_i$ crashed before $p_j$ completes round $i &lt; j$</li>
</ul>

<p>We have proved the contradiction in the inverse, and thus the lemma.</p>
</div></details>

<ul>
  <li><em>Validity</em> follows from the algorithm and BEB1 (validity)</li>
  <li><em>Termination</em> follows from PFD1 (strong completeness) and BEB1 (validity): no process will remain indefinitely blocked in a round; every correct process $p$ will eventually reach round $p$ and decide in that round</li>
  <li>
    <p><em>Uniform Agreement</em> can be proven as follows.</p>

    <p>Let $p_i$ with ID $i$ be the process with the smallest ID which decides on some value. This implies that it completes round $N$.</p>

    <p>By the above lemma, in round $i$, every $p_j$ with $j &gt; i$ receives and adopts the proposal of $p_i$. Thus, every process which sends a message after round $i$, or which decides, has the same proposal at the end of round $i$.</p>
  </li>
  <li><em>Integrity</em> follows from the algorithm and BEB1 (validity)</li>
</ul>

<h3 id="algorithm-3-uniform-consensus-with-eventually-perfect-failure-detector">Algorithm 3: Uniform Consensus with Eventually Perfect Failure Detector</h3>
<p>The two previous algorithms relied on perfect failure detectors. What happens if we use an eventually perfect failure detector $\diamond\mathcal{P}$ instead?</p>

<p>The problem is that that $\diamond\mathcal{P}$ only has <em>eventual</em> strong accuracy (EPFD2). This means that correct processes may be <em>falsely</em> suspected a finite number of time, which breaks the two previous algorithms: if a process is falsely suspected by everyone, and it falsely suspects everyone, then all the others would do consensus without it, and decide differently from it.</p>

<p>This algorithm relies on a majority of processes being correct (i.e. it can handle $f &lt; \frac{N}{2}$ failures). The solution is a little involved, so we won‚Äôt give pseudo-code for it. Instead, we‚Äôll just try to get an overarching idea of what goes on.</p>

<p>The algorithm is also round-based: processes still move incrementally from one round to the next. Process $p_i$ is the leader at round $k$, where $i = k \mod n$. In such a round, $p_i$ <em>tries</em> to decide:</p>

<ul>
  <li>It succeeds if it is not suspected.</li>
  <li>It fails if it is suspected. Processes that suspect $p_i$ inform it (with a negative acknowledgment, <abbr title="Negative Acknowledgment">NACK</abbr>, message), and everybody moves on to the next round (including $p_i$).</li>
</ul>

<p>If it succeeds, it uses <abbr title="Reliable Broadcast">RB</abbr> to send the decision to all. It‚Äôs important to use <abbr title="Reliable Broadcast">RB</abbr> at this step (not <abbr title="Best Effort Broadcast">BEB</abbr>) to preclude the case where $p_i$ crashes while broadcasting. This would allow for a situation where some nodes have delivered, and others haven‚Äôt.</p>

<p>Within a round $k$, $p_i$ decides on a value in three steps:</p>

<ol>
  <li>It collects propositions from the other processes, and chooses a value proposed by the majority.</li>
  <li>It broadcasts the chosen value back, and processes change their proposal to the value broadcast by $p_i$. The processes send an acknowledgment.</li>
  <li>If everyone acks, it decides, and broadcasts the decision. When others receive the decision, they decide on the given value.</li>
</ol>

<p>If a process suspects it at any point, it sends a <abbr title="Negative Acknowledgment">NACK</abbr> and everyone moves on. But the decided value may still have disseminated among the processes, since $p_i$ broadcasts the value before deciding. Thus, we have progress (because we went with the majority value, so we‚Äôre advancing towards consensus, or at worst, not moving).</p>

<p>Let‚Äôs take a look at a correctness argument:</p>

<ul>
  <li><em>Validity</em> is trivial</li>
  <li><em>Uniform agreement</em>: Let $k$ be the first round in which some leader process $p_i$ decides on a value $v$. This means that, in round $k$, a majority of processes have adopted $v$. <abbr title="According To The Algorithm">ATTA</abbr>, no value other than $v$ will be proposed, and therefore decided, henceforth.</li>
  <li><em>Termination</em> states that every correct process eventually decides. If a correct process decides, it uses <abbr title="Reliable Broadcast">RB</abbr> to send the decision to all, so every correct process decides.</li>
  <li><em>Integrity</em> is trivial</li>
</ul>

<h2 id="atomic-commit">Atomic commit</h2>
<p>The unit of data processing in a distributed system is the <em>transaction</em>. A transaction describes the actions to be taken, and can be terminated either by <strong>committing</strong> or <strong>aborting</strong>.</p>

<h3 id="non-blocking-atomic-commit-nbac">Non-Blocking Atomic Commit (<abbr title="Non-Blocking Atomic Commit">NBAC</abbr>)</h3>
<p>The <strong>nonblocking atomic commit (<abbr title="Non-Blocking Atomic Commit">NBAC</abbr>)</strong> abstraction is used to solve this problem in a reliable way. As in consensus, every process proposes an initial value of 0 or 1 (no or yes), and must decide on a final value 0 or 1 (abort or commit). Unlike consensus, the processes here seek to decide 1, but every process has a veto right.</p>

<p>The properties of <abbr title="Non-Blocking Atomic Commit">NBAC</abbr> are:</p>

<ul>
  <li><strong>NBAC1. Uniform Agreement</strong>: no two processes decide differently</li>
  <li><strong>NBAC2. Termination</strong>: every correct process eventually decides</li>
  <li><strong>NBAC3. Commit-validity</strong>: 1 can only be decided if all processes propose 1</li>
  <li><strong>NBAC4. Abort-validity</strong>: 0 can only be decided if some process crashes or votes 0</li>
</ul>

<p>Note that here, <abbr title="Non-Blocking Atomic Commit">NBAC</abbr> must decide to abort if some process crashes, even though all processes have proposed 1 (commit).</p>

<p>We can implement <abbr title="Non-Blocking Atomic Commit">NBAC</abbr> using three underlying abstractions:</p>

<ul>
  <li>A perfect failure detector $\mathcal{P}$</li>
  <li>Uniform consensus</li>
  <li>Best-effort broadcast <abbr title="Best Effort Broadcast">BEB</abbr></li>
</ul>

<p>It works as follows: every process $p$ broadcasts its initial vote (0 or 1, abort or commit) to all other processes using <abbr title="Best Effort Broadcast">BEB</abbr>. It waits to hear something from every process $q$ in the system; this is either done through <em>beb</em>-delivery from $q$, or by detecting the crash of $q$. At this point, two situations are possible:</p>

<ul>
  <li>If $p$ gets 0 (abort) from any other process, or if it detects a crash, it invokes consensus with a proposal to abort (0).</li>
  <li>Otherwise, if it receives the vote to commit (1) from all processes, then it invokes consensus with a proposal to commit (1).</li>
</ul>

<p>Once the consensus is over, every process <abbr title="Non-Blocking Atomic Commit">NBAC</abbr>-decides according to the outcome of the consensus.</p>

<p>We can write this more formally:</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">nonBlockingAtomicCommit</span> <span class="p">(</span><span class="n">nbac</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span>    <span class="n">UniformConsensus</span> <span class="p">(</span><span class="n">ucons</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">nbacPropose</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">nbacDecide</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">NBAC1</span><span class="p">,</span> <span class="n">NBAC2</span><span class="p">,</span> <span class="n">NBAC3</span><span class="p">,</span> <span class="n">NBAC4</span><span class="err">


</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">nbac</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">prop</span> <span class="p">:</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="n">correct</span> <span class="o">\</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">

</span><span class="c1"># Broadcast proposals to others:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">propose</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># Register proposal broadcasts from others:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">src</span><span class="p">};</span><span class="err">
</span>    <span class="n">prop</span> <span class="p">:</span><span class="o">=</span> <span class="n">prop</span> <span class="o">*</span> <span class="n">v</span><span class="p">;</span><span class="err">

</span><span class="c1"># When all correct processes have delivered,
# initialize consensus by proposing prop
</span><span class="k">upon</span> <span class="k">event</span> <span class="n">correct</span> <span class="o">‚äÜ</span> <span class="n">delivered</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">correct</span> <span class="o">!=</span> <span class="err">Œ†</span><span class="p">:</span><span class="err">
</span>        <span class="n">prop</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uconsPropose</span><span class="p">,</span> <span class="n">prop</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uconsDecide</span><span class="p">,</span> <span class="n">decision</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">nbacDecide</span><span class="p">,</span> <span class="n">decision</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We use multiplication to factor in the decisions we get from other processes; if we get a single 0, the final proposition will be 0 too. If we only get ones, the final proposition will be 1 too. Otherwise, this should be a fairly straight-forward implementation of the description we gave.</p>

<p>We need a perfect failure detector $\mathcal{P}$. An eventually perfect failure detector $\diamond\mathcal{P}$ is not enough, because we may suspect a process: this leads us to run uniform consensus with a proposal to abort, and consequently decide to abort. After this whole ordeal, we may find out that it wasn‚Äôt crashed after all, and the previously suspected process would never decide, which violates termination.</p>

<h3 id="2-phase-commit-2pc">2-Phase Commit (<abbr title="Two-Phase Commit">2PC</abbr>)</h3>
<p>This is a <em>blocking</em> algorithm, meaning that a crash will result in the algorithm being stuck. Unlike <abbr title="Non-Blocking Atomic Commit">NBAC</abbr>, this algorithm does not use consensus. It operates under a relaxed set of constraints; the termination property has been replaced with weak termination, which just says that if a process $p$ doesn‚Äôt crash, then all correct processes eventually decide.</p>

<p>In <abbr title="Two-Phase Commit">2PC</abbr>, we have a leading coordinator process $p$ which takes the decision. It asks everyone to vote, makes a decision, and notifies everyone of the decision.</p>

<p>As the name indicates, there are two phases in this algorithm:</p>

<ol>
  <li><strong>Voting phase:</strong> As before, proposals are sent with best-effort broadcast. A process collects all these proposals.</li>
  <li><strong>Commit phase</strong>: Again, just as before, it decides to abort if it receives any abort proposals, or if it detects any crashes with its perfect failure detector. Otherwise, if it receives proposals to commit from everyone, it will decide to commit. It then sends this decision to all processes with <abbr title="Best Effort Broadcast">BEB</abbr>.</li>
</ol>

<p>If $p$ crashes, all processes are blocked, waiting for its response.</p>

<h2 id="terminating-reliable-broadcast-trb">Terminating reliable broadcast (<abbr title="Terminating Reliable Broadcast">TRB</abbr>)</h2>
<p>Like reliable broadcast, terminating reliable broadcast (<abbr title="Terminating Reliable Broadcast">TRB</abbr>) is a communication primitive used to disseminate a message among a set of processes in a reliable way. However, <abbr title="Terminating Reliable Broadcast">TRB</abbr> is stricter than <abbr title="Uniform Reliable Broadcast">URB</abbr>.</p>

<p>In <abbr title="Terminating Reliable Broadcast">TRB</abbr>, there is a specific broadcaster process $p_{\text{src}}$, known by all processes. It is supposed to broadcast a message $m$. We‚Äôll also define a distinct message $\phi \ne m$. The other processes need to deliver $m$ if $p_{\text{src}}$ is correct, but may deliver $\phi$ if $p_{\text{src}}$ crashes.</p>

<p>The idea is that if $p_{\text{src}}$ crashes, the other processes may detect that it‚Äôs crashed, without having ever received $m$. But this doesn‚Äôt mean that $m$ wasn‚Äôt sent; $p_{\text{src}}$ may have crashed while it was in the process of sending $m$, so some processes may have delivered it while others might never do so.</p>

<p>For a process $p$, the following cases cannot be distinguished:</p>

<ul>
  <li>Some other process $q$ has delivered $m$; this means that $p$ should keep waiting for it</li>
  <li>No process will ever deliver $m$; this means that $p$ should <strong>not</strong> keep waiting for it</li>
</ul>

<p><abbr title="Terminating Reliable Broadcast">TRB</abbr> solves this by adding this missing piece of information to (uniform) reliable broadcast. It ensures that every process either delivers the message $m$ or sends a failure indicator $\phi$.</p>

<h3 id="properties-6">Properties</h3>
<p>The properties of <abbr title="Terminating Reliable Broadcast">TRB</abbr> are:</p>

<ul>
  <li><strong>TRB1. Integrity</strong>: If a process delivers a message $msg$, then either $msg=\phi$, or $msg=m$ that was broadcast by $p_{\text{src}}$</li>
  <li><strong>TRB2. Validity</strong>: If the sender $p_{\text{src}}$ is correct and broadcasts a message $m$, then $p_{\text{src}}$ eventually delivers $m$</li>
  <li><strong>(U)TRB3. (Uniform) Agreement</strong>: For any message $m$, if a correct process (any process) delivers $m$, then every correct process delivers $m$</li>
  <li><strong>TRB4. Termination</strong>: Every correct process eventually delivers exactly one message</li>
</ul>

<p>Unlike reliable broadcast, every correct process delivers a message, even if the broadcaster crashes. Indeed, with (uniform) reliable broadcast, when the broadcaster crashes, the other processes may deliver <em>nothing</em>.</p>

<h3 id="algorithm-3">Algorithm</h3>
<p>The following algorithm implements consensus-based uniform terminating reliable broadcast. To implement regular (non-uniform) <abbr title="Terminating Reliable Broadcast">TRB</abbr>, we can just use regular (non-uniform) consensus.</p>

<p>All processes wait until they receive a message from the source $p_{\text{src}}$, or until they detect that it has crashed. By the validity property of <abbr title="Best Effort Broadcast">BEB</abbr>, and the properties of a perfect failure detector, no process is ever left waiting forever.</p>

<p>They then invoke uniform consensus to know whether to deliver $m$ or $\phi$.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">trbBroadcast</span> <span class="p">(</span><span class="n">trb</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span>    <span class="n">Consensus</span> <span class="p">(</span><span class="n">ucons</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">trbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span>  <span class="n">broadcasts</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">trbDeliver</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">a</span> <span class="n">message</span> <span class="n">m</span><span class="p">,</span> <span class="ow">or</span> <span class="n">the</span> <span class="n">failure</span> <span class="err">œï
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">TRB1</span><span class="p">,</span> <span class="n">TRB2</span><span class="p">,</span> <span class="n">TRB3</span><span class="p">,</span> <span class="n">TRB4</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">trb</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;:</span><span class="err">
</span>    <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span><span class="err">

</span><span class="c1"># When application broadcasts:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">trbBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># When the perfect failure detector detects that
# the broadcaster p_src has crashed:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">proposal</span> <span class="o">=</span> <span class="bp">nil</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p_src</span><span class="p">:</span><span class="err">
</span>        <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="err">œï</span><span class="p">;</span><span class="err">

</span><span class="c1"># Otherwise, if we successfully receive from p_src:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">proposal</span> <span class="o">=</span> <span class="bp">nil</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p_src</span><span class="p">:</span><span class="err">
</span>        <span class="n">proposal</span> <span class="p">:</span><span class="o">=</span> <span class="n">m</span><span class="p">;</span><span class="err">

</span><span class="c1"># Start consensus as soon as we have a proposal:
</span><span class="k">upon</span> <span class="k">event</span> <span class="p">(</span><span class="n">proposal</span> <span class="o">!=</span> <span class="bp">nil</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">propose</span><span class="p">,</span> <span class="n">proposal</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># Deliver results of consensus:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">decide</span><span class="p">,</span> <span class="n">decision</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">trbDeliver</span><span class="p">,</span> <span class="n">p_src</span><span class="p">,</span> <span class="n">decision</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Let‚Äôs take a look at the scenario where $p_{\text{src}}$ broadcasts $m$ to processes $q$, $r$ and $s$. It broadcasts using <abbr title="Best Effort Broadcast">BEB</abbr>, so it can crash while broadcasting, and some processes wouldn‚Äôt receive the message. Suppose $q$ and $r$ got the message, but $s$ did not; instead it detects that $p_{\text{src}}$ has crashed. In the consensus round, $s$ will propose $\phi$, while the two other processes propose $m$. Since they are in the majority, the result of the consensus will be a decision to deliver $m$ (remember <a href="#algorithm-3-uniform-consensus-with-eventually-perfect-failure-detector">algorithm 3 for uniform consensus</a>, which picks the majority value). But in this scenario, $\phi$ would also have been a valid result.</p>

<h3 id="failure-detector">Failure detector</h3>
<p>The <abbr title="Terminating Reliable Broadcast">TRB</abbr> algorithm uses the perfect failure detector $\mathcal{P}$, which means that is is sufficient. Is it also sufficient? We‚Äôll argue that it is, because we can implement $\mathcal{P}$ with <abbr title="Terminating Reliable Broadcast">TRB</abbr> (meaning that it‚Äôs necessary):</p>

<p>Assume that every process $p_i$ is the broadcaster $p_{\text{src}}$, and can use an infinite number of instances of <abbr title="Terminating Reliable Broadcast">TRB</abbr>. The algorithm is as follows:</p>

<ol>
  <li>Every process keeps broadcasting messages with <abbr title="Terminating Reliable Broadcast">TRB</abbr></li>
  <li>If a process $p_k$ delivers $\phi_i$, it suspects $p_i$</li>
</ol>

<p>This algorithm uses non-uniform <abbr title="Terminating Reliable Broadcast">TRB</abbr>, i.e. just respecting agreement (not uniform agreement).</p>

<h2 id="group-membership-gm">Group membership (<abbr title="Group Membership">GM</abbr>)</h2>
<p>Many of the algorithms we‚Äôve seen so far require some knowledge of the state of other processes in the network $\Pi$. In other words, we need to know which processes are <em>participating</em> in the computation and which are not. So far, we‚Äôve used failure detectors to get this information.</p>

<p>The problem with failure detectors is that they are not coordinated, even when the failure detector is perfect. The outputs of failure detectors in different processes are not always the same: we may get notifications about crashes in different orders and at different times (because of delays in the network), and thus obtain different perspectives of the system‚Äôs evolution.</p>

<p>The group membership abstraction solves this problem, giving us consistent, accurate and better coordinated information about the state of processes.</p>

<p>In this course, we‚Äôll only use group membership to give coordinated information about crashes, but it‚Äôs useful to know that it can also be used to coordinate processes <em>joining</em> or <em>leaving</em> the set $\Pi$ explicitly (i.e. without crashing, but instead leaving voluntarily). This  enables dynamic changes in the set of processes $\Pi$. So far, we‚Äôve assumed that $\Pi$ is a static set of $N$ processes, but group membership allows us to handle dynamic sets.</p>

<h3 id="properties-7">Properties</h3>
<p>A group is the set of processes participating in the computation. The current membership is called a <em>view</em>. A view $V$ is a pair $V = (i, M)$, where $i$ is the numbering of the view, and $M$ is a set of processes.</p>

<p>The views are numbered by the number of changes the set of processes has gone through previously. As such, the first view is identified by $i=0$, and $M = \Pi$ (so $V_0 = (0, \Pi)$).</p>

<p>When the view changes, we get an indication event <code class="highlighter-rouge">&lt;membView, V&gt;</code>; we say that processes <em>install</em> this new view.</p>

<p>The properties for the group membership abstraction in this course are:</p>

<ul>
  <li><strong>Memb1. Local Monotonicity</strong>: If a process installs view $(j, M)$ after $(k, N)$, then $j &gt; k$ and $M \subset N$ (the only reason to change a view is to remove a process from the set when it crashes).</li>
  <li><strong>Memb2. Uniform Agreement</strong>: No two processes install views $(j, M)$ and $(j, M‚Äô)$ such that $M \ne M‚Äô$.</li>
  <li><strong>Memb3. Completeness</strong>: If a process $p$ crashes, then there is an integer $j$ such that every correct process installs view $(j, M)$ in which $p\notin M$</li>
  <li><strong>Memb4. Accuracy</strong>: If some process installs a view $(i, M)$ and $p\notin M$ then $p$ has crashed.</li>
</ul>

<h3 id="algorithm-4">Algorithm</h3>
<p>The implementation uses uniform consensus and a perfect failure detector.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">GroupMembership</span> <span class="p">(</span><span class="n">memb</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">UniformConsensus</span> <span class="p">(</span><span class="n">ucons</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">membView</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">Memb1</span><span class="p">,</span> <span class="n">Memb2</span><span class="p">,</span> <span class="n">Memb3</span><span class="p">,</span> <span class="n">Memb4</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">memb</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">view</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="err">Œ†</span><span class="p">);</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span><span class="err">
</span>    <span class="n">wait</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="n">correct</span> <span class="o">\</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">

</span><span class="c1"># When we've detected a crash and we aren't waiting for
# consensus, trigger new consensus for view.
</span><span class="k">upon</span> <span class="k">event</span> <span class="p">(</span><span class="n">correct</span> <span class="o">‚äÇ</span> <span class="n">view</span><span class="p">.</span><span class="n">memb</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">wait</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">wait</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uconsPropose</span><span class="p">,</span> <span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">correct</span><span class="p">)&gt;;</span><span class="err">

</span><span class="c1"># When consensus is done, install the new view:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uconsDecide</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">memb</span><span class="p">)&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">view</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">memb</span><span class="p">);</span><span class="err">
</span>    <span class="n">wait</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">membView</span><span class="p">,</span> <span class="n">view</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We use a <code class="highlighter-rouge">wait</code> variable: this allows to prevent a process from triggering a new view installation before the previous one has been done.</p>

<h2 id="view-synchronous-broadcast-vs">View-Synchronous broadcast (<abbr title="View-Synchronous broadcast">VS</abbr>)</h2>
<p>View-synchronous broadcast is the abstraction resulting from the combination of group membership and reliable broadcast. It ensures that the delivery of messages is coordinated by the installation of views.</p>

<h3 id="properties-8">Properties</h3>
<p>We aim to ensure all the properties of group membership (Memb1, Memb2, Memb3, Memb4) and of reliable broadcast (RB1, RB2, RB3, RB4). On top of this, we also aim to ensure the following property:</p>

<ul>
  <li><strong>VS1. View inclusion</strong>: A message is <code class="highlighter-rouge">vsDeliver</code>ed in the view where it is <code class="highlighter-rouge">vsBroadcast</code>.</li>
</ul>

<p>Unfortunately, this property doesn‚Äôt come for free. Combining <abbr title="View-Synchronous broadcast">VS</abbr> and <abbr title="Group Membership">GM</abbr> introduces a subtle problem that we‚Äôll have to solve, justifying the introduction of a solution as a new abstraction. Indeed, if a message is broadcast right as we‚Äôre installing a view, we‚Äôre breaking things.</p>

<p>Consider that a group of processes are exchanging messages, and process $q$ crashes. This failure is detected, and the other processes install a new view $V = (i, M)$, with $q \notin M$. After that, suppose that process $p$ delivers a message $m$ that was originally broadcast by $q$ (this can happen because of delays in the network). But it doesn‚Äôt make sense to deliver messages from processes that aren‚Äôt in the view to the application layer.</p>

<p>At this point, the solution may seem straightforward: allow $p$ to discard messages from $q$. Unfortunately, it‚Äôs possible that a third process $r$ has delivered $m$ before the view $V$ was installed. At this point, process $p$ must essentially chose between two conflicting goals: either deliver $m$ to ensure agreement (RB4), or discard it and guarantee view inclusion (VS1).</p>

<p>To solve this, we must introduce some notion of phases in which messages can or cannot be sent.</p>

<h3 id="algorithm-1-trb-based-vs">Algorithm 1: <abbr title="Terminating Reliable Broadcast">TRB</abbr>-based <abbr title="View-Synchronous broadcast">VS</abbr></h3>
<p><abbr title="View-Synchronous broadcast">VS</abbr> broadcast extends both <abbr title="Reliable Broadcast">RB</abbr> and <abbr title="Group Membership">GM</abbr>, so its interface must have events of both primitives. In addition to that, we need to add two more events for blocking communications when we‚Äôre about to install a view.</p>

<p>Note that these events for blocking communications aren‚Äôt between processes: they‚Äôre a contract between the <abbr title="View-Synchronous broadcast">VS</abbr> algorithm and the layer above (i.e. the application layer). If the application layer keeps broadcasting messages, installing a view may be postponed indefinitely. Therefore, when we need to install a view, we ask the application layer to stop broadcasting in the current view by indicating a <code class="highlighter-rouge">&lt;vsBlock&gt;</code> event. When the higher level module agrees, it replies by the requests of <code class="highlighter-rouge">&lt;vsBlockOk&gt;</code>.</p>

<p>We assume that the application layer indeed is well-behaved, and does not broadcast any further in the current view after the <code class="highlighter-rouge">&lt;vsBlockOk&gt;</code>. It can start broadcasting again once a new view is installed (<code class="highlighter-rouge">&lt;vsView, V&gt;</code>).</p>

<p>The key element of this algorithm is a flush procedure, which the processes execute when the <abbr title="Group Membership">GM</abbr> changes the view. This procedure uses uniform <abbr title="Terminating Reliable Broadcast">TRB</abbr> to rebroadcast messages that it has <code class="highlighter-rouge">vsDeliver</code>ed in the current view.</p>

<p>For normal data transfer within a view, we attach the view id to each message, and use <abbr title="Best Effort Broadcast">BEB</abbr> to broadcast. On the opposite side, when messages are <abbr title="Best Effort Broadcast">BEB</abbr> delivered (with a view id matching the current view), it can immediately <code class="highlighter-rouge">vsDeliver</code>. It‚Äôs also important the receiver saves the message to <code class="highlighter-rouge">delivered</code>, so that it can replay it during the flush procedure.</p>

<p>We start the flush procedure when <abbr title="Group Membership">GM</abbr> installs a view. We first ask the application to stop broadcasting; when we receive the OK, we stop <code class="highlighter-rouge">vsDeliver</code>ing, and discard all <abbr title="Best Effort Broadcast">BEB</abbr> messages. We can then resend all messages we <code class="highlighter-rouge">vsDeliver</code>ed previously (which are saved in <code class="highlighter-rouge">delivered</code>) using an instance of <abbr title="Terminating Reliable Broadcast">TRB</abbr> for each destination process.</p>

<p>We then receive all flush messages from the other processes. When we have received all flushes, we can move on to the next view.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">ViewSynchrony</span> <span class="p">(</span><span class="n">vs</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">GroupMembership</span> <span class="p">(</span><span class="n">memb</span><span class="p">)</span><span class="err">
</span>    <span class="n">UniformTerminatingReliableBroadcast</span> <span class="p">(</span><span class="n">utrb</span><span class="p">)</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">message</span> <span class="n">m</span> <span class="n">broadcast</span> <span class="n">by</span> <span class="n">src</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsView</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;:</span> <span class="n">Installs</span> <span class="n">a</span> <span class="n">view</span> <span class="n">V</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBlock</span><span class="p">&gt;:</span> <span class="n">requests</span> <span class="k">that</span> <span class="n">no</span> <span class="n">new</span> <span class="n">messages</span> <span class="n">are</span> <span class="err">
</span>                           <span class="n">broadcast</span> <span class="n">temporarily</span><span class="p">,</span> <span class="n">until</span> <span class="n">next</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">installed</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBlockOk</span><span class="p">&gt;:</span> <span class="n">confirms</span> <span class="k">that</span> <span class="n">no</span> <span class="n">new</span> <span class="n">messages</span> <span class="n">will</span> <span class="n">be</span><span class="err">
</span>                          <span class="n">broadcast</span> <span class="n">until</span> <span class="n">next</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">installed</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">RB1</span><span class="p">,</span> <span class="n">RB2</span><span class="p">,</span> <span class="n">RB3</span><span class="p">,</span> <span class="n">RB4</span><span class="err">
</span>    <span class="n">Memb1</span><span class="p">,</span> <span class="n">Memb2</span><span class="p">,</span> <span class="n">Memb3</span><span class="p">,</span> <span class="n">Memb4</span><span class="err">
</span>    <span class="n">VS1</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vs</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">view</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="err">Œ†</span><span class="p">);</span>    <span class="c1"># currently installed view
</span>    <span class="n">nextView</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span>   <span class="c1"># next view to install after flushing
</span>    <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="p">[];</span>     <span class="c1"># <abbr title="First In First Out">FIFO</abbr> queue of pending views
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span>    <span class="c1"># set of delivered messages in current view
</span>    <span class="n">trbDone</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span>      <span class="c1"># set of processes done flushing with uTRB
</span>    <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span> <span class="c1"># whether we're currently flushing
</span>                       <span class="c1"># messages in order to install a view
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span>  <span class="c1"># whether the application layer is blocked
</span><span class="err">
</span><span class="c1">#############################
# Part 1: Data transmission #
#############################
</span><span class="err">
</span><span class="c1"># Attach view ID to all messages we will broadcast:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">blocked</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsDeliver</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span><span class="err">

</span><span class="c1"># Deliver new messages from same view:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">view_id</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">view_id</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">blocked</span><span class="p">):</span><span class="err">
</span>        <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1">#######################
# Part 2: View change #
#######################
</span><span class="err">
</span><span class="c1"># Append new view to pending:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">membView</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">pending</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="p">);</span><span class="err">

</span><span class="c1"># When we need to switch view, initiate flushing by
# requesting vsBlock from application layer:
</span><span class="k">upon</span> <span class="k">event</span> <span class="p">(</span><span class="n">pending</span> <span class="o">!=</span> <span class="err">‚àÖ</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">flushing</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">nextView</span> <span class="p">:</span><span class="o">=</span> <span class="n">pending</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1"># get head of queue
</span>    <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBlock</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># When application layer replies OK, block and flush:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBlockOk</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>    <span class="n">trbDone</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">trbBroadcast</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">delivered</span><span class="p">)&gt;;</span><span class="err">

</span><span class="c1"># Get flushes and deliver missing messages:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">trbDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">(</span><span class="n">view_id</span><span class="p">,</span> <span class="n">view_delivered</span><span class="p">)&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">trbDone</span> <span class="p">:</span><span class="o">=</span> <span class="n">trbDone</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">src</span><span class="p">};</span><span class="err">
</span>    <span class="k">forall</span> <span class="n">m</span> <span class="o">‚àà</span> <span class="n">view_delivered</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>        <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># If we get œï, we can consider the process to be done flushing:
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">trbDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="err">œï</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">trbDone</span> <span class="p">:</span><span class="o">=</span> <span class="n">trbDone</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">src</span><span class="p">};</span><span class="err">

</span><span class="c1"># Once we have all flushes, we can go to the next view:
</span><span class="k">upon</span> <span class="k">event</span> <span class="p">(</span><span class="n">trbDone</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">memb</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">blocked</span> <span class="o">=</span> <span class="bp">true</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">view</span> <span class="p">:</span><span class="o">=</span> <span class="n">nextView</span><span class="p">;</span><span class="err">
</span>    <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsView</span><span class="p">,</span> <span class="n">view</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="algorithm-2-consensus-based-vs">Algorithm 2: Consensus-based <abbr title="View-Synchronous broadcast">VS</abbr></h3>
<p>The previous algorithm is uniform in the sense that no two processes install different views. But it isn‚Äôt uniform in terms of message delivery, as one process may <code class="highlighter-rouge">vsDeliver</code> a message and crash, while no other processes deliver that message.</p>

<p>So we need to revise the previous algorithm to get uniform <abbr title="View-Synchronous broadcast">VS</abbr>. Instead of launching parallel instances of <abbr title="Terminating Reliable Broadcast">TRB</abbr>, plus a group membership, we can use a consensus instance and parallel broadcasts for every view change.</p>

<p>The idea is that when $\mathcal{P}$ detects a failure, the processes exchange the messages they have delivered, and use consensus to agree on the membership and message set.</p>

<p>The data transmission works as previously. However, for the view change, we use consensus to agree on the message set (stored in <code class="highlighter-rouge">dset</code>).</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">ViewSynchrony</span> <span class="p">(</span><span class="n">vs</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">UniformConsensus</span> <span class="p">(</span><span class="n">ucons</span><span class="p">)</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">message</span> <span class="n">m</span> <span class="n">broadcast</span> <span class="n">by</span> <span class="n">src</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsView</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;:</span> <span class="n">Installs</span> <span class="n">a</span> <span class="n">view</span> <span class="n">V</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBlock</span><span class="p">&gt;:</span> <span class="n">requests</span> <span class="k">that</span> <span class="n">no</span> <span class="n">new</span> <span class="n">messages</span> <span class="n">are</span> <span class="err">
</span>                           <span class="n">broadcast</span> <span class="n">temporarily</span><span class="p">,</span> <span class="n">until</span> <span class="n">next</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">installed</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBlockOk</span><span class="p">&gt;:</span> <span class="n">confirms</span> <span class="k">that</span> <span class="n">no</span> <span class="n">new</span> <span class="n">messages</span> <span class="n">will</span> <span class="n">be</span><span class="err">
</span>                          <span class="n">broadcast</span> <span class="n">until</span> <span class="n">next</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">installed</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">RB1</span><span class="p">,</span> <span class="n">RB2</span><span class="p">,</span> <span class="n">RB3</span><span class="p">,</span> <span class="n">RB4</span><span class="err">
</span>    <span class="n">Memb1</span><span class="p">,</span> <span class="n">Memb2</span><span class="p">,</span> <span class="n">Memb3</span><span class="p">,</span> <span class="n">Memb4</span><span class="err">
</span>    <span class="n">VS1</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vs</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">view</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="err">Œ†</span><span class="p">);</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span><span class="err">
</span>    <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">dset</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">

</span><span class="c1">#############################
# Part 1: Data transmission #
#############################
</span><span class="err">
</span><span class="c1"># Same as before
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">blocked</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsDeliver</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">view_id</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">view_id</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">blocked</span><span class="p">):</span><span class="err">
</span>        <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1">#######################
# Part 2: View change #
#######################
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="n">correct</span> <span class="o">\</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">flushing</span><span class="p">:</span><span class="err">
</span>        <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBlock</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsBlockOk</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">DSET</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">delivered</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">DSET</span><span class="p">,</span> <span class="n">view_id</span><span class="p">,</span> <span class="n">m_set</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">dset</span> <span class="p">:</span><span class="o">=</span> <span class="n">dset</span> <span class="o">‚à™</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">m_set</span><span class="p">);</span><span class="err">
</span>    <span class="k">if</span> <span class="k">forall</span> <span class="n">p</span> <span class="o">‚àà</span> <span class="n">correct</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">‚àà</span> <span class="n">dset</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uconsPropose</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">correct</span><span class="p">,</span> <span class="n">dset</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uconsDecide</span><span class="p">,</span> <span class="n">view_id</span><span class="p">,</span> <span class="n">view_members</span><span class="p">,</span> <span class="n">view_dset</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">forall</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mset</span><span class="p">)</span> <span class="o">‚àà</span> <span class="n">view_dset</span> <span class="k">such</span> <span class="k">that</span> <span class="n">p</span> <span class="o">‚àà</span> <span class="n">view_members</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>        <span class="k">forall</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">‚àà</span> <span class="n">mset</span> <span class="k">such</span> <span class="k">that</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>            <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>            <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>    <span class="n">view</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="n">view_id</span><span class="p">,</span> <span class="n">view_members</span><span class="p">);</span><span class="err">
</span>    <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">dset</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">vsView</span><span class="p">,</span> <span class="n">view</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="algorithm-3-consensus-based-uniform-vs">Algorithm 3: Consensus-based Uniform <abbr title="View-Synchronous broadcast">VS</abbr></h3>
<p>Using <abbr title="Uniform Reliable Broadcast">URB</abbr> instead of <abbr title="Best Effort Broadcast">BEB</abbr> does not ensure uniformity. Therefore, a few changes are necessary.</p>

<p>As in algorithm 1 and 2, to <code class="highlighter-rouge">vsBroadcast</code>, we simply <code class="highlighter-rouge">bebBroadcast</code> and attach the view ID in a <code class="highlighter-rouge">Data</code> message. But now, when receiving these <code class="highlighter-rouge">bebBroadcast</code>, we mark the source as having acknowledged, and we acknowledge ourselves by re-broadcasting the message. We also add the message $m$ to the set of messages that have been broadcast in <code class="highlighter-rouge">pending</code>. This variable contains all messages that have been received in the current view. The set of processes that have acknowledged a message $m$ is stored in <code class="highlighter-rouge">ack[m]</code>.</p>

<p>We also maintain a variable <code class="highlighter-rouge">delivered</code> containing all messages ever <code class="highlighter-rouge">vsDeliver</code>ed. We can <code class="highlighter-rouge">vsDeliver</code> and add to <code class="highlighter-rouge">delivered</code> when all processes in the current view are contained in <code class="highlighter-rouge">ack[m]</code> (this is similar to what we did for <abbr title="Uniform Reliable Broadcast">URB</abbr>).</p>

<p>When $\mathcal{P}$ detects a crash, we initiate a flush. This process first <code class="highlighter-rouge">bebBroadcast</code>s the contents of <code class="highlighter-rouge">pending</code> (which contains all messages from the current view). It‚Äôs possible that not all messages in this set have been <code class="highlighter-rouge">vsDeliver</code>ed, so as soon as we‚Äôve collected all other uncrashed processes‚Äô <code class="highlighter-rouge">pending</code>, we can initiate a consensus about the new view, and about the union of all the <code class="highlighter-rouge">pending</code> sets it has received.</p>

<p>When consensus decides, we <code class="highlighter-rouge">vsDeliver</code> all the <code class="highlighter-rouge">pending</code> messages in the consensus decision, and install the new view.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="n">UniformViewSynchrony</span> <span class="p">(</span><span class="n">uvs</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">UniformConsensus</span> <span class="p">(</span><span class="n">ucons</span><span class="p">)</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">broadcasts</span> <span class="n">m</span> <span class="n">to</span> <span class="n">all</span> <span class="n">processes</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;:</span> <span class="n">delivers</span> <span class="n">message</span> <span class="n">m</span> <span class="n">broadcast</span> <span class="n">by</span> <span class="n">src</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsView</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;:</span> <span class="n">Installs</span> <span class="n">a</span> <span class="n">view</span> <span class="n">V</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsBlock</span><span class="p">&gt;:</span> <span class="n">requests</span> <span class="k">that</span> <span class="n">no</span> <span class="n">new</span> <span class="n">messages</span> <span class="n">are</span> <span class="err">
</span>                            <span class="n">broadcast</span> <span class="n">temporarily</span><span class="p">,</span> <span class="n">until</span> <span class="n">next</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">installed</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsBlockOk</span><span class="p">&gt;:</span> <span class="n">confirms</span> <span class="k">that</span> <span class="n">no</span> <span class="n">new</span> <span class="n">messages</span> <span class="n">will</span> <span class="n">be</span><span class="err">
</span>                           <span class="n">broadcast</span> <span class="n">until</span> <span class="n">next</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">installed</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">URB1</span><span class="p">,</span> <span class="n">URB2</span><span class="p">,</span> <span class="n">URB3</span><span class="p">,</span> <span class="n">URB4</span><span class="err">
</span>    <span class="n">Memb1</span><span class="p">,</span> <span class="n">Memb2</span><span class="p">,</span> <span class="n">Memb3</span><span class="p">,</span> <span class="n">Memb4</span><span class="err">
</span>    <span class="n">VS1</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvs</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">view</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="err">Œ†</span><span class="p">);</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span><span class="err">
</span>    <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">dset</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span> <span class="c1"># set of processes having ack'ed m
</span><span class="err">
</span><span class="c1">#############################
# Part 1: Data transmission #
#############################
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsBroadcast</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">blocked</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="n">pending</span> <span class="o">‚à™</span> <span class="p">{(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)};</span><span class="err">
</span>    <span class="c1"># do not vsDeliver to self yet!
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">view_id</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">blocked</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">view_id</span><span class="p">:</span><span class="err">
</span>        <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">sender</span><span class="p">};</span><span class="err">
</span>        <span class="k">if</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">pending</span><span class="p">:</span><span class="err">
</span>            <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="n">pending</span> <span class="o">‚à™</span> <span class="p">{(</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">)};</span><span class="err">
</span>            <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Data</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">]&gt;;</span> <span class="c1"># ack! 
</span><span class="err">
</span><span class="c1"># When all processes have acked a pending, undelivered message:
</span><span class="k">upon</span> <span class="k">exists</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">‚àà</span> <span class="n">pending</span> <span class="err">
</span>  <span class="k">such</span> <span class="k">that</span> <span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">members</span> <span class="o">‚äÜ</span> <span class="n">ack</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span><span class="p">)</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1">#######################
# Part 2: View change #
#######################
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="n">correct</span> <span class="o">\</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">flushing</span><span class="p">:</span><span class="err">
</span>        <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsBlock</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsBlockOk</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">DSET</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pending</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">DSET</span><span class="p">,</span> <span class="n">view_id</span><span class="p">,</span> <span class="n">m_set</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">dset</span> <span class="p">:</span><span class="o">=</span> <span class="n">dset</span> <span class="o">‚à™</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">m_set</span><span class="p">);</span><span class="err">
</span>    <span class="k">if</span> <span class="k">forall</span> <span class="n">p</span> <span class="o">‚àà</span> <span class="n">correct</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">‚àà</span> <span class="n">dset</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uconsPropose</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">correct</span><span class="p">,</span> <span class="n">dset</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uconsDecide</span><span class="p">,</span> <span class="n">view_id</span><span class="p">,</span> <span class="n">view_members</span><span class="p">,</span> <span class="n">view_dset</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">forall</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mset</span><span class="p">)</span> <span class="o">‚àà</span> <span class="n">view_dset</span> <span class="k">such</span> <span class="k">that</span> <span class="n">p</span> <span class="o">‚àà</span> <span class="n">view_members</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>        <span class="k">forall</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">‚àà</span> <span class="n">mset</span> <span class="k">such</span> <span class="k">that</span> <span class="n">m</span> <span class="o">‚àâ</span> <span class="n">delivered</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>            <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="n">delivered</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">m</span><span class="p">};</span><span class="err">
</span>            <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">m</span><span class="p">&gt;;</span><span class="err">
</span>    <span class="n">view</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="n">view_id</span><span class="p">,</span> <span class="n">view_members</span><span class="p">);</span><span class="err">
</span>    <span class="n">flushing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">blocked</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>    <span class="n">dset</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">pending</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="n">delivered</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">uvsView</span><span class="p">,</span> <span class="n">view</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="shared-memory-sm">Shared Memory (<abbr title="Shared Memory">SM</abbr>)</h2>
<p>In this section, we‚Äôll take a look at shared memory through a series of distributed algorithms that enable distributed data storage through read and write operations. These shared memory abstractions are called <em>registers</em>, since they resemble one.</p>

<p>The variations we‚Äôll look at vary in the number of processes that can read or write. Specifically, we‚Äôll look at:</p>

<ul>
  <li>$(1, N)$ regular register</li>
  <li>$(1, 1)$ atomic register</li>
  <li>$(1, N)$ atomic register</li>
</ul>

<p>The tuple notation above represents the supported number of writers and readers, respectively, so $(1, N)$ means one process can write, and $N$ can read. As we‚Äôll see, the difference between regular and atomic registers lies in the concurrency guarantees that they offer.</p>

<h3 id="1-n-regular-register">(1, N) Regular register</h3>
<p>This register assumes only one writer, but an arbitrary number of readers. This means that one specific process $p$ can write, but any process (including $p$) can read.</p>

<h4 id="properties-9">Properties</h4>
<p>A (1, N) regular register provides the following properties:</p>

<ul>
  <li><strong>ONRR1 Termination</strong>: if a correct process invokes an operation, then the operation eventually completes</li>
  <li><strong>ONRR2 Validity</strong>:
    <ul>
      <li>Any read not concurrent with a write returns the last value written</li>
      <li>Reads concurrent with a write return the last value written <em>or</em> the value concurrently being written</li>
    </ul>
  </li>
</ul>

<p>A note about ONRR2: if the writer crashes, the failed write is considered to be concurrent with all concurrent and future reads</p>

<p>Therefore, a read after a failed write can return the value that was supposed to be written, or the last value written before that.</p>

<p>In any case, reads always return values that have been, are being, or have been attempted to be written. In other words, read values can‚Äôt be created out of thin air, they must come from somewhere.</p>

<h4 id="algorithm-1-fail-stop-with-perfect-failure-detection">Algorithm 1: fail-stop with perfect failure detection</h4>
<p>Let‚Äôs take a look at how we can implement this with a message passing model. The following fail-stop algorithm is fairly simple. It uses a perfect failure detector (eventually perfect would not be enough).</p>

<p>To read, the algorithm simply returns the locally stored value. To write, it <code class="highlighter-rouge">bebBroadcast</code>s a <code class="highlighter-rouge">Write</code> message with the new value. Other processes can acknowledge this with a <abbr title="Perfect Link">PL</abbr>, and update the value (including the process that is being written to, as it also broadcasts the <code class="highlighter-rouge">Write</code> to itself). Once every process has ack‚Äôed, we can complete the write operation by triggering <code class="highlighter-rouge">&lt;onrrWriteReturn&gt;</code>.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">RegularRegister</span> <span class="p">(</span><span class="n">onrr</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectLinks</span> <span class="p">(</span><span class="n">pp2p</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrRead</span><span class="p">&gt;:</span> <span class="n">invokes</span> <span class="n">a</span> <span class="n">read</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWrite</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">invokes</span> <span class="n">a</span> <span class="n">write</span> <span class="n">with</span> <span class="n">value</span> <span class="n">v</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrReadReturn</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">completes</span> <span class="n">a</span> <span class="n">read</span><span class="p">,</span> <span class="n">returns</span> <span class="n">v</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWriteReturn</span><span class="p">&gt;:</span> <span class="n">completes</span> <span class="n">a</span> <span class="n">write</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">ONRR1</span><span class="p">,</span> <span class="n">ONRR2</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrr</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">val</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span>    <span class="c1"># register value
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="err">Œ†</span><span class="p">;</span>  <span class="c1"># set of correct processes 
</span>    <span class="n">acked</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span>    <span class="c1"># set of processes that have <abbr title="Acknowledgment">ACK</abbr>'ed the write
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">crash</span><span class="p">,</span> <span class="n">p</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">correct</span> <span class="p">:</span><span class="o">=</span> <span class="n">correct</span> <span class="o">\</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrRead</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrReadReturn</span><span class="p">,</span> <span class="n">val</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWrite</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span> <span class="p">[</span><span class="n">Write</span><span class="p">,</span> <span class="n">v</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">Write</span><span class="p">,</span> <span class="n">v</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">val</span> <span class="p">:</span><span class="o">=</span> <span class="n">v</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">plSend</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n"><abbr title="Acknowledgment">ACK</abbr></span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">plDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n"><abbr title="Acknowledgment">ACK</abbr></span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">acked</span> <span class="p">:</span><span class="o">=</span> <span class="n">acked</span> <span class="o">‚à™</span> <span class="p">{</span><span class="n">src</span><span class="p">};</span><span class="err">

</span><span class="k">upon</span> <span class="n">correct</span> <span class="o">‚äÜ</span> <span class="n">acked</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">acked</span> <span class="p">:</span><span class="o">=</span> <span class="err">‚àÖ</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWriteReturn</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The above algorithm is correct, as:</p>

<ul>
  <li><strong>ONRR1 Termination</strong>
    <ul>
      <li><abbr title="According To The Algorithm">ATTA</abbr>, all reads are local and eventually return, so termination for reads is trivial.</li>
      <li><abbr title="According To The Algorithm">ATTA</abbr>, writes eventually return, because and any process that doesn‚Äôt send back an ack crashes, and any process that crashes is detected. <abbr title="According To The Algorithm">ATTA</abbr>, both cases are handled, so we will eventually return. This is proven by:
        <ul>
          <li>PFD1, the strong completeness property of $\mathcal{P}$</li>
          <li>PL1, the reliable delivery of the perfect link channels</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>ONRR2 Validity</strong>:
    <ul>
      <li>In the absence of concurrent or failed operation, a read returns the last value written. To prove this, assume that a <code class="highlighter-rouge">write(x)</code> terminates, and no other <code class="highlighter-rouge">write</code> is invoked.</li>
    </ul>

    <p>By PFD2 (strong accuracy of $\mathcal{P}$), the value of the register at all processes that didn‚Äôt crash is <code class="highlighter-rouge">x</code>. Any subsequent <code class="highlighter-rouge">read()</code> at process $p$ returns the value at $p$, which is the last written value.</p>

    <ul>
      <li>A read returns the value concurrently written or last value written. This should be fairly clear <abbr title="According To The Algorithm">ATTA</abbr>, but the book has a more detailed proof.</li>
    </ul>
  </li>
</ul>

<p>Since we used PFD2 of $\mathcal{P}$ in the above proof, we need a perfect failure detector. Without that, we may violate the ONRR2 validity property of the register.</p>

<h4 id="algorithm-2-fail-silent-without-failure-detectors">Algorithm 2: Fail-silent without failure detectors</h4>
<p>Under the assumption that a majority of the processes are correct, we can actually implement (1, N) regular registers without failure detectors. This majority assumption is needed for this algorithm, even if we were to add an eventually perfect failure detector.</p>

<p>The key idea is that the writer process $p$ and all reader processes should use a set of <em>witnesses</em> that keep track of the most recent value of the register. Each set of witnesses must overlap: this forms <em>quorums</em> (defined as a collection of sets so that no two sets‚Äô intersection is empty). In our case, we consider a very simple form of quorum, namely a majority.</p>

<p>Like the previous algorithm, we store the register value in <code class="highlighter-rouge">val</code>; in addition to it, we also store a timestamp <code class="highlighter-rouge">ts</code>, counting the number of write operations.</p>

<p>When the writer process $p$ writes, it increments the timestamp, and <code class="highlighter-rouge">bebBroadcast</code>s a <code class="highlighter-rouge">Write</code> message to all processes. The processes can adopt the value by storing it locally if the timestamp is larger than the current one, and acknowledging through a <abbr title="Perfect Link">PL</abbr>. Once $p$ has such an acknowledgment from a majority of processes, it completes the write.</p>

<p>To read a value, the reader <code class="highlighter-rouge">bebBroadcast</code>s a <code class="highlighter-rouge">Read</code> message to all processes. Every process replies through a <abbr title="Perfect Link">PL</abbr> with its current value and timestamp. Once the reader has replies from a majority of processes, it selects the one with the highest timestamp, which ensures that the last value written is returned.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">RegularRegister</span> <span class="p">(</span><span class="n">onrr</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectLinks</span> <span class="p">(</span><span class="n">pp2p</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrRead</span><span class="p">&gt;:</span> <span class="n">invokes</span> <span class="n">a</span> <span class="n">read</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWrite</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">invokes</span> <span class="n">a</span> <span class="n">write</span> <span class="n">with</span> <span class="n">value</span> <span class="n">v</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrReadReturn</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">completes</span> <span class="n">a</span> <span class="n">read</span><span class="p">,</span> <span class="n">returns</span> <span class="n">v</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWriteReturn</span><span class="p">&gt;:</span> <span class="n">completes</span> <span class="n">a</span> <span class="n">write</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">ONRR1</span><span class="p">,</span> <span class="n">ONRR2</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrr</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">val</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span>    <span class="c1"># register value
</span>    <span class="n">ts</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1"># register timestamp (counts number of writes)
</span>    <span class="n">write_ts</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># timestamp of the pending write
</span>    <span class="n">acks</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1"># number of processes having ack'ed pending write
</span>    <span class="n">read_id</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1"># id of the currently pending read operation
</span>    <span class="n">readlist</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="bp">nil</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span> <span class="c1"># replies from the Read message
</span><span class="err">
</span><span class="c1">##################
# Part 1: Writes #
##################
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWrite</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">write_ts</span> <span class="p">:</span><span class="o">=</span> <span class="n">write_ts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span>    <span class="n">acks</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Write</span><span class="p">,</span> <span class="n">write_ts</span><span class="p">,</span> <span class="n">v</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">Write</span><span class="p">,</span> <span class="n">value_ts</span><span class="p">,</span> <span class="n">value</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">value_ts</span> <span class="p">&gt;</span> <span class="n">ts</span><span class="p">:</span><span class="err">
</span>        <span class="n">ts</span> <span class="p">:</span><span class="o">=</span> <span class="n">value_ts</span><span class="p">;</span><span class="err">
</span>        <span class="n">val</span> <span class="p">:</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pSend</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n"><abbr title="Acknowledgment">ACK</abbr></span><span class="p">,</span> <span class="n">value_ts</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pDeliver</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="p">[</span><span class="n"><abbr title="Acknowledgment">ACK</abbr></span><span class="p">,</span> <span class="n">value_ts</span><span class="p">]&gt;</span> <span class="k">such</span> <span class="k">that</span> <span class="n">value_ts</span> <span class="o">=</span> <span class="n">write_ts</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">acks</span> <span class="p">:</span><span class="o">=</span> <span class="n">acks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span>    <span class="k">if</span> <span class="n">acks</span> <span class="p">&gt;</span> <span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span><span class="err">
</span>        <span class="n">acks</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWriteReturn</span><span class="p">&gt;</span><span class="err">

</span><span class="c1">#################
# Part 2: Reads #
#################
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrRead</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">read_id</span> <span class="p">:</span><span class="o">=</span> <span class="n">read_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span>    <span class="n">readlist</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="bp">nil</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebBroadcast</span><span class="p">,</span> <span class="p">[</span><span class="n">Read</span><span class="p">,</span> <span class="n">rid</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">bebDeliver</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">Read</span><span class="p">,</span> <span class="n">read_id</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pSend</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="n">read_id</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">val</span><span class="p">]&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">pp2pDeliver</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="n">read_id</span><span class="p">,</span> <span class="n">read_ts</span><span class="p">,</span> <span class="n">read_val</span><span class="p">]&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">readlist</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="n">read_ts</span><span class="p">,</span> <span class="n">read_val</span><span class="p">);</span><span class="err">
</span>    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">readlist</span><span class="p">)</span> <span class="p">&gt;</span> <span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span><span class="err">
</span>        <span class="n">v</span> <span class="p">:</span><span class="o">=</span> <span class="n">highest_timestamp_val</span><span class="p">(</span><span class="n">readlist</span><span class="p">);</span><span class="err">
</span>        <span class="n">readlist</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="bp">nil</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrReadReturn</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="1-n-atomic-register">(1, N) Atomic register</h3>
<h4 id="properties-10">Properties</h4>
<p>With regular registers, the guarantees we gave about reads that are concurrent to writes are a little weak. For instance, suppose that a writer $p$ invokes <code class="highlighter-rouge">write(v)</code>. The specification allows for concurrent reads to return <code class="highlighter-rouge">nil</code> then <code class="highlighter-rouge">v</code> then <code class="highlighter-rouge">nil</code> again, and so on, until the write is done or if the writer crashes while writing, this can go on forever. An <strong>atomic register</strong> prevents such behavior.</p>

<p>An atomic register provides an additional guarantee compared to a regular register: <em>ordering</em>. The guarantee is that even when there is concurrency and failures, the execution is <em>linearizable</em>, i.e. it is equivalent to a sequential and failure-free execution. This means that we can now think of the write happening at a single atomic point in time, sometime during the execution of the write.</p>

<p>This means that both of the following are true:</p>

<ul>
  <li>Every failed write operation appears to be either complete or not to have been invoked at all</li>
  <li>Every complete operation appears to have been executed at some instant between its invocation and the reply event.</li>
</ul>

<p>Roughly speaking, atomic registers prevent ‚Äúold‚Äù values from being read by a process $q$ once a newer value has been read by $s$. The properties are:</p>

<ul>
  <li><strong>ONAR1. Termination = ONRR1</strong></li>
  <li><strong>ONAR2. Validity = ONRR2</strong></li>
  <li><strong>ONAR3. Ordering</strong>: If a read returns a value $v$ and a subsequent read returns a value $w$, then the write of $w$ does not precede the write of $v$</li>
</ul>

<h4 id="from-1-n-regular-to-1-1-atomic">From (1, N) regular to (1, 1) atomic</h4>
<p>First, let‚Äôs convert (1, N) regular into (1, 1) atomic. As before, we‚Äôll keep a timestamp for writes, which we increment every time we write. But this time, we‚Äôll also introduce a timestamp for reads, which contains the highest write-timestamp it has read so far. This allows the reader to avoid returning old values once it has read a new one.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">AtomicRegister</span> <span class="p">(</span><span class="n">ooar</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">RegularRegister</span> <span class="p">(</span><span class="n">onrr</span><span class="p">)</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooar</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">val</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span>      <span class="c1"># register value
</span>    <span class="n">ts</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1"># reader timestamp
</span>    <span class="n">write_ts</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span> <span class="c1"># writer timestamp
</span><span class="err">
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooarWrite</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">write_ts</span> <span class="p">:</span><span class="o">=</span> <span class="n">write_ts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWrite</span><span class="p">,</span> <span class="p">(</span><span class="n">write_ts</span><span class="p">,</span> <span class="n">v</span><span class="p">)&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrWriteReturn</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooarWriteReturn</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooarRead</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrRead</span><span class="p">&gt;;</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onrrReadReturn</span><span class="p">,</span> <span class="p">(</span><span class="n">value_ts</span><span class="p">,</span> <span class="n">value</span><span class="p">)&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">if</span> <span class="n">value_ts</span> <span class="p">&gt;</span> <span class="n">ts</span><span class="p">:</span><span class="err">
</span>        <span class="n">val</span> <span class="p">:</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span><span class="err">
</span>        <span class="n">ts</span> <span class="p">:</span><span class="o">=</span> <span class="n">value_ts</span><span class="p">;</span><span class="err">
</span>    <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooarReadReturn</span><span class="p">,</span> <span class="n">val</span><span class="p">&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="algorithm-1-from-1-1-atomic-to-1-n-atomic">Algorithm 1: From (1, 1) atomic to (1, N) atomic</h4>
<p>We can construct a (1, N) atomic register from $N^2$ underlying (1, 1) atomic registers. These are organized in a $N \times N$ matrix, with instances called 
$\text{ooar}[q][r]$ for $q \in \Pi$ and $r \in \Pi$.</p>

<p>Register instance $\text{ooar}[q][r]$ is used to inform process $q$ about the last value read by reader $r$. This establishes a sort of one-way communication channel, where $r$ writes to the register, and $q$ reads from it.</p>

<p>The writer $p$ places written values into registers $\text{ooar}[q][p]$, so that all readers $q\in\Pi$ can read. This means that every read and write requires $N$ registers to be updated.</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">AtomicRegister</span> <span class="p">(</span><span class="n">onar</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">AtomicRegister</span> <span class="p">(</span><span class="n">multiple</span> <span class="n">instances</span> <span class="n">ooar</span><span class="p">[][])</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarRead</span><span class="p">&gt;:</span> <span class="n">invokes</span> <span class="n">a</span> <span class="n">read</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarWrite</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">invokes</span> <span class="n">a</span> <span class="n">write</span> <span class="n">with</span> <span class="n">value</span> <span class="n">v</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarReadReturn</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">completes</span> <span class="n">a</span> <span class="n">read</span><span class="p">,</span> <span class="n">returns</span> <span class="n">v</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarWriteReturn</span><span class="p">&gt;:</span> <span class="n">completes</span> <span class="n">a</span> <span class="n">write</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">ONAR1</span><span class="p">,</span> <span class="n">ONAR2</span><span class="p">,</span> <span class="n">ONAR3</span><span class="err">

</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onar</span><span class="p">,</span> <span class="n">Init</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">ts</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1"># timestamp
</span>    <span class="n">acks</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1"># number of updated registers in write and read
</span>    <span class="n">writing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span> <span class="c1"># whether we are currently reading or writing
</span>    <span class="n">readval</span> <span class="p">:</span><span class="o">=</span> <span class="bp">nil</span><span class="p">;</span>   <span class="c1"># last read value
</span>    <span class="n">readlist</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="bp">nil</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span> <span class="c1"># reads from all other processes
</span>    <span class="k">forall</span> <span class="n">q</span> <span class="o">‚àà</span> <span class="err">Œ†</span><span class="p">,</span> <span class="n">r</span> <span class="o">‚àà</span> <span class="err">Œ†</span><span class="p">:</span><span class="err">
</span>        <span class="n">ooar</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ooar</span> <span class="n">with</span> <span class="n">writer</span> <span class="n">r</span><span class="p">,</span> <span class="n">reader</span> <span class="n">q</span><span class="p">;</span><span class="err">

</span><span class="c1"># To write, write to all q processes through (1, 1)-atomic registers
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarWrite</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">ts</span> <span class="p">:</span><span class="o">=</span> <span class="n">ts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span>    <span class="n">writing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">true</span><span class="p">;</span><span class="err">
</span>    <span class="k">forall</span> <span class="n">q</span> <span class="o">‚àà</span> <span class="err">Œ†</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooar</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="bp">self</span><span class="p">]</span><span class="n">Write</span><span class="p">,</span> <span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">v</span><span class="p">)&gt;;</span><span class="err">

</span><span class="c1"># When all (1, 1)-atomic writes are done, WriteReturn or ReadReturn
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooar</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="bp">self</span><span class="p">]</span><span class="n">WriteReturn</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">acks</span> <span class="p">:</span><span class="o">=</span> <span class="n">acks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span>    <span class="k">if</span> <span class="n">acks</span> <span class="o">=</span> <span class="n">N</span><span class="p">:</span><span class="err">
</span>        <span class="n">acks</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span>        <span class="k">if</span> <span class="n">writing</span><span class="p">:</span><span class="err">
</span>            <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarWriteReturn</span><span class="p">&gt;;</span><span class="err">
</span>            <span class="n">writing</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span><span class="p">;</span><span class="err">
</span>        <span class="k">else</span><span class="p">:</span><span class="err">
</span>            <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarReadReturn</span><span class="p">,</span> <span class="n">readval</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># To read, read from all r processes through (1, 1)-atomic registers
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarRead</span><span class="p">&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="k">forall</span> <span class="n">r</span> <span class="o">‚àà</span> <span class="err">Œ†</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>        <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooar</span><span class="p">[</span><span class="bp">self</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="n">Read</span><span class="p">&gt;;</span><span class="err">

</span><span class="c1"># When all reads are done, select the highest timestamp value,
# and write to all q processes
</span><span class="k">upon</span> <span class="k">event</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooar</span><span class="p">[</span><span class="bp">self</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="n">ReadReturn</span><span class="p">,</span> <span class="p">(</span><span class="n">value_ts</span><span class="p">,</span> <span class="n">value</span><span class="p">)&gt;</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>    <span class="n">readlist</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="p">:</span><span class="o">=</span> <span class="p">(</span><span class="n">value_ts</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span><span class="err">
</span>    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">readlist</span><span class="p">)</span> <span class="o">=</span> <span class="n">N</span><span class="p">:</span><span class="err">
</span>        <span class="p">(</span><span class="n">maxts</span><span class="p">,</span> <span class="n">readval</span><span class="p">)</span> <span class="p">:</span><span class="o">=</span> <span class="n">highest_timestamp_pair</span><span class="p">(</span><span class="n">readlist</span><span class="p">);</span><span class="err">
</span>        <span class="n">readlist</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="bp">nil</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span><span class="err">
</span>        <span class="k">forall</span> <span class="n">q</span> <span class="o">‚àà</span> <span class="err">Œ†</span> <span class="k">do</span><span class="p">:</span><span class="err">
</span>            <span class="k">trigger</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">ooar</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="bp">self</span><span class="p">]</span><span class="n">Write</span><span class="p">,</span> <span class="p">(</span><span class="n">maxts</span><span class="p">,</span> <span class="n">readval</span><span class="p">)&gt;;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="algorithm-2-read-impose-write-all-1-n-atomic">Algorithm 2: Read-impose Write-all (1, N) atomic</h4>
<p>We assume a fail-stop model, where any number of processes can crash, channels are reliable, and failure detection is perfect. We won‚Äôt go into the algorithm in detail, but its signature is:</p>

<figure class="highlight"><pre><code class="language-dapseudo" data-lang="dapseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="nb">Implements</span><span class="p">:</span><span class="err">
</span>    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">AtomicRegister</span> <span class="p">(</span><span class="n">onar</span><span class="p">)</span><span class="err">
</span><span class="nb">Uses</span><span class="p">:</span><span class="err">
</span>    <span class="n">BestEffortBroadcast</span> <span class="p">(</span><span class="n">beb</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectLinks</span> <span class="p">(</span><span class="n">pp2p</span><span class="p">)</span><span class="err">
</span>    <span class="n">PerfectFailureDetector</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="err">
</span><span class="nb">Events</span><span class="p">:</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarRead</span><span class="p">&gt;:</span> <span class="n">invokes</span> <span class="n">a</span> <span class="n">read</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span>    <span class="nb">Request</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarWrite</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">invokes</span> <span class="n">a</span> <span class="n">write</span> <span class="n">with</span> <span class="n">value</span> <span class="n">v</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarReadReturn</span><span class="p">,</span> <span class="n">v</span><span class="p">&gt;:</span> <span class="n">completes</span> <span class="n">a</span> <span class="n">read</span><span class="p">,</span> <span class="n">returns</span> <span class="n">v</span><span class="err">
</span>    <span class="nb">Indication</span><span class="p">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nc">onarWriteReturn</span><span class="p">&gt;:</span> <span class="n">completes</span> <span class="n">a</span> <span class="n">write</span> <span class="n">on</span> <span class="n">the</span> <span class="n">register</span><span class="err">
</span><span class="nb">Properties</span><span class="p">:</span><span class="err">
</span>    <span class="n">ONAR1</span><span class="p">,</span> <span class="n">ONAR2</span><span class="p">,</span> <span class="n">ONAR3</span>
</pre></td></tr></tbody></table></code></pre></figure>

<details><summary><p>Guest Lectures</p>
</summary><div class="details-content">
<h2 id="guest-lecture-1-mathematically-robust-distributed-systems">Guest Lecture 1: Mathematically robust distributed systems</h2>
<p>Some bugs in distributed systems can be very difficult to catch (it could involve long and costly simulation; with $n$ computers, it takes time $2^n$ to simulate all possible cases), and can be very costly when it happens.</p>

<p>The only way to be sure that there are no bugs is to <em>prove</em> it formally and mathematically.</p>

<h3 id="definition-of-the-distributed-system-graph">Definition of the distributed system graph</h3>

<p>Let $G(V, E)$ be a graph, where $V$ is the set of process nodes, and $E$ is the set of channel edges connecting the processes.</p>

<p>Two nodes $p$ and $q$ are <strong>neighbors</strong> if and only if there is an edge $\left\{ p, q \right\} \in E$.</p>

<p>Let $X \subseteq V$ be the set of <strong>crashed nodes</strong>. The other nodes are <strong>correct nodes</strong>.</p>

<p>We‚Äôll define the <strong>path</strong> as the sequence of nodes $(p_1, p_2, \dots, p_n)$ such that $\forall i \in \left\{i, \dots, n-1\right\}$, $p_i$ and $p_{i+1}$ are neighbors.</p>

<p>Two nodes $p$ and $q$ are <strong>connected</strong> if we have a path $(p_1, p_2, \dots, p_n)$ such that $p_1 = p$ and $p_2 = q$.</p>

<p>They are <strong>n-connected</strong> if there are $n$ disjoint paths connecting them; two paths $A = \left\{ p_1, \dots, p_n \right\}$ and $B = \left\{ p_1, \dots, p_n \right\}$ are disjoint if $A \cap B = \left\{ p, q \right\}$ (i.e. $p$ and $q$ are the two only nodes in common in the path).</p>

<p>The graph is <strong>k-connected</strong> if, $\forall \left\{ p, q \right\} \subseteq V$ there are $k$ disjoint paths between $p$ and $q$.</p>

<h3 id="example-on-a-simple-algorithm">Example on a simple algorithm</h3>

<p>Each node $p$ holds a message $m_p$ and a set $p.R$. The goal is for two nodes $p$ and $q$ to have $(p, m_p) \in q.R$ and $(q, m_q) \in p.R$; that is, they want to exchange messages, to <em>communicate reliably</em>. The algorithm is as follows:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">for</span> <span class="n">each</span> <span class="n">node</span> <span class="n">p</span><span class="p">:</span>
  <span class="n">initially</span><span class="p">:</span>
    <span class="n">send</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="n">to</span> <span class="nb">all</span> <span class="n">neighbors</span>

  <span class="n">upon</span> <span class="n">reception</span> <span class="n">of</span> <span class="n">of</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="n">add</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">to</span> <span class="n">p</span><span class="p">.</span><span class="n">R</span>
    <span class="n">send</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">to</span> <span class="nb">all</span> <span class="n">neighbors</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="reliable-communication">Reliable communication</h4>

<p>Now, let‚Äôs prove that if two nodes $p$ and $q$ are connected, then they communicate reliably. We‚Äôll do this by induction; formally, we‚Äôd like to prove that the proposition $\mathcal{P}_k$, defined as ‚Äú$p_k \text{ receives } (p, m_p)$‚Äù, is true for $k\in \left\{ 1, \dots, n \right\}$.</p>

<ul>
  <li>
    <p><strong>Base case</strong></p>

    <p>According to the algorithm, $p=p_1$ initially sends $(p, m_p)$ to $p_2$. So $p_2$ receives $(p, m_p)$ from $p_1$, and $\mathcal{P}_2$ is true.</p>
  </li>
  <li>
    <p><strong>Induction step</strong></p>

    <p>Suppose that the induction hypothesis $\mathcal{P}$ is true for $k \in \left\{2, \dots, n-1 \right\}$.</p>

    <p>Then, according to the algorithm, $p_k$ sends $(p, m_p)$ to $p_{k+1}$, meaning that $p_{k+1}$ receives $(p, m_p)$ from $p_k$, which means that $\mathcal{P}_{k+1}$ is true.</p>
  </li>
</ul>

<p>Thus $\mathcal{P}_k$ is true.</p>

<h3 id="robustness-property">Robustness property</h3>
<p>If at most $k$ nodes are crashed, and the graph is $(k+1)$-connected, then all correct nodes <strong>communicate reliably</strong>.</p>

<p>We prove this by contradiction. We want to prove $\mathcal{P}$, so let‚Äôs suppose that the opposite, $\bar{\mathcal{P}}$ is true; to prove this, we must be able to conclude that the graph is $(k+1)$-connected, but there are 2 correct nodes $p$ and $q$ that <em>do not</em> communicate reliably. Hopefully, doing so will lead us to a paradoxical conclusion that allows us to assert $\mathcal{P}$.</p>

<p>As we are $(k+1)$-connected, there exists $k+1$ paths $(P_1, P_2, \dots, P_{k+1})$ paths connecting any two nodes $p$ and $q$. We want to prove that $p$ and $q$ do not communicate reliably, meaning that all paths between them are ‚Äúcut‚Äù by at least one crashed node. As the paths are disjoint, this requires at least $k+1$ crashed nodes to cut them all.</p>

<p>This is a contradiction: we were working under the assumption that $k$ nodse were crashed, and proved that $k+1$ nodes were crashed. This disproves $\bar{\mathcal{P}}$ and proves $\mathcal{P}$.</p>

<h3 id="random-failures">Random failures</h3>
<p>Let‚Äôs assume that $p$ and $q$ are connected by a single path of length 1, only separated by a node $n$. If each node has a probability $f$ of crashing, then the probability of communicating reliably is $1-f$.</p>

<p>Now, suppose that the path is of length $n$; the probability of communicating reliably is the probability that none of the nodes crashing; individually, that is $1-f$, so for the whole chain, the probability is $(1-f)^n$.</p>

<p>However, if we have $n$ paths of length 1 (that is, instead of setting them up serially like previously, we set them up in parallel), the probability of not communicating reliably is that of all intermediary nodes crashing, which is $f^n$; thus, the probability of actually communicating reliably is $1-f^n$.</p>

<p>If our nodes are connecting by $n$ paths of length $m$, the probability of not communicating reliably is that of all lines being cut. The probability of a single line being cut is $1 - (1 - f)^m$. The probability of any line being cut is one minus the probability of no line being cut, so the final probability is $1 - (1 - (1 - f)^m)^n$.</p>

<h3 id="example-proof">Example proof</h3>
<p>Assume an infinite 2D grid of nodes. Nodes $p$ and $q$ are connected, with the distance in the shortest path being $D$. What is the probability of communicating reliably when this distance tends to infinity?</p>

\[\lim_{D \rightarrow \infty} = \dots\]

<p>First, let‚Äôs define a sequence of grids $G_k$. $G_0$ is a single node, $G_{k+1}$ is built from 9 grids $G_k$.</p>

<p>$G_{k+1}$ is <strong>correct</strong> if at least 8 of its 9 grids are correct.</p>

<p>We‚Äôll introduce the concept of a ‚Äúmeta-correct‚Äù node; this is not really anything official, just something we‚Äôre making up for the purpose of this proof. Consider a grid $G_n$. A node $p$ is ‚Äúmeta-correct‚Äù if:</p>

<ul>
  <li>It is in a correct grid $G_n$, and</li>
  <li>It is in a correct grid $G_{n-1}$, and</li>
  <li>It is in a correct grid $G_{n-2}$, ‚Ä¶</li>
</ul>

<p>For the sake of this proof, let‚Äôs just admit that all meta-correct nodes are connected; if you take two nodes $p$ and $q$ that are both meta-correct, there will be a path of nodes connecting them.</p>

<h4 id="step-1">Step 1</h4>
<p>If $x$ is the probability that $G_k$ is correct, what is the probability $P(x)$ that $G_{k+1}$ is correct?</p>

<p>$G_{k+1}$ is built up of 9 subgrids $G_k$. Let $P_i$ be the probability of $i$ nodes failing; the probability of $G_k$ being correct is the probability at most one subgrid being incorrect.</p>

\[\begin{align}
P_0 &amp; = x^9 \\
P_1 &amp; = 9(1-x)x^8 \\
P(x) &amp; = P_0 + P_1 = x^9 + 9(1-x)x^8 \\
\end{align}\]

<h4 id="step-2">Step 2</h4>
<p>Let $\alpha = 0.9$, and $z(x) = 1 + \alpha (x-1)$.</p>

<p>We will admit the following: if $x \in [0.99, 1]$ then $z(x) \le P(x)$.</p>

<p>Let $P_k$ be the result of applying $P$ (as defined in step 1) to $1-f$, $k$ times: $P_k = P(P(P(\dots P(1-f))))$. We will prove that $P_k \ge 1 - \alpha^k, \forall k &gt; 0$, by induction:</p>

<ul>
  <li><strong>Base case</strong>: $P_0 = 1-f = 0.99$ and $1-\alpha^0 = 1-1 = 0$, so $P_0 \ge 1-\alpha^0$.</li>
  <li>
    <p><strong>Induction step</strong>:</p>

    <p>Let‚Äôs suppose that $P_k \ge 1-\alpha^k$. We want to prove this for $k+1$, namely $P_{k+1} \ge 1 - \alpha^{k+1}$.</p>

\[P_{k+1} \ge P(P_k) \ge z(P_k) \ge z(1 - \alpha^k) \\
P_{k+1} \ge 1 + \alpha(1 - \alpha^k - 1) \\
P_{k+1} \ge 1 - \alpha^{k+1}\]
  </li>
</ul>

<p>This proves the result that $\forall k, P_k \ge 1 - \alpha^k$.</p>

<h4 id="step-3">Step 3</h4>
<p>Todo.</p>

<h2 id="guest-lecture-2-byzantine-failures">Guest lecture 2: Byzantine failures</h2>
<p>So far, we‚Äôve only considered situations in which nodes crash. In this section, we‚Äôll consider a new case: the one where nodes go ‚Äúevil‚Äù, a situation we call <strong>byzantine failures</strong>.</p>

<p>Suppose that our nodes are arranged in a grid. $S$ sends a message $m$ to $R$ by broadcasting $(S, m)$. With a simple broadcast algorithm, we just broadcast the message to the neighbor, which may be a byzantine node $B$ that alters the message before rebroadcasting it. Because $B$ can simply do that, we see that this simple algorithm is not enough to deal with byzantine failures.</p>

<p>To deal with this problem, we‚Äôll consider some other algorithms.</p>

<p>First, consider the case where there are $n$ intermediary nodes between $S$ and $R$ (this is not a daisy chain of nodes, but instead just $m$ paths of length 2 between $S$ and $R$). We assume that $S$ and $R$ are both correct (non-Byzantine) nodes, but the intermediary nodes may be.</p>

<p>For this algorithm, we define $k = \frac{n}{2} - 1$ if $n$ is even, and $k = \frac{n - 1}{2}$ if it is odd. The idea is to have $k+1$ be the smallest number of nodes to have a majority among the $n$ intermediary nodes. Let‚Äôs also assume that $R$ has a set $\Omega$ that acts as its memory, and a variable $x$, initially set to $x = 0$. Our goal is to have $x = m$.</p>

<p>$S$ simply sends out the message $m$ to its neighbors. The intermediary nodes forward messages that they receive to $R$. Finally, when $R$ receives a message $m$ from $p$, it adds it to the set $\Omega$. When there are $k+1$ nodes in the set, it can set $x = m$ (essentially, deliver the message).</p>

<p>We‚Äôll prove properties on this. The main point to note is that these proofs make no assumption on the potentially Byzantine nodes.</p>

<ul>
  <li>
    <p><strong>Safety</strong>: if the number of Byzantine nodes $f$ is $f \le k$, then $x = 0$ or $x = m$.</p>

    <p>The proof is by contradiction. Let‚Äôs suppose that the opposite is true, i.e. that $x = m‚Äô$, where $m‚Äô \ne m$. Then, according to the algorithm, this means that there must be $k+1$ nodes such that $\forall i \in \left\{ 1, \dots, k+1 \right\}$, we have $(p_i, m) \in \Omega$. But according to the algorithm, there are only two reasons for such a message being in the set; that is, either $p_i$ operates in good faith, receiving $m‚Äô$ from $S$, or it operates in bad faith, being a Byzantine node. The first case is impossible, as $S$ is correct. The alternative case can only happen if there are $k+1$ byzantine nodes, which is also impossible (since by assumption $f \le k$. This contradiction proves the safety property.</p>
  </li>
  <li>
    <p><strong>Liveness</strong>: if $f \le k$, we eventually have $x = m$.</p>

    <p>To prove this, we first define a set of $k+1$ correct (non-Byzantine) intermediary nodes. These nodes all receive $m$ from $S$, send it to $R$, which places it in $\Omega$. Eventually, we‚Äôll have $k+1$ nodes in the set, and then $x=m$.</p>

    <p>By the liveness and safety property, we know that initially $x=0$, eventually $x=m$, and we never have $x=m‚Äô$.</p>
  </li>
  <li>
    <p><strong>Optimality</strong>: if $f \ge k + 1$, it is impossible to ensure the safety property.</p>

    <p>Assume we have $k+1$ Byzantine nodes sending $m‚Äô$ to $R$. According to the algorithm, we get $x = m‚Äô$, so no safety.</p>

    <p>We can conclude that we can tolerate at most $k$ Byzantine nodes.</p>
  </li>
</ul>

<p>But here we only considered the specific case of length 2 paths. Let‚Äôs now consider the general case, which is the $(2k+1)$ connected graph. In this case, we consider any graph, and each node needs to broadcast a message $m_p$. Every node has a set $p_R$ to send messages, and a set $p_X$ of received messages.</p>

<p>The algorithm is as follows. Initially, the nodes send $(p, \emptyset, m_p)$ to their neighbors. When a node $p$ receives $(u, \Omega, m)$ from a neighbor $q$, with $p\notin\Omega$ and $q\notin\Omega$, the node sends $(u, \Omega\cup u, m)$ to its neighbors, and add that to $p_X$. When there exists a node $q$, a message $m$ and $k+1$ sets $\Omega_1, \dots, \Omega_{k+1}$ such that $\bigcup_{i=1}^{k+1} \Omega_i = \left\{ q \right\}$, and we have $k+1$ message in $p_X$, we can add $(q, m)$ to $p_R$.</p>

<p>We‚Äôll prove the following properties under the hypotheses that we have at most $k$ Byzantine nodes (a minority), and that the graph is connected (otherwise we couldn‚Äôt broadcast messages between the nodes)</p>

<ul>
  <li>
    <p><strong>Safety</strong>: If $p$ and $q$ are two correct nodes, we never have $(p, m_p‚Äô)\in q_R$ (where $m_p‚Äô \ne m_p$). In other words, no fake messages are accepted.</p>

    <p>The proof is by contradiction, in which we use induction to arrive to a contradictory conclusion. We‚Äôll try to prove the opposite of our claim, namely that there are two correct nodes $p$ and $q$ such that $(p, m_p‚Äô) \in q_R$.</p>

    <p>According to our algorithm, we have $k+1$ disjoint sets whose intersection is $p$, and $k+1$ elements $(p, \Omega_i, m) \in q_X$.</p>

    <p>To prove this, we‚Äôll need to prove a sub-property: that each set $\Omega_i$ contains at least one byzantine node. We prove this by contradiction. We‚Äôll suppose the opposite, namely that $\Omega_i$ contains no byzantine node (i.e. that they are all correct). I won‚Äôt write down the proof of this, but it‚Äôs in the lecture notes if ever (it‚Äôs by induction).</p>
  </li>
</ul>

</div></details>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:read-both" role="doc-endnote">
      <p>Consensus and <abbr title="Total Order Broadcast">TOB</abbr> are very interdependent, so it can be a good idea to read both twice.¬†<a href="#fnref:read-both" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET