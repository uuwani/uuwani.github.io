I"ºW<ul id="markdown-toc">
  <li><a href="#books" id="markdown-toc-books">Books</a></li>
  <li><a href="#call-by-name-cbn-call-by-value-cbv" id="markdown-toc-call-by-name-cbn-call-by-value-cbv">Call-by-name (CBN), call-by-value (CBV)</a>    <ul>
      <li><a href="#value-definitions" id="markdown-toc-value-definitions">Value definitions</a></li>
    </ul>
  </li>
  <li><a href="#blocks-and-lexical-scope" id="markdown-toc-blocks-and-lexical-scope">Blocks and lexical scope</a></li>
  <li><a href="#tail-recursion" id="markdown-toc-tail-recursion">Tail recursion</a></li>
  <li><a href="#higher-order-functions" id="markdown-toc-higher-order-functions">Higher-Order Functions</a>    <ul>
      <li><a href="#anonymous-functions" id="markdown-toc-anonymous-functions">Anonymous functions</a></li>
    </ul>
  </li>
  <li><a href="#currying" id="markdown-toc-currying">Currying</a></li>
  <li><a href="#classes-functions-and-data" id="markdown-toc-classes-functions-and-data">Classes: functions and data</a>    <ul>
      <li><a href="#methods" id="markdown-toc-methods">Methods</a>        <ul>
          <li><a href="#identifier" id="markdown-toc-identifier">Identifier</a></li>
          <li><a href="#infix-notation" id="markdown-toc-infix-notation">Infix notation</a></li>
        </ul>
      </li>
      <li><a href="#constructors" id="markdown-toc-constructors">Constructors</a></li>
      <li><a href="#data-abstraction" id="markdown-toc-data-abstraction">Data abstraction</a></li>
      <li><a href="#assert-and-require" id="markdown-toc-assert-and-require">Assert and require</a></li>
    </ul>
  </li>
  <li><a href="#class-hierarchies" id="markdown-toc-class-hierarchies">Class Hierarchies</a>    <ul>
      <li><a href="#abstract-classes" id="markdown-toc-abstract-classes">Abstract classes</a>        <ul>
          <li><a href="#terminology" id="markdown-toc-terminology">Terminology</a></li>
          <li><a href="#override" id="markdown-toc-override">Override</a></li>
        </ul>
      </li>
      <li><a href="#traits" id="markdown-toc-traits">Traits</a></li>
      <li><a href="#singleton-objects" id="markdown-toc-singleton-objects">Singleton objects</a></li>
      <li><a href="#packages-and-imports" id="markdown-toc-packages-and-imports">Packages and imports</a></li>
      <li><a href="#polymorphism" id="markdown-toc-polymorphism">Polymorphism</a>        <ul>
          <li><a href="#type-inference" id="markdown-toc-type-inference">Type inference</a></li>
          <li><a href="#type-bounds" id="markdown-toc-type-bounds">Type bounds</a></li>
          <li><a href="#variance" id="markdown-toc-variance">Variance</a></li>
        </ul>
      </li>
      <li><a href="#object-oriented-decomposition" id="markdown-toc-object-oriented-decomposition">Object oriented decomposition</a></li>
      <li><a href="#pattern-matching" id="markdown-toc-pattern-matching">Pattern matching</a></li>
      <li><a href="#case-classes" id="markdown-toc-case-classes">Case classes</a></li>
    </ul>
  </li>
  <li><a href="#lists" id="markdown-toc-lists">Lists</a>    <ul>
      <li><a href="#list-constructors" id="markdown-toc-list-constructors">List constructors</a></li>
      <li><a href="#list-patterns" id="markdown-toc-list-patterns">List patterns</a></li>
      <li><a href="#list-methods" id="markdown-toc-list-methods">List methods</a>        <ul>
          <li><a href="#sublists-and-element-access" id="markdown-toc-sublists-and-element-access">Sublists and element access</a></li>
          <li><a href="#creating-new-lists" id="markdown-toc-creating-new-lists">Creating new lists</a></li>
          <li><a href="#finding-elements" id="markdown-toc-finding-elements">Finding elements</a></li>
        </ul>
      </li>
      <li><a href="#higher-order-list-functions" id="markdown-toc-higher-order-list-functions">Higher-order list functions</a>        <ul>
          <li><a href="#map" id="markdown-toc-map">Map</a></li>
          <li><a href="#filter" id="markdown-toc-filter">Filter</a></li>
          <li><a href="#reduce" id="markdown-toc-reduce">Reduce</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#implicit-parameters" id="markdown-toc-implicit-parameters">Implicit parameters</a>    <ul>
      <li><a href="#rules-for-implicit-parameters" id="markdown-toc-rules-for-implicit-parameters">Rules for implicit parameters</a></li>
    </ul>
  </li>
  <li><a href="#proof-techniques" id="markdown-toc-proof-techniques">Proof techniques</a>    <ul>
      <li><a href="#structural-induction" id="markdown-toc-structural-induction">Structural induction</a>        <ul>
          <li><a href="#example" id="markdown-toc-example">Example</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#other-collections" id="markdown-toc-other-collections">Other collections</a>    <ul>
      <li><a href="#sequences" id="markdown-toc-sequences">Sequences</a>        <ul>
          <li><a href="#vectors" id="markdown-toc-vectors">Vectors</a></li>
          <li><a href="#arrays-and-strings" id="markdown-toc-arrays-and-strings">Arrays and Strings</a></li>
          <li><a href="#range" id="markdown-toc-range">Range</a></li>
        </ul>
      </li>
      <li><a href="#sets" id="markdown-toc-sets">Sets</a></li>
      <li><a href="#maps" id="markdown-toc-maps">Maps</a></li>
      <li><a href="#operations-on-iterables" id="markdown-toc-operations-on-iterables">Operations on iterables</a>        <ul>
          <li><a href="#operations-on-sequences" id="markdown-toc-operations-on-sequences">Operations on Sequences</a></li>
          <li><a href="#sorted-and-groupby" id="markdown-toc-sorted-and-groupby">Sorted and groupBy</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#for-expressions" id="markdown-toc-for-expressions">For-Expressions</a>    <ul>
      <li><a href="#querying" id="markdown-toc-querying">Querying</a></li>
      <li><a href="#translation-to-higher-order-functions" id="markdown-toc-translation-to-higher-order-functions">Translation to higher-order functions</a></li>
      <li><a href="#functional-random-generators" id="markdown-toc-functional-random-generators">Functional Random Generators</a>        <ul>
          <li><a href="#definition" id="markdown-toc-definition">Definition</a></li>
          <li><a href="#usage" id="markdown-toc-usage">Usage</a></li>
          <li><a href="#application-random-testing" id="markdown-toc-application-random-testing">Application: Random Testing</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#monads" id="markdown-toc-monads">Monads</a>    <ul>
      <li><a href="#definition-1" id="markdown-toc-definition-1">Definition</a></li>
      <li><a href="#significance-of-the-laws" id="markdown-toc-significance-of-the-laws">Significance of the laws</a></li>
    </ul>
  </li>
  <li><a href="#streams" id="markdown-toc-streams">Streams</a>    <ul>
      <li><a href="#definition-2" id="markdown-toc-definition-2">Definition</a></li>
      <li><a href="#implementation" id="markdown-toc-implementation">Implementation</a></li>
      <li><a href="#lazy-evaluation" id="markdown-toc-lazy-evaluation">Lazy Evaluation</a></li>
      <li><a href="#infinite-streams" id="markdown-toc-infinite-streams">Infinite Streams</a></li>
    </ul>
  </li>
  <li><a href="#functions-and-state" id="markdown-toc-functions-and-state">Functions and State</a>    <ul>
      <li><a href="#stateful-objects" id="markdown-toc-stateful-objects">Stateful Objects</a></li>
      <li><a href="#identity" id="markdown-toc-identity">Identity</a></li>
      <li><a href="#loops" id="markdown-toc-loops">Loops</a></li>
    </ul>
  </li>
  <li><a href="#lisp" id="markdown-toc-lisp">Lisp</a></li>
</ul>

<!-- More -->

<h2 id="books">Books</h2>
<ul>
  <li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">Structure and Interpretation of Computer Programs</a>, Harold Abelson and Gerald Jay Sussman, MIT Press</li>
  <li>Programming in Scala, Martin Odersky, Lex Spoon and Bill Venners, 2nd edition, Artima 2010</li>
</ul>

<h2 id="call-by-name-cbn-call-by-value-cbv">Call-by-name (CBN), call-by-value (CBV)</h2>
<p>Letâ€™s say we have the following function, and that we call it in the following way:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">test</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="nf">test</span><span class="o">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are 2 strategies to solving this: send the function the uncalculated arguments (CBN) or calculate the arguments and <em>then</em> send them to the function (CBV).</p>

<ul>
  <li>CBN and CBV reduce an expression to the same value as long as both evaluations terminate.</li>
  <li>If CBV evaluation of an expression <em>e</em> terminates, then CBN evaluation of <em>e</em> terminates too</li>
  <li>The other direction is not true.</li>
</ul>

<p>Hereâ€™s an example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">first</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
<span class="k">def</span> <span class="nf">loop</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">loop</span>

<span class="nf">first</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">loop</span><span class="o">)</span> <span class="c1">// reduces to 1 under CBN since loop isn't run</span>
<span class="nf">first</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">loop</span><span class="o">)</span> <span class="c1">// does not terminate under CBV</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Scala normally uses CBV, but you can force CBN with the <code class="highlighter-rouge">=&gt;</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">contOne</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">or</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">false</span> <span class="c1">// we need to return y as a value, not a function.</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="value-definitions">Value definitions</h3>
<p>Using <code class="highlighter-rouge">def</code> is CBN, but <code class="highlighter-rouge">val</code> is CBV.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// x refers to 2</span>
<span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="nf">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// y refers to 4, and not the function square(x)</span>

<span class="k">def</span> <span class="nf">x</span> <span class="k">=</span> <span class="n">loop</span> <span class="c1">// OK</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="n">loop</span> <span class="c1">// does not terminate since loop is evaluated</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="blocks-and-lexical-scope">Blocks and lexical scope</h2>
<p>To avoid namespace pollution, we can use nested functions:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sqrt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">sqrtIter</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="nf">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span> <span class="n">guess</span>
        <span class="k">else</span> <span class="nf">sqrtIter</span><span class="o">(</span><span class="nf">improve</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span>

    <span class="k">def</span> <span class="nf">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
        <span class="nf">abs</span><span class="o">(</span><span class="n">guess</span> <span class="o">*</span> <span class="n">guess</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">/</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.001</span>

    <span class="k">def</span> <span class="nf">improve</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
        <span class="o">(</span><span class="n">guess</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">guess</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="nf">sqrtIter</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is done using a block, delimited by <code class="highlighter-rouge">{ ... }</code> braces. The last element of a block is an expression that defines its return value.</p>

<p>The definitions inside a block are only visible from within the block. The block has access to whatâ€™s been defined outside of it, but if it redefines an external definition, the new one will <em>shadow</em> the old one, meaning it will be redefined inside the block.</p>

<h2 id="tail-recursion">Tail recursion</h2>
<p>If a function calls itself as its last action, then the functionâ€™s stack frame can be reused. This is called <em>tail recursion</em>. In practice, this means that recursion is iterative in Scala, and is just as efficient as a loop.</p>

<p>One can require that a function is tail-recursive using a <code class="highlighter-rouge">@tailrec</code> annotation:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nd">@tailrec</span>
<span class="k">def</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>An error is issued if <code class="highlighter-rouge">gcd</code> isnâ€™t tail recursive.</p>

<h2 id="higher-order-functions">Higher-Order Functions</h2>
<p>Functions that take other functions as parameters or that return functions as results are called <em>higher order functions</em>, as opposed to a <em>first order function</em> that acts on simple data types.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1">// Higher order function</span>
<span class="c1">// Corresponds to the sum of f(n) from a to b</span>
<span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="o">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="mi">0</span>
    <span class="k">else</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">+</span> <span class="nf">sum</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

<span class="c1">// Different functions f</span>
<span class="k">def</span> <span class="nf">id</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">def</span> <span class="nf">cube</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// Calling our higher order function</span>
<span class="k">def</span> <span class="nf">sumInts</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">sumCubes</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">cube</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="anonymous-functions">Anonymous functions</h3>
<p>Instead of having to define a <code class="highlighter-rouge">cube</code> and <code class="highlighter-rouge">id</code> function in the example above, we can just write an anonymous function as such:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sumInts</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">sumCubes</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="currying">Currying</h2>
<p>From <a href="https://en.wikipedia.org/wiki/Currying">Wikipedia</a>:</p>

<blockquote>
  <p>Currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument.</p>
</blockquote>

<p>Essentially, with currying we do the following transition:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="nf">f</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// evaluates to 3</span>

<span class="k">def</span> <span class="nf">curry</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="nf">curry</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="c1">// evaluates to x =&gt; (y =&gt; x + y)</span>
<span class="nf">curry</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// evaluates to y =&gt; y + 1</span>
<span class="nf">curry</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="mi">1</span><span class="o">)(</span><span class="mi">2</span><span class="o">)</span> <span class="c1">// evaluates to 3</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Using currying, we can once more improve our <code class="highlighter-rouge">sum</code> function:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span> <span class="c1">// Higher order function</span>
    <span class="k">def</span> <span class="nf">sumF</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="mi">0</span>
        <span class="k">else</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">+</span> <span class="nf">sumF</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
    <span class="n">sumF</span> <span class="c1">// Returns another function</span>
<span class="o">}</span>

<span class="nf">sum</span><span class="o">(</span><span class="n">cube</span><span class="o">)(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span> <span class="c1">// equivalent to sumCubes</span>

<span class="c1">// Syntactic sugar:</span>
<span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">+</span> <span class="nf">sum</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><em>Function application associates to the left</em> so <code class="highlighter-rouge">sum(cube)(1, 10)</code> is equivalent to <code class="highlighter-rouge">(sum(cube))(1, 10)</code>.</p>

<p>The type of <code class="highlighter-rouge">sum</code> is <code class="highlighter-rouge">(Int =&gt; Int) =&gt; (Int, Int) =&gt; Int</code>. This should be read and understood as <code class="highlighter-rouge">(Int =&gt; Int) =&gt; ((Int, Int) =&gt; Int)</code> as <em>functional types associate to the right</em>.</p>

<h2 id="classes-functions-and-data">Classes: functions and data</h2>
<p>In Scala, we use <em>classes</em> to define and create data structures:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">numer</span> <span class="k">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">denom</span> <span class="k">=</span> <span class="n">y</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This introduces two entities:</p>

<ul>
  <li>A new <em>type</em> named <code class="highlighter-rouge">Rational</code></li>
  <li>A <em>constructor</em> <code class="highlighter-rouge">Rational</code> to create elements of this type</li>
</ul>

<h3 id="methods">Methods</h3>
<p>One can go further and also package functions operating on a data abstraction into the data abstraction itself. Such functions are called <em>methods</em>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">numer</span> <span class="k">=</span> <span class="n">x</span> 
    <span class="k">def</span> <span class="nf">denom</span> <span class="k">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> 
        <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
            <span class="n">numer</span> <span class="o">*</span> <span class="nv">that</span><span class="o">.</span><span class="py">denom</span> <span class="o">+</span> <span class="nv">that</span><span class="o">.</span><span class="py">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
            <span class="n">denom</span> <span class="o">*</span> <span class="nv">that</span><span class="o">.</span><span class="py">denom</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">denom</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="identifier">Identifier</h4>

<p>The identifier is alphanumeric (starting with a letter, followed by letters or numbers) xor symbolic (starting with a symbol, followed by other symbols). We can mix them by using an alphanumeric name, an underscore <code class="highlighter-rouge">_</code> and then a symbol.</p>

<p>Small practical trick: to define a <code class="highlighter-rouge">neg</code> function that returns the negation of a <code class="highlighter-rouge">Rational</code>, we can write:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">unary_-</span> <span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(-</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span> <span class="c1">// space between - and : because : shouldn't be a part of the identifier.</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <em>precedence</em> of an operator is determined by its first character, in the following priority (from lowest to highest):</p>

<ul>
  <li>All letters</li>
  <li><code class="highlighter-rouge">|</code></li>
  <li><code class="highlighter-rouge">^</code></li>
  <li><code class="highlighter-rouge">&amp;</code></li>
  <li><code class="highlighter-rouge">&lt; &gt;</code></li>
  <li><code class="highlighter-rouge">= !</code></li>
  <li><code class="highlighter-rouge">:</code></li>
  <li><code class="highlighter-rouge">+ -</code></li>
  <li><code class="highlighter-rouge">* / %</code></li>
  <li>All other symbolic characters</li>
</ul>

<h4 id="infix-notation">Infix notation</h4>
<p>Any method with a parameter can be used like an infix operator:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="n">r</span> <span class="n">add</span> <span class="n">s</span>                            <span class="nv">r</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="n">r</span> <span class="n">less</span> <span class="n">s</span>     <span class="cm">/* in place of */</span>     <span class="nv">r</span><span class="o">.</span><span class="py">less</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="n">r</span> <span class="n">max</span> <span class="n">s</span>                            <span class="nv">r</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="constructors">Constructors</h3>
<p>Scala naturally executes the code in the class body as an implicit constructor, but there is a way to explicitly define more constructors if necessary:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">this</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">this</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">numer</span> <span class="k">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">denom</span> <span class="k">=</span> <span class="n">y</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="data-abstraction">Data abstraction</h3>
<p>We can improve <code class="highlighter-rouge">Rational</code> by making it an irreducible fraction using the GCD:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">def</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">numer</span> <span class="k">=</span> <span class="n">x</span> <span class="o">/</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="c1">// Computed only once with a val</span>
    <span class="k">val</span> <span class="nv">denom</span> <span class="k">=</span> <span class="n">y</span> <span class="o">/</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>

    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are obviously multiple ways of achieving this; the above code just shows one. The ability to choose different implementations of the data without affecting clients is called <em>data abstraction</em>.</p>

<h3 id="assert-and-require">Assert and require</h3>
<p>When calling the constructor, using a denominator of 0 will eventually lead to errors. There are two ways of imposing restrictions on the given constructor arguments:</p>

<ul>
  <li><code class="highlighter-rouge">require</code>, which throws an <code class="highlighter-rouge">IllegalArgumentException</code> if it fails</li>
  <li><code class="highlighter-rouge">assert</code>, which throws an <code class="highlighter-rouge">AssertionError</code> if it fails</li>
</ul>

<p>This reflects a difference in intent:</p>

<ul>
  <li><code class="highlighter-rouge">require</code> is used to enforce a precondition on the caller of a function</li>
  <li><code class="highlighter-rouge">assert</code> is used to check the code of the function itself</li>
</ul>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="nf">require</span><span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"denominator must be non-zero"</span><span class="o">)</span>
    
    <span class="k">val</span> <span class="nv">root</span> <span class="k">=</span> <span class="nf">sqrt</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
    <span class="nf">assert</span><span class="o">(</span><span class="n">root</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="class-hierarchies">Class Hierarchies</h2>

<h3 id="abstract-classes">Abstract classes</h3>
<p>Just like in <a href="/notes-prog/">Java</a>, we can have absctract classes and their implementation:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">IntSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span>
    <span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span> <span class="c1">// Empty binary tree</span>
    <span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Empty</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Empty</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Intset</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span> <span class="c1">// left and right subtree</span>
    <span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">elem</span><span class="o">)</span> <span class="n">left</span> <span class="n">contains</span> <span class="n">x</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">elem</span><span class="o">)</span> <span class="n">right</span> <span class="n">contains</span> <span class="n">x</span>
        <span class="k">else</span> <span class="kc">true</span>

    <span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span> 
        <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">elem</span><span class="o">)</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span> <span class="n">incl</span> <span class="n">x</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">elem</span><span class="o">)</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span>
        <span class="k">else</span> <span class="k">this</span> <span class="c1">// already in the tree, nothing to add</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="terminology">Terminology</h4>
<ul>
  <li><code class="highlighter-rouge">Empty</code> and <code class="highlighter-rouge">NonEmpty</code> both <em>extend</em> the class <code class="highlighter-rouge">IntSet</code></li>
  <li>The definitions of <code class="highlighter-rouge">incl</code> and <code class="highlighter-rouge">contains</code> <em>implement</em> the abstract functions of <code class="highlighter-rouge">IntSet</code></li>
  <li>This implies that the types <code class="highlighter-rouge">Empty</code> and <code class="highlighter-rouge">NonEmpty</code> <em>conform</em> to the type <code class="highlighter-rouge">IntSet</code>, and can be used wherever an <code class="highlighter-rouge">IntSet</code> is required</li>
  <li><code class="highlighter-rouge">IntSet</code> is the superclass of <code class="highlighter-rouge">Empty</code> and <code class="highlighter-rouge">NonEmpty</code></li>
  <li><code class="highlighter-rouge">Empty</code> and <code class="highlighter-rouge">NonEmpty</code> are <em>subclasses</em> of <code class="highlighter-rouge">IntSet</code></li>
  <li>In Scala, any user-defined class extends another class. By default, if no superclass is given, the superclass is <code class="highlighter-rouge">Object</code></li>
  <li>The direct or indirect superclasses are called <em>base classes</em></li>
</ul>

<h4 id="override">Override</h4>
<p>It is possible to <em>redefine</em> an existing, non-abstract definition in a subclass by using <code class="highlighter-rouge">override</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Base</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">foo</span> <span class="k">=</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Sub</span> <span class="k">extends</span> <span class="nc">Base</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">foo</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// You need to use override</span>
    <span class="k">def</span> <span class="nf">bar</span> <span class="k">=</span> <span class="mi">3</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Overriding something that isnâ€™t overrideable yields an error.</p>

<h3 id="traits">Traits</h3>
<p>In Scala, a class can only have one superclass. But sometimes we want several supertypes. To do this we can use <em>traits</em>. Itâ€™s declared just like an abstract class, but using the keyword <code class="highlighter-rouge">trait</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Planar</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// Abstract method as it lacks an implementation</span>
    <span class="k">def</span> <span class="nf">width</span><span class="k">:</span> <span class="kt">Int</span>
    <span class="k">def</span> <span class="nf">surface</span> <span class="k">=</span> <span class="n">height</span> <span class="o">*</span> <span class="n">width</span> <span class="c1">// Concrete method defining a default implementation</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Classes, objects and traits can inherit from at most one class but as arbitrarily many traits.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Square</span> <span class="k">extends</span> <span class="nc">Shape</span> <span class="k">with</span> <span class="nc">Planar</span> <span class="k">with</span> <span class="nc">Movable</span> <span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Traits <strong>cannot</strong> have value parameters, only classes can.</p>

<h3 id="singleton-objects">Singleton objects</h3>
<p>In the <code class="highlighter-rouge">IntSet</code> example, one could argue that there really only is a single empty <code class="highlighter-rouge">IntSet</code>, and that itâ€™s overkill to have the user create many instances of <code class="highlighter-rouge">Empty</code>. Instead we can define a <em>singleton object</em>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Singleton objects are values, so <code class="highlighter-rouge">Empty</code> evaluates to itself.</p>

<h3 id="packages-and-imports">Packages and imports</h3>
<p>Classes and objects are organized in packages, just like in Java.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">package</span> <span class="nn">funprog.example</span>

<span class="k">object</span> <span class="nc">Rational</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>One can now call the object using its full qualified name, or with an import:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">test</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nv">funprog</span><span class="o">.</span><span class="py">example</span><span class="o">.</span><span class="py">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// or</span>
<span class="k">import</span> <span class="nn">funprog.example.Rational</span> <span class="c1">// Import Rational</span>
<span class="k">import</span> <span class="nn">funprog.example.</span><span class="o">{</span><span class="nc">Rational</span><span class="o">,</span> <span class="nc">Hello</span><span class="o">}</span> <span class="c1">// Import both Rational and Hello</span>
<span class="k">import</span> <span class="nn">funprog.example._</span> <span class="c1">// Or import everything in funprog.example</span>

<span class="k">object</span> <span class="nc">test2</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="polymorphism">Polymorphism</h3>
<p>Just <a href="/notes-prog#gÃ©nÃ©ricitÃ©">like in Java</a>, we may wish to have polymorphic types.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">val</span> <span class="nv">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="k">val</span> <span class="nv">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>

    <span class="c1">// val head: T is a legal implementation of head</span>
    <span class="c1">// and so is val tail: List[T]</span>
    <span class="c1">// (they're in the argument list of Cons[T])</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Nil</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Nil.head"</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Nil.tail"</span><span class="o">)</span> <span class="c1">// returns type Nothing</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Type parameters can be used in classes, but also in functions.</p>

<h4 id="type-inference">Type inference</h4>
<p>The Scala compiler can usually deduce the correct type parameters.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">singleton</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elem</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Nil</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

<span class="n">singleton</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// Explicit type definition</span>
<span class="nf">singleton</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// Type inference</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="type-bounds">Type bounds</h4>
<p>We can set the types of parameters as either subtypes or supertypes of something. For instance, a method that takes an <code class="highlighter-rouge">IntSet</code> and returns it if all elements are positive, or throws an error if not, could be implemented as such:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="c1">// Can either return an Empty or a NonEmpty, depending on what it's given:</span>
<span class="k">def</span> <span class="nf">assertAllPos</span><span class="o">[</span><span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">IntSet</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=</span> <span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here, <code class="highlighter-rouge">&lt;: IntSet</code> is an <strong>upper bound</strong> of the type parameter <code class="highlighter-rouge">S</code>. Generally:</p>

<ul>
  <li><code class="highlighter-rouge">S &lt;: T</code> means <code class="highlighter-rouge">S</code> is a <em>subtype</em> of <code class="highlighter-rouge">T</code></li>
  <li><code class="highlighter-rouge">S &gt;: T</code> means <code class="highlighter-rouge">S</code> is a <em>supertype</em> of <code class="highlighter-rouge">T</code></li>
</ul>

<p>Itâ€™s also possible to mix a lower bound with an upper bound:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="o">[</span><span class="kt">S</span> <span class="k">&gt;:</span> <span class="kt">NonEmpty</span> <span class="k">&lt;:</span> <span class="kt">IntSet</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This would restrict <code class="highlighter-rouge">S</code> to any type on the interval between <code class="highlighter-rouge">NonEmpty</code> and <code class="highlighter-rouge">IntSet</code>.</p>

<h4 id="variance">Variance</h4>
<p>Given <code class="highlighter-rouge">NonEmpty &lt;: IntSet</code>, is <code class="highlighter-rouge">List[NonEmpty] &lt;: List[IntSet]</code>? Yes!</p>

<p>Types for which this relationship holds are called <strong>covariant</strong> because their subtyping relationship varies with the type parameter. This makes sense in situations fitting the Liskov Substitution Principle (loosely paraphrased):</p>

<blockquote>
  <p>If <code class="highlighter-rouge">A &lt;: B</code>, then everything one can do with a value of type <code class="highlighter-rouge">B</code> one should also be able to do with a value of type <code class="highlighter-rouge">A</code>.</p>
</blockquote>

<p>In Scala, for instance, <code class="highlighter-rouge">Array</code>s are not covariant.</p>

<p>There are in fact 3 types of variance (given <code class="highlighter-rouge">A &lt;: B</code>):</p>

<ul>
  <li><code class="highlighter-rouge">C[A] &lt;: C[B]</code> means <code class="highlighter-rouge">C</code> is <strong>covariant</strong></li>
  <li><code class="highlighter-rouge">C[A] &gt;: C[B]</code> means <code class="highlighter-rouge">C</code> is <strong>contravariant</strong></li>
  <li>Neither <code class="highlighter-rouge">C[A]</code> nor <code class="highlighter-rouge">C[B]</code> is a subtype of the other means <code class="highlighter-rouge">C</code> is <strong>nonvariant</strong></li>
</ul>

<p>Scala lets you declare the variance of a type by annotating the type parameter:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// C is covariant</span>
<span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// C is contravariant</span>
<span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// C is invariant</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><strong>Functions are contravariant in their argument types, and covariant in their result type.</strong> This allows us to state a very useful and important subtyping relation for functions: <code class="highlighter-rouge">A1 =&gt; B2 &lt;: A2 =&gt; B1</code> <strong>if and only if</strong> <code class="highlighter-rouge">A1 &gt;: A2</code> <strong>and</strong> <code class="highlighter-rouge">B1 &gt;: B2</code>.</p>

<p>Note that, in this case, <code class="highlighter-rouge">A2 =&gt; B2</code> is <strong>unrelated to</strong> <code class="highlighter-rouge">A1 =&gt; B1</code>.</p>

<p>The Scala compiler checks that there are no problematic combinations when compiling a class with variance annotations. Roughly:</p>

<ul>
  <li><em>Covariant</em> type parameters can only appear in method results
    <ul>
      <li>However, <em>covariant</em> type parameters may appear in <em>lower</em> bounds of method type parameters</li>
    </ul>
  </li>
  <li><em>Contravariant</em> type parameters can only appear in method parameters
    <ul>
      <li>However, <em>contravariant</em> type parameters may appear in <em>upper</em> bounds of method type parameters</li>
    </ul>
  </li>
  <li><em>Invariant</em> type parameters can appear anywhere</li>
</ul>

<p>The following code, for instance, is correct as the covariant type parameter is a method result, and the contravariant is a parameter:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">package</span> <span class="nn">scala</span>
<span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-T</span>, <span class="kt">+U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="object-oriented-decomposition">Object oriented decomposition</h3>
<p>Instead of writing external methods that apply to different types of subclasses, we can write the functionality inside the respective classes.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Expr</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">e1</span><span class="o">.</span><span class="py">eval</span> <span class="o">+</span> <span class="nv">e2</span><span class="o">.</span><span class="py">eval</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>But this is problematic if we need to add lots of methods but not add many classes, as weâ€™ll need to define new methods in all the subclasses. Another limitation of OO decomposition is that some non-local operations cannot be encapsulated in the method of a single object.</p>

<p>In these cases, <a href="#pattern-matching">pattern matching</a> may be a better solution.</p>

<h3 id="pattern-matching">Pattern matching</h3>
<p>Pattern matching is a generalization of <code class="highlighter-rouge">switch</code> from C or Java, to class hierarchies. Itâ€™s expressed in Scala using the keyword <code class="highlighter-rouge">match</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span>
    <span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">eval</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">+</span> <span class="nf">eval</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If none of the cases match, a match error exception is thrown.</p>

<p>Patterns are constructed from:</p>

<ul>
  <li>Constructors, e.g. <code class="highlighter-rouge">Number</code>, <code class="highlighter-rouge">Sum</code></li>
  <li>Variables, e.g. <code class="highlighter-rouge">n</code>, <code class="highlighter-rouge">e1</code>, <code class="highlighter-rouge">e2</code></li>
  <li>Wildcard patterns <code class="highlighter-rouge">_</code> (if we donâ€™t care about the argument, we can use <code class="highlighter-rouge">Number(_)</code>)</li>
  <li>Constants, e.g. <code class="highlighter-rouge">1</code>, <code class="highlighter-rouge">true</code> (by convention, start <code class="highlighter-rouge">const</code> with a capital letter).</li>
</ul>

<p>These patterns can be stacked, so we may try to match a <code class="highlighter-rouge">Sum(Number(1), Var(x))</code> for instance. The same variable name can only appear once in a pattern, so <code class="highlighter-rouge">Sum(x, x)</code> is not a legal pattern.</p>

<p>Itâ€™s possible to define the evaluation function as a method of the base trait:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Expr</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span>
        <span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">e1</span><span class="o">.</span><span class="py">eval</span> <span class="o">+</span> <span class="nv">e2</span><span class="o">.</span><span class="py">eval</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Pattern matching is especially useful when what we do is mainly to add methods (not really changing the class hierarchy). Otherwise, if we mainly create sub-classes, then <a href="#object-oriented-decomposition">object-oriented decomposition</a> works best.</p>

<h3 id="case-classes">Case classes</h3>
<p>A <strong>case class</strong> definition is similar to a normal class definition, except that it is preceded by the modifier <code class="highlighter-rouge">case</code>. For example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Epxr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Doing this implicitly defines companion object with <code class="highlighter-rouge">apply</code> methods.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">Number</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Sum</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This way we can just do <code class="highlighter-rouge">Number(1)</code> instead of <code class="highlighter-rouge">new Number(1)</code>.</p>

<h2 id="lists">Lists</h2>
<p>There are two important differences between lists and arrays:</p>

<ul>
  <li>Lists are immutable â€” the elements of a list cannot be changed.</li>
  <li>Lists are recursive (linked lists), while arrays are flat.</li>
</ul>

<p>Like arrays, lists are <em>homogeneous</em>: the elements of a list must all have the same type.</p>

<h3 id="list-constructors">List constructors</h3>
<p>A bit of syntactic sugar: you can construct new lists using the construction operation <code class="highlighter-rouge">::</code> (pronounced <em>cons</em>).</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="n">fruit</span> <span class="k">=</span> <span class="s">"apples"</span> <span class="o">::</span> <span class="s">"oranges"</span> <span class="o">::</span> <span class="s">"pears"</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="nc">List</span><span class="o">(</span><span class="s">"apples"</span><span class="o">,</span> <span class="s">"oranges"</span><span class="o">,</span> <span class="s">"pears"</span><span class="o">)</span> <span class="c1">// Equivalent</span>
<span class="nc">Nil</span><span class="o">.::(</span><span class="s">"pears"</span><span class="o">).::(</span><span class="s">"oranges"</span><span class="o">).::(</span><span class="s">"apples"</span><span class="o">)</span> <span class="c1">// Also equivalent</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>As a convention, operators ending in <code class="highlighter-rouge">:</code> associate to the right, and are calls on the right-hand operand.</p>

<h3 id="list-patterns">List patterns</h3>
<p>It is also possible to decompose lists with pattern matching. Examples:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="nc">Nil</span> <span class="c1">// Nil constant</span>
<span class="n">p</span> <span class="o">::</span> <span class="n">ps</span> <span class="c1">// A pattern that matches a list with a head matching p and a tail matching ps</span>
<span class="nc">List</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="o">...,</span> <span class="n">pn</span><span class="o">)</span> <span class="c1">// Same as p1 :: ... :: pn :: Nil</span>
<span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="n">xs</span> <span class="c1">// Lists that start with 1 then 2</span>
<span class="n">x</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="c1">// Lists of length 1</span>
<span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// Same as x :: Nil</span>
<span class="nc">List</span><span class="o">()</span> <span class="c1">// Empty list, same as Nil</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">2</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="c1">// A list that contains as only element another list that starts with 2</span>

<span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="nc">List</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="o">::</span> <span class="n">zs</span> <span class="c1">// Lists of length &gt;= 3 with a list of 2 elements in 3rd pos</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can do a really short insertion sort this way (but one that runs in O(n<sup>2</sup>))</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
    <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">insert</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="nf">isort</span><span class="o">(</span><span class="n">ys</span><span class="o">))</span> <span class="c1">// y is head, ys is tail</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> 
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="list-methods">List methods</h3>

<h4 id="sublists-and-element-access">Sublists and element access</h4>
<ul>
  <li><code class="highlighter-rouge">xs.length</code>: The number of elements of <code class="highlighter-rouge">xs</code></li>
  <li><code class="highlighter-rouge">xs.last</code>: The listâ€™s last elemeent, exception if <code class="highlighter-rouge">xs</code> is empty</li>
  <li><code class="highlighter-rouge">xs.init</code>: A list consisting of all elements of <code class="highlighter-rouge">xs</code> except the last one, except if <code class="highlighter-rouge">xs</code> is empty.</li>
  <li><code class="highlighter-rouge">xs take n</code>: A list consisting of the first <code class="highlighter-rouge">n</code> elements of <code class="highlighter-rouge">xs</code> or <code class="highlighter-rouge">xs</code> itself if itâ€™s shorter than <code class="highlighter-rouge">n</code></li>
  <li><code class="highlighter-rouge">xs drop n</code>: The rest of the collection after taking <code class="highlighter-rouge">n</code> elements.</li>
  <li><code class="highlighter-rouge">xs(n)</code>: The element of <code class="highlighter-rouge">xs</code> at index <code class="highlighter-rouge">n</code></li>
</ul>

<h4 id="creating-new-lists">Creating new lists</h4>
<ul>
  <li><code class="highlighter-rouge">xs ++ ys</code> or <code class="highlighter-rouge">xs ::: ys</code>: Concatenation of <code class="highlighter-rouge">xs</code> and <code class="highlighter-rouge">ys</code></li>
  <li><code class="highlighter-rouge">xs.reverse</code>: The list containing the elements of <code class="highlighter-rouge">xs</code> in reversed order</li>
  <li><code class="highlighter-rouge">xs updated (n, x)</code>: The list containing the same elements as <code class="highlighter-rouge">xs</code>, except at index <code class="highlighter-rouge">n</code> where it contains <code class="highlighter-rouge">x</code>.</li>
</ul>

<h4 id="finding-elements">Finding elements</h4>
<ul>
  <li><code class="highlighter-rouge">xs indexOf x</code>: The index of the first elemen in <code class="highlighter-rouge">xs</code> matching <code class="highlighter-rouge">x</code>, or <code class="highlighter-rouge">-1</code> if <code class="highlighter-rouge">x</code> does not appear in <code class="highlighter-rouge">xs</code></li>
  <li><code class="highlighter-rouge">xs contains x</code>: same as <code class="highlighter-rouge">xs indexOf x &gt;= 0</code></li>
</ul>

<!--
### Pairs and tuples
Not too interesting
-->

<h3 id="higher-order-list-functions">Higher-order list functions</h3>
<p>These are functions that work on lists and take another function as argument. The above examples often have similar structures, and we can identify patterns:</p>

<ul>
  <li>transforming each element in a list in a certain way</li>
  <li>retrieving a list of all elements satisfying a criterion</li>
  <li>combining the elements of a list using an operator</li>
</ul>

<p>Since Scala is a functional language, we can write generic function that implement these patterns using <a href="#higher-order-functions">higher-order functions</a>.</p>

<h4 id="map">Map</h4>
<p>The actual implementation of <code class="highlighter-rouge">map</code> is a bit more complicated for performance reasons, but follows something allong the lines of:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="k">this</span>
        <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="nv">xs</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Multiplies all elements of the list by a factor</span>
<span class="k">def</span> <span class="nf">scaleList</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">xs</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factor</span><span class="o">)</span>

<span class="c1">// Squares all elements of the list</span>
<span class="k">def</span> <span class="nf">squareList</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
    <span class="n">xs</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="filter">Filter</h4>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="k">this</span>
        <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> 
            <span class="nf">if</span> <span class="o">(</span><span class="nf">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nv">xs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
            <span class="k">else</span> <span class="nv">xs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">positiveElems</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are a few other methods that extract sublists based on a predicate:</p>

<ul>
  <li><code class="highlighter-rouge">xs filterNot p</code>: Same as <code class="highlighter-rouge">xs filter (x &gt;= !p(x))</code></li>
  <li><code class="highlighter-rouge">xs partition p</code>: Same as <code class="highlighter-rouge">(xs filter p, xs filterNot p)</code></li>
  <li><code class="highlighter-rouge">xs takeWhile p</code>: The longest prefix of list <code class="highlighter-rouge">xs</code> consisting of elements that all satisfy the predicate <code class="highlighter-rouge">p</code></li>
  <li><code class="highlighter-rouge">xs dropWhile p</code>: The remainder of the list <code class="highlighter-rouge">xs</code> after any leading elements satisfying <code class="highlighter-rouge">p</code> have been removed</li>
  <li><code class="highlighter-rouge">xs span p</code>: Same as <code class="highlighter-rouge">(xs takeWhile p, xs dropWhile p)</code></li>
</ul>

<h4 id="reduce">Reduce</h4>
<p>A reduction of a list consist of a combination of the elements using a given operator (i.e. summing or multiplying all the elements).</p>

<p>For certain operations, the order matters, and there are therefore different  orders in which the reduction can be made.</p>

<p>One such function is <code class="highlighter-rouge">foldLeft</code>. It goes from left to right and  takes an <em>accumulator</em> <code class="highlighter-rouge">z</code> as an additional parameter, which is returned when <code class="highlighter-rouge">foldLeft</code> is called on an empty list. For instance</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="c1">// The general notation is:</span>
<span class="c1">// (List(x1, ..., xn) foldLeft z)(op)</span>
<span class="c1">// Which returns:</span>
<span class="c1">// ((z op x1) op ...) op xn</span>

<span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span> <span class="n">foldLeft</span> <span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">product</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span> <span class="n">foldLeft</span> <span class="mi">1</span><span class="o">)(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><em>Note:</em> The <code class="highlighter-rouge">(_ + _)</code> notation is equivalent to <code class="highlighter-rouge">((x, y) =&gt; x + y)</code>.</p>

<p><code class="highlighter-rouge">foldLeft</code> and <code class="highlighter-rouge">reduceLeft</code> (same as <code class="highlighter-rouge">foldLeft</code> but without the <code class="highlighter-rouge">z</code> argument) could be implemented as follows:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">reduceLeft</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Nil</span>     <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Nil.reduceLeft"</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">xs</span> <span class="n">foldLeft</span> <span class="n">x</span><span class="o">)(</span><span class="n">op</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">foldLeft</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">U</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Nil</span>     <span class="k">=&gt;</span> <span class="n">z</span>
        <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">xs</span> <span class="n">foldLeft</span> <span class="nf">op</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">x</span><span class="o">))(</span><span class="n">op</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">foldRight</code> and <code class="highlighter-rouge">reduceRight</code> follow similar implementations but put the parentheses to the right.</p>

<h2 id="implicit-parameters">Implicit parameters</h2>
<p>If we wanted to generalize an implementation of merge sort to work on more types than just <code class="highlighter-rouge">Int</code>s, we could rewrite it as such:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">msort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">lt</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
            <span class="nf">case</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
            <span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nf">if</span> <span class="o">(</span><span class="nf">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
                <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
        <span class="nf">merge</span><span class="o">(</span><span class="nf">msort</span><span class="o">(</span><span class="n">fst</span><span class="o">)(</span><span class="n">lt</span><span class="o">),</span> <span class="nf">msort</span><span class="o">(</span><span class="n">snd</span><span class="o">)(</span><span class="n">lt</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="nf">msort</span><span class="o">(</span><span class="n">nums</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">// Generalisation:</span>
<span class="k">val</span> <span class="nv">fruits</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"pineapple"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">)</span>
<span class="nf">msort</span><span class="o">(</span><span class="n">fruits</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">#</span> <span class="n">lexicographical</span> <span class="n">order</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>As a tiny note, itâ€™s usually best to put the function value as the last parameter of a function, because that makes it more likely that the compiler can infer the types of the arguments of the function. E.g. we have written <code class="highlighter-rouge">(x, y) =&gt; x &lt; y)</code> instead of <code class="highlighter-rouge">(x: Int, y: Int) =&gt; x &lt; y</code>.</p>

<p>How can we make this code nicer? We can use the <code class="highlighter-rouge">Ordering</code> type to represent the function, and make it an implicit parameter:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">msort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
            <span class="nf">case</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
            <span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nf">if</span> <span class="o">(</span><span class="nv">ord</span><span class="o">.</span><span class="py">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
                <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
        <span class="nf">merge</span><span class="o">(</span><span class="nf">msort</span><span class="o">(</span><span class="n">fst</span><span class="o">),</span> <span class="nf">msort</span><span class="o">(</span><span class="n">snd</span><span class="o">))</span> <span class="c1">// ord is visible at this scope</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="nf">msort</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>

<span class="c1">// Generalisation:</span>
<span class="k">val</span> <span class="nv">fruits</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"pineapple"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">)</span>
<span class="nf">msort</span><span class="o">(</span><span class="n">fruits</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Using the <code class="highlighter-rouge">Ordering[T]</code> type means using the predefined default ordering, which we donâ€™t even need to supply to <code class="highlighter-rouge">msort</code>, namely <code class="highlighter-rouge">Ordering.String</code> and <code class="highlighter-rouge">Ordering.Int</code>. See notes on <a href="/notes-prog/#ordre-en-java">ordering in Java</a>.</p>

<p>When you write an implicit parameter, and you donâ€™t write an actual argument that matches that parameter, the compiler will figure out the right implicit to pass, based on the demanded type.</p>

<h3 id="rules-for-implicit-parameters">Rules for implicit parameters</h3>
<p>Say that a function takes an implicit parameter of type <code class="highlighter-rouge">T</code>. The compiler will search for an implicit definition that:</p>

<ul>
  <li>is marked <code class="highlighter-rouge">implicit</code></li>
  <li>has a type compatible with <code class="highlighter-rouge">T</code></li>
  <li>is visible at the scope of the function call (see line 13 above), or is defined in a companion object associated with <code class="highlighter-rouge">T</code></li>
</ul>

<p>If thereâ€™s a single (most specific) definition, it will be taken as actual argument for the implicit parameter. Otherwise, itâ€™s an error.</p>

<p>For instance, at line 13, the compiler inserts the <code class="highlighter-rouge">ord</code> parameter of <code class="highlighter-rouge">msort</code></p>

<h2 id="proof-techniques">Proof techniques</h2>
<p>Before we can prove anything, weâ€™ll just assert that pure functional languages have a property called <em>referential transparency</em>, since they donâ€™t have side effects. This means that we can use reduction steps as equalities to some part of a term.</p>

<h3 id="structural-induction">Structural induction</h3>
<p>The principle of structural induction is analogous to natural induction.</p>

<p>To prove a property <code class="highlighter-rouge">P(xs)</code> for all lists <code class="highlighter-rouge">xs</code>:</p>

<ul>
  <li><strong>Base case</strong>: Show that <code class="highlighter-rouge">P(Nil)</code> holds</li>
  <li><strong>Induction step</strong>: for a list <code class="highlighter-rouge">xs</code>and some element <code class="highlighter-rouge">x</code>, show that if <code class="highlighter-rouge">P(xs)</code> holds then <code class="highlighter-rouge">P(x :: xs)</code> also holds.</li>
</ul>

<p>Instead of constructing numbers and adding 1, we construct lists from <code class="highlighter-rouge">Nil</code> and add one element.</p>

<h4 id="example">Example</h4>
<p>Letâ€™s show that, for lists <code class="highlighter-rouge">xs</code>, <code class="highlighter-rouge">ys</code> and <code class="highlighter-rouge">zs</code>, <code class="highlighter-rouge">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</code>.</p>

<p>Weâ€™ll use the two following axioms of <code class="highlighter-rouge">++</code> to prove this:</p>

<ol>
  <li><code class="highlighter-rouge">Nil ++ ys = ys</code></li>
  <li><code class="highlighter-rouge">(x :: xs1) ++ ys = x :: (xs1 ++ ys)</code></li>
</ol>

<p>Letâ€™s solve it. First, the base case:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="c1">// Left-hand side:</span>
<span class="o">(</span><span class="nc">Nil</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span> <span class="k">=</span> <span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span> <span class="c1">// by the 1st clause of ++</span>

<span class="c1">// Right-hand side:</span>
<span class="nc">Nil</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span> <span class="c1">// by the 1st clause of ++</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now, onto the induction step:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="c1">// Left-hand side:</span>
<span class="o">((</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">))</span> <span class="o">++</span> <span class="n">zs</span> <span class="c1">// by 2nd clause of ++</span>
                        <span class="k">=</span> <span class="n">x</span> <span class="o">::</span> <span class="o">((</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span> <span class="c1">// by 2nd clause of ++</span>
                        <span class="k">=</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">))</span> <span class="c1">// by induction hypothesis</span>

<span class="c1">// Right-hand side:</span>
<span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">))</span> <span class="c1">// by 2nd clause of ++</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>So this property is established.</p>

<h2 id="other-collections">Other collections</h2>
<p>All the collections weâ€™ll study are <em>immutable</em>. The collection hierarchy is as follows:</p>

<ul>
  <li><code class="highlighter-rouge">Iterable</code>
    <ul>
      <li><code class="highlighter-rouge">Seq</code>
        <ul>
          <li><code class="highlighter-rouge">List</code></li>
          <li><code class="highlighter-rouge">Vector</code></li>
          <li><code class="highlighter-rouge">Range</code></li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">Set</code></li>
      <li><code class="highlighter-rouge">Map</code></li>
    </ul>
  </li>
</ul>

<h3 id="sequences">Sequences</h3>

<h4 id="vectors">Vectors</h4>
<p>A <code class="highlighter-rouge">Vector</code> of up to 32 elements is just an array, but once it grows past that bound, its representation changes; it becomes a <code class="highlighter-rouge">Vector</code> of 32 pointers to <code class="highlighter-rouge">Vector</code>s (that follow the same rule once they outgrow 32).</p>

<p>Unlike lists, which are linear (access to the end of the list is slower than the start), random access to a certain element in a vector can be done in time log<sub>32</sub>(n).</p>

<p>Vectors are fairly good for bulk operations that traverse a sequence, such as a <a href="#map">map</a>, <a href="#reduce">fold</a> or <a href="#filter">filter</a>. Also, 32 is a good number since it corresponds to a cache line.</p>

<p>Vectors are created analogously to lists:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">88</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">people</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"James"</span><span class="o">,</span> <span class="s">"Peter"</span><span class="o">)</span>

<span class="c1">// Instead of x :: xs we have:</span>
<span class="n">x</span> <span class="o">+:</span> <span class="n">xs</span> <span class="c1">// create a new vector with leading element x, followed by xs</span>
<span class="n">xs</span> <span class="o">:+</span> <span class="n">x</span> <span class="c1">// create a new vector with trailing element x, preceded by xs</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Creating new vectors with these <code class="highlighter-rouge">:+</code> and <code class="highlighter-rouge">+:</code> operators works by adding a vector, and recreating parent vectors with pointers to the existing ones. Doing this preserves immutability while still being fairly efficient (log<sub>32</sub>(n)).</p>

<h4 id="arrays-and-strings">Arrays and Strings</h4>
<p>They come from Java, so they canâ€™t be subclasses of <code class="highlighter-rouge">Iterable</code>, but they still work just as if they were subclasses of <code class="highlighter-rouge">Seq</code>, and we can apply all the same operations.</p>

<h4 id="range">Range</h4>
<p>Represents a sequence of evenly spaced integers.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">r</span><span class="k">:</span> <span class="kt">Range</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">5</span> <span class="c1">// 1, 2, 3, 4</span>
<span class="k">val</span> <span class="nv">s</span><span class="k">:</span> <span class="kt">Range</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span> <span class="c1">// 1, 2, 3, 4, 5</span>
<span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span> <span class="n">by</span> <span class="mi">3</span> <span class="c1">// 1, 4, 7, 10</span>
<span class="mi">6</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">by</span> <span class="o">-</span><span class="mi">2</span> <span class="c1">// 6, 4, 2</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Ranges are represented as three fields: lower bounds, upper bounds and step value.</p>

<h3 id="sets">Sets</h3>
<p>Sets are another basic abstraction in the Scala collections. It is written analogously to a sequence:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"pear"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">6</span><span class="o">).</span><span class="py">toSet</span>

<span class="c1">// Most operations on sequences are also available on sets:</span>
<span class="n">s</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// Set(3, 4, 5, 6, 7, 8)</span>
<span class="n">fruit</span> <span class="nf">filter</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">startsWith</span> <span class="o">==</span> <span class="s">"app"</span><span class="o">)</span> <span class="c1">// Set("apple")</span>
<span class="nv">s</span><span class="o">.</span><span class="py">nonEmpty</span> <span class="c1">// true</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The principal differences between sets and sequences are:</p>

<ol>
  <li>Sets are <strong>unordered</strong>: the elements of a set do not have a predefined order in which they appear in the set.</li>
  <li>Sets <strong>do not have duplicate elements</strong>.</li>
  <li>The <strong>fundamental operation</strong> on sets is <code class="highlighter-rouge">contains</code>.</li>
</ol>

<h3 id="maps">Maps</h3>
<p>Another fundamental collection type is the <code class="highlighter-rouge">map</code>. A map of type <code class="highlighter-rouge">Map[Key, Value]</code> is a data structure associating keys with values.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">romanNumerals</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"I"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"V"</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">"X"</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">capitalOfCountry</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"US"</span> <span class="o">-&gt;</span> <span class="s">"Washington"</span><span class="o">,</span> <span class="s">"Switzerland"</span> <span class="o">-&gt;</span> <span class="s">"Bern"</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Theyâ€™re both an <code class="highlighter-rouge">Iterable</code> and a function, as <code class="highlighter-rouge">Map[Key, Value]</code> also extends the function type <code class="highlighter-rouge">Key =&gt; Value</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="nf">capitalOfCountry</span><span class="o">(</span><span class="s">"US"</span><span class="o">)</span> <span class="c1">// "Washington"</span>
<span class="nf">capitalOfCountry</span><span class="o">(</span><span class="s">"Andorra"</span><span class="o">)</span> <span class="c1">// NoSuchElementException: key not found: Andorra</span>

<span class="n">capitalOfCountry</span> <span class="n">get</span> <span class="s">"Andorra"</span> <span class="c1">// None</span>
<span class="n">capitalOfCountry</span> <span class="n">get</span> <span class="s">"US"</span> <span class="c1">// Some("Washington")</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Both the <code class="highlighter-rouge">None</code> and the <code class="highlighter-rouge">Some</code> are subclasses of the <code class="highlighter-rouge">Option</code> type.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Some</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">object</span> <span class="nc">None</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This means that we can do pattern matching, or use the <code class="highlighter-rouge">withDefaultValue</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">showCapital</span><span class="o">(</span><span class="n">country</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nv">capitalOfCountry</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">country</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">capital</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">capital</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="s">"missing data"</span>
<span class="o">}</span>

<span class="n">capitalOfCountry</span> <span class="n">get</span> <span class="s">"US"</span> <span class="c1">// "Washington"</span>
<span class="n">capitalOfCountry</span> <span class="n">get</span> <span class="s">"Andorra"</span> <span class="c1">// "missing data"</span>

<span class="k">val</span> <span class="nv">cap1</span> <span class="k">=</span> <span class="n">capitalOfCountry</span> <span class="n">withDefaultValue</span> <span class="s">"Unknown"</span>
<span class="nf">cap1</span><span class="o">(</span><span class="s">"Andorra"</span><span class="o">)</span>  <span class="c1">// "Unknown"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="operations-on-iterables">Operations on iterables</h3>

<h4 id="operations-on-sequences">Operations on Sequences</h4>
<ul>
  <li><code class="highlighter-rouge">xs exists p</code>: <code class="highlighter-rouge">true</code> if there is an element <code class="highlighter-rouge">x</code> of <code class="highlighter-rouge">xs</code> such that <code class="highlighter-rouge">p(x)</code> holds, <code class="highlighter-rouge">false</code> otherwise.</li>
  <li><code class="highlighter-rouge">xs forall p</code>: <code class="highlighter-rouge">true</code> if <code class="highlighter-rouge">p(x)</code> holds for all elements <code class="highlighter-rouge">x</code> of <code class="highlighter-rouge">xs</code>, <code class="highlighter-rouge">false</code> otherwise</li>
  <li><code class="highlighter-rouge">xs zip ys</code>: A sequence of pairs drawn from corresponding elements of sequences <code class="highlighter-rouge">xs</code> and <code class="highlighter-rouge">ys</code></li>
  <li><code class="highlighter-rouge">xs.unzip</code>: Splits a sequences of pairs <code class="highlighter-rouge">xs</code> into two sequences consisting of the first and second halves of all pairs</li>
  <li><code class="highlighter-rouge">xs.flatMap f</code>: Applies collection-valued function <code class="highlighter-rouge">f</code> to all elements of <code class="highlighter-rouge">xs</code> to all elements the results.</li>
  <li><code class="highlighter-rouge">xs.sum</code>: The sum of all elements of this numeric collection</li>
  <li><code class="highlighter-rouge">xs.product</code>: The product of all elements of this numeric collection</li>
  <li><code class="highlighter-rouge">xs.max</code>: The maximum of all elements of this numeric collection (an <code class="highlighter-rouge">Ordering</code> must exist)</li>
  <li><code class="highlighter-rouge">xs.min</code>: The minimum of all elements of this numeric collection (an <code class="highlighter-rouge">Ordering</code> must exist)</li>
</ul>

<p>A few examples below.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="c1">// List all combinations of numbers x and y</span>
<span class="c1">// where x is drawn from 1..M</span>
<span class="c1">// and y is drawn from 1..N</span>
<span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">M</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">N</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span> 
    <span class="c1">// &gt; Vector((1, 1), (1, 2), ..., (2, 1), (2, 2), ...)</span>

<span class="c1">// Scalar product of two vectors</span>
<span class="k">def</span> <span class="nf">scalarProduct</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
    <span class="o">(</span><span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">xy</span> <span class="k">=</span> <span class="nv">xy</span><span class="o">.</span><span class="py">_1</span> <span class="o">*</span> <span class="nv">xy</span><span class="o">.</span><span class="py">_2</span><span class="o">).</span><span class="py">sum</span>

<span class="c1">// Or using pattern matching function value</span>
<span class="c1">// Note: Generally, {case p1 =&gt; e1 ...} is </span>
<span class="c1">// equivalent to x =&gt; x match {case p =&gt; e1 ...}</span>
<span class="k">def</span> <span class="nf">scalarProduct</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
    <span class="o">(</span><span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">).</span><span class="py">map</span><span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">}.</span><span class="py">sum</span>

<span class="k">def</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="o">(</span><span class="mi">2</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">forall</span> <span class="o">(</span><span class="n">d</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="sorted-and-groupby">Sorted and groupBy</h4>
<p>To sort elements, we can use either <code class="highlighter-rouge">sortWith</code> or <code class="highlighter-rouge">sorted</code> as below.</p>

<p><code class="highlighter-rouge">groupBy</code> is available on Scala collections. It partitions a collection into a map of collections according to a discriminator function <code class="highlighter-rouge">f</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"pear"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"pineapple"</span><span class="o">)</span>
<span class="n">fruit</span> <span class="nf">sortWith</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">length</span> <span class="o">&lt;</span> <span class="nv">_</span><span class="o">.</span><span class="py">length</span><span class="o">)</span> <span class="c1">// List("pear", "apple", "orange", "pineapple")</span>
<span class="nv">fruit</span><span class="o">.</span><span class="py">sorted</span> <span class="c1">// List("apple", "orange", "pear", "pineapple")</span>

<span class="n">fruit</span> <span class="nf">groupBy</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">head</span><span class="o">)</span> <span class="c1">// &gt; Map(p -&gt; List(pear, pineapple),</span>
                       <span class="c1">// |     a -&gt; List(apple),</span>
                       <span class="c1">// |     o -&gt; List(orange))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="for-expressions">For-Expressions</h2>
<p>Higher order functions and collections in functional languages often replace loops in imperative languages. Programs using many nested loops can therefore often be replaced by a combination of higher order functions.</p>

<p>For example, letâ€™s say we want to find all <em>1 &lt; i &lt; j &lt; n</em> for which <em>i + j</em> is prime. This would take two loops in an imperative language, but in Scala we can â€œjustâ€ write:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span>
           <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">pair</span> <span class="k">=&gt;</span> <span class="nf">isPrime</span><span class="o">(</span><span class="nv">pair</span><span class="o">.</span><span class="py">_1</span> <span class="o">+</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_2</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is hard to read, so we can use a for expression, of the form</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nf">for</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="n">e</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Where <code class="highlighter-rouge">s</code> is a sequence of <em>generators</em> and <em>filters</em>, and <code class="highlighter-rouge">e</code> is an expression whose value is returned by an iteration.</p>

<p>Instead of <code class="highlighter-rouge">( s )</code>, braces <code class="highlighter-rouge">{ s }</code> can also be used, and then the sequence of generators and filters can be written on multiple lines without requiring semicolons.</p>

<p>Using a for expression, we can rewrite our previous example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">for</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">n</span>
    <span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">i</span>
    <span class="k">if</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>

<span class="c1">// Scalar product</span>
<span class="o">(</span><span class="nf">for</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">).</span><span class="py">sum</span>
</pre></td></tr></tbody></table></code></pre></figure>

<hr />

<p><em>The rest of these notes correspond to the</em> Functional Pogram Design in Scala <em>course</em></p>

<hr />

<h3 id="querying">Querying</h3>
<p>Letâ€™s say we want to query the number of authors who have written two or more books.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="o">{</span>   <span class="k">for</span> <span class="o">{</span>
        <span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span>
        <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span>
        <span class="k">if</span> <span class="nv">b1</span><span class="o">.</span><span class="py">title</span> <span class="o">&lt;</span> <span class="nv">b2</span><span class="o">.</span><span class="py">title</span> <span class="c1">// Prevent duplicates by using lexicographical order</span>
                               <span class="c1">// We could also use if b1 != b2, but this would</span>
                               <span class="c1">// match for the same pair of books twice.</span>
        <span class="n">a1</span> <span class="k">&lt;-</span> <span class="nv">b1</span><span class="o">.</span><span class="py">authors</span>
        <span class="n">a2</span> <span class="k">&lt;-</span> <span class="nv">b2</span><span class="o">.</span><span class="py">authors</span>
        <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">a1</span>
<span class="o">}.</span><span class="py">distinct</span> <span class="c1">// another way to prevent duplicates</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The first mechanism to prevent duplicates is to compare titles using lexicographical order instead of a simple <code class="highlighter-rouge">!=</code>. Another trick is to use <code class="highlighter-rouge">.distinct</code>, which is like a <code class="highlighter-rouge">.toSet</code>.</p>

<h3 id="translation-to-higher-order-functions">Translation to higher-order functions</h3>
<p>The syntax of for is closely related to the higher-order functions <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code>, and <code class="highlighter-rouge">filter</code>.  These functions could be implemented as such:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="k">yield</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">filter</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="k">if</span> <span class="nf">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">x</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In reality, the translation is done the other way by the compiler. How do we translate for-expressions to these higher-order functions?</p>

<p>Below is the for expression and its translation at the next line.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="c1">// For-expression</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">e1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">e2</span>
<span class="c1">// Desugared</span>
<span class="nv">e1</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">e2</span><span class="o">)</span>


<span class="c1">// Let s be a (potentially empty) sequence of generators and filters</span>
<span class="c1">// For-expression</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">e1</span> <span class="k">if</span> <span class="n">f</span><span class="o">;</span> <span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="n">e2</span>
<span class="c1">// Desugared</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="nv">e1</span><span class="o">.</span><span class="py">withFilter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">);</span> <span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="n">e2</span>

<span class="c1">// For-expression</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">e1</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">e2</span><span class="o">;</span> <span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="n">e3</span>
<span class="c1">// Desugared</span>
<span class="nv">e1</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">for</span> <span class="o">(</span><span class="n">y</span> <span class="k">&lt;-</span> <span class="n">e2</span><span class="o">;</span> <span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="n">e3</span><span class="o">)</span>

<span class="c1">// For-expression</span>
<span class="k">for</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">n</span>
    <span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">i</span>
    <span class="k">if</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
<span class="c1">// Desugared</span>
<span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">).</span><span class="py">withFilter</span><span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">))</span>
               <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>See more examples of desugared for-expressions in <a href="https://gist.github.com/MaximeKjaer/77470b143207f21f6a68317600e410cb">this gist</a>.</p>

<p>Interestingly, the translation of <code class="highlighter-rouge">for</code> is not limited to lists, sequences, or collections. Since itâ€™s based solely on the presence of the methods <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">withFilter</code>, we can simply redefine these methods for our own types.</p>

<p>If, for instance, we were to write a database supporting these methods, then as long as these methods are defined, we can use the <code class="highlighter-rouge">for</code> syntax for querying the database.</p>

<h3 id="functional-random-generators">Functional Random Generators</h3>

<h4 id="definition">Definition</h4>
<p>We could also define these three methods (<code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">withFilter</code>) for a random value generator. Letâ€™s define it as such:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">integers</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">rand</span> <span class="k">=</span> <span class="k">new</span> <span class="nv">java</span><span class="o">.</span><span class="py">util</span><span class="o">.</span><span class="py">Random</span>
    <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nv">rand</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">booleans</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nv">integers</span><span class="o">.</span><span class="py">generate</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">pairs</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="nv">integers</span><span class="o">.</span><span class="py">generate</span><span class="o">,</span> <span class="nv">integers</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>But we can streamline this:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">booleans</span> <span class="k">=</span> <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">integers</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">pairs</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">u</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
    <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">t</span>
    <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">u</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Which expands to:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">booleans</span> <span class="k">=</span> <span class="n">integers</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">pairs</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">u</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">t</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="nf">map</span> <span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We therefore need to define <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code> on the <code class="highlighter-rouge">Generator</code> class.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
    <span class="n">self</span> <span class="k">=&gt;</span> <span class="c1">// an alias for "this"</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="k">:</span> <span class="kt">T</span>

    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nv">self</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span> <span class="c1">// we use self instead of this to reference the trait and not the method</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">])</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nv">self</span><span class="o">.</span><span class="py">generate</span><span class="o">).</span><span class="py">generate</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Our example now expands to:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">booleans</span> <span class="k">=</span> <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">integers</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">val</span> <span class="nv">booleans</span> <span class="k">=</span> <span class="n">integers</span> <span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">}</span>
<span class="k">val</span> <span class="nv">booleans</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)(</span><span class="nv">integers</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">val</span> <span class="nv">booleans</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nv">integers</span><span class="o">.</span><span class="py">generate</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can also define other types of generators:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">single</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="n">x</span> <span class="c1">// identity</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">choose</span><span class="o">(</span><span class="n">lo</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">hi</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">integers</span><span class="o">)</span> <span class="k">yield</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">x</span> <span class="o">%</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">oneOf</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// T* means you can give it as many arguments as you want</span>
    <span class="nf">for</span> <span class="o">(</span><span class="n">idx</span> <span class="k">&lt;-</span> <span class="nf">choose</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span><span class="o">))</span> <span class="k">yield</span> <span class="nf">xs</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="usage">Usage</h4>
<p>Having created a generator, we can use this as a building block for more complex expressions:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">lists</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
    <span class="n">isEmpty</span> <span class="k">&lt;-</span> <span class="n">booleans</span>
    <span class="n">list</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">emptyLists</span> <span class="k">else</span> <span class="n">nonEmptyLists</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">list</span>

<span class="k">def</span> <span class="nf">emptyListst</span> <span class="k">=</span> <span class="nf">single</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">nonEmptyLists</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
    <span class="n">head</span> <span class="k">&lt;-</span> <span class="n">integers</span>
    <span class="n">tail</span> <span class="k">&lt;-</span> <span class="n">lists</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="application-random-testing">Application: Random Testing</h4>
<p>Generators are especially useful for random testing. Obviously itâ€™s hard to predict the result of any random input without running the program, but what we can do is test <em>postconditions</em>, which are properties of the expected result.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">test</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">numTimes</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span><span class="o">)(</span><span class="n">test</span> <span class="n">T</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">numTimes</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">value</span> <span class="k">=</span> <span class="nv">g</span><span class="o">.</span><span class="py">generate</span>
        <span class="nf">assert</span><span class="o">(</span><span class="nf">test</span><span class="o">(</span><span class="n">value</span><span class="o">),</span> <span class="s">"test failed for "</span><span class="o">+</span><span class="n">value</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"Passed "</span> <span class="o">+</span> <span class="n">numTimes</span> <span class="o">+</span> <span class="s">" tests"</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can use a tool called ScalaCheck to do this in a more automated way. Instead of writing tests, with ScalaCheck we write <em>properties</em> that are assumed to hold. ScalaCheck will then try to find good counter-examples if the assertion fails.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="n">forall</span> <span class="o">{</span> <span class="o">(</span><span class="n">l1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">l2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=&gt;</span>
    <span class="nv">l1</span><span class="o">.</span><span class="py">size</span> <span class="o">+</span> <span class="nv">l2</span><span class="o">.</span><span class="py">size</span> <span class="o">==</span> <span class="o">(</span><span class="n">l1</span> <span class="o">++</span> <span class="n">l2</span><span class="o">).</span><span class="py">size</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="monads">Monads</h2>

<h3 id="definition-1">Definition</h3>
<p>A monad <code class="highlighter-rouge">M</code> is a parametric type <code class="highlighter-rouge">M[T]</code>  with two operations, <code class="highlighter-rouge">unit</code> and <code class="highlighter-rouge">flatMap</code> (more commonly called <code class="highlighter-rouge">bind</code> in the literature):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">M</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The unit method return a monad with the given type:</p>

<ul>
  <li><code class="highlighter-rouge">List</code> is a monad with <code class="highlighter-rouge">unit(x) = List(x)</code></li>
  <li><code class="highlighter-rouge">Set</code> is a monad with <code class="highlighter-rouge">unit(x) = Set(x)</code></li>
  <li><code class="highlighter-rouge">Option</code> is a monad with <code class="highlighter-rouge">unit(x) = Some(x)</code></li>
  <li><code class="highlighter-rouge">Generator</code> is a monad with <code class="highlighter-rouge">unit(x) = single(x)</code></li>
</ul>

<p>For every monad, <code class="highlighter-rouge">map</code> can be be defined as a combination of <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">unit</code>. All of the following are equivalent.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="n">m</span> <span class="n">map</span> <span class="n">f</span>
<span class="n">m</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">unit</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
<span class="n">m</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">f</span> <span class="n">andThen</span> <span class="n">unit</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>These methods have to satisfy some laws:</p>

<ul>
  <li><strong>Associativity</strong>: we can put the parentheses either to the left or the right, so <code class="highlighter-rouge">(m flatMap f) flatMap g == m flatMap(x =&gt; f(x) flatMap g)</code></li>
  <li><strong>Left unit</strong>: <code class="highlighter-rouge">unit(x) flatMap f == f(x)</code></li>
  <li><strong>Right unit</strong>: <code class="highlighter-rouge">m flatMap unit == m</code></li>
</ul>

<h3 id="significance-of-the-laws">Significance of the laws</h3>
<p>Associativity says that one can â€œinlineâ€ nested for-expressions; the following are equivalent:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">for</span> <span class="o">{</span>
    <span class="n">y</span> <span class="k">&lt;-</span> <span class="nf">for</span><span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">m</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">y</span>
    <span class="n">z</span> <span class="k">&lt;-</span> <span class="nf">g</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">z</span>

<span class="k">for</span> <span class="o">{</span>
    <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">m</span>
    <span class="n">y</span> <span class="k">&lt;-</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="n">z</span> <span class="k">&lt;-</span> <span class="nf">g</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">z</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Right unit says <code class="highlighter-rouge">for (x &lt;- m) yield x</code> is equivalent to just <code class="highlighter-rouge">m</code>, and left unit isnâ€™t very useful for for-expressions.</p>

<p>If monads are still mysterious, <a href="https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534#.vrwvtyqhz">this is a good read</a>.</p>

<h2 id="streams">Streams</h2>
<p>Sometimes, for performance reasons, we want avoid computing the tail of a sequence until it is needed for the evalutation result (which might be never). Streams implement this idea while keeping the notation concise. Theyâ€™re similar to lists, but their tail is evaluated only on demand.</p>

<h3 id="definition-2">Definition</h3>
<p>Streams can be constructed like most other collections:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="nv">Stream</span><span class="o">.</span><span class="py">cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">empty</span><span class="o">))</span>
<span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">).</span><span class="py">toStream</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">.toStream</code> can be applied to any collection.</p>

<p>Streams can be described as partially constructed lists, and <em>they support almost all of the <code class="highlighter-rouge">List</code> methods</em>. For instance, to find the second prime number between 1000 and 10000, we can do:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="o">((</span><span class="mi">1000</span> <span class="n">to</span> <span class="mi">10000</span><span class="o">).</span><span class="py">toStream</span> <span class="n">filter</span> <span class="n">isPrime</span><span class="o">)(</span><span class="mi">1</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The only exception is the cons operator, which is <code class="highlighter-rouge">#::</code> instead of <code class="highlighter-rouge">::</code>. This can be used in operation but also in patterns.</p>

<h3 id="implementation">Implementation</h3>
<p>Again, this is pretty close to lists:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">A</span>
    <span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>All other methods can be defined in terms of these three. The actual implementation of streams is in the <code class="highlighter-rouge">Stream</code> companion object, so if we want to define a new type of <code class="highlighter-rouge">Stream</code>, we just need to redefine these three methods.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">Stream</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="c1">// Use CBN!</span>
        <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
        <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">hd</span>
        <span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="n">tl</span>
    <span class="o">}</span>
    <span class="k">val</span> <span class="nv">empty</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
        <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"empty.head"</span><span class="o">)</span>
        <span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"empty.tail"</span><span class="o">)</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Notice how the <code class="highlighter-rouge">cons</code> method uses <a href="#call-by-name-cbn-call-by-value-cbv">CBN</a>. This is what makes the whole drastic difference between <code class="highlighter-rouge">List</code> and <code class="highlighter-rouge">Stream</code>!</p>

<p>The other stream methods are implemented analogously to their list counterparts:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">this</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">p</span><span class="o">(</span><span class="n">head</span><span class="o">))</span> <span class="nf">cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="nv">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">))</span>
        <span class="k">else</span> <span class="nv">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="lazy-evaluation">Lazy Evaluation</h3>
<p>The proposed implementation suffers from a serious potential performance problem: if <code class="highlighter-rouge">tail</code> is called several times, the corresponding stream will be recomputed each time. To avoid this, we can store the result of the first evalutation of <code class="highlighter-rouge">tail</code> and re-use the stored result next time.</p>

<p>This is called <em>lazy evaluation</em> (as opposed to <em>by-name evaluation</em> where everything is recomputed, and <em>strict evaluation</em> for normal parameters and <code class="highlighter-rouge">val</code> definitions). Scala uses strict evaluation by default, but allows lazy evaluation:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">lazy</span> <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="n">expr</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="highlighter-rouge">x</code> is computed only once, when it is needed the first time; since functional programming expressions yield the same result on each call, the result is saved and reused next time.</p>

<p>This means that using a lazy value for <code class="highlighter-rouge">tail</code>, <code class="highlighter-rouge">Stream.cons</code> can be implemented more efficiently:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">hd</span>
    <span class="k">lazy</span> <span class="k">val</span> <span class="nv">tail</span> <span class="k">=</span> <span class="n">tl</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="infinite-streams">Infinite Streams</h3>
<p>Infinite streams benefit from laziness. All elements of a stream except the first one are computed only when needed. This opens up the possibility to define infinite streams.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">from</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">n</span> <span class="o">#::</span> <span class="nf">from</span><span class="o">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">nats</span> <span class="k">=</span> <span class="nf">from</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// stream of all natural numbers</span>
<span class="n">nats</span> <span class="nf">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">4</span><span class="o">)</span> <span class="c1">// all natural multiples of 4</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We also donâ€™t need to worry too much about infinite recursions with infinite streams since the tail isnâ€™t evaluated:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">sqrtStream</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">improve</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">guess</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">guess</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">lazy</span> <span class="k">val</span> <span class="nv">guesses</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">#::</span> <span class="o">(</span><span class="n">guesses</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span>

    <span class="n">guesses</span> 
<span class="o">}</span>

<span class="k">def</span> <span class="nf">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
    <span class="nv">math</span><span class="o">.</span><span class="py">abs</span><span class="o">((</span><span class="n">guess</span> <span class="o">*</span> <span class="n">guess</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">/</span> <span class="n">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mf">0.0001</span>

<span class="nf">sqrtStream</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="nf">filter</span> <span class="o">(</span><span class="nf">isGoodEnough</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="functions-and-state">Functions and State</h2>
<p>So far weâ€™ve seen that rewriting can be done anywhere in a term, and all rewritings which terminate lead to the same solution. For instance:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">iterate</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
    <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="k">def</span> <span class="nf">square</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="nf">iterate</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// Can be rewritten as follows:</span>
<span class="nf">if</span> <span class="o">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">3</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">)</span>
<span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
<span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">9</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
<span class="mi">9</span>

<span class="c1">// But also:</span>
<span class="nf">if</span> <span class="o">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">3</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
<span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="mi">9</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are multiple ways to rewrite our way to the solution; this is known as the Church-Rosser Theorem of lambda-calculus.</p>

<p>In this chapter, weâ€™ll look at code that <em>doesnâ€™t</em> satisfy that property. We will say goodbye to the substitution model for code that isnâ€™t purely functional.</p>

<h3 id="stateful-objects">Stateful Objects</h3>
<p>An object <em>has a state</em> if its behavior is influenced by its history. It is mutable (while everything so far has been immutable).</p>

<p>Mutable states are defined using the <code class="highlighter-rouge">var</code> keyword (instead of <code class="highlighter-rouge">val</code>), and assigned with <code class="highlighter-rouge">=</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"abc"</span>
<span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">111</span>
<span class="n">x</span> <span class="k">=</span> <span class="s">"hi"</span>
<span class="n">count</span> <span class="k">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span> 
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we define an object with stateful variables, then it is a stateful object if the result of calling a method depends on the history of the called methods, that the result may change over time.</p>

<h3 id="identity">Identity</h3>
<p>Mutable state introduces questions about equality, identity between two objects.</p>

<p>With immutable values (<code class="highlighter-rouge">val</code>), we had <em>referential transparency</em>; <code class="highlighter-rouge">val x = E; val y = E</code> was equivalent to <code class="highlighter-rouge">val x = E; val y = x</code>. This is no longer the case.</p>

<p>If <code class="highlighter-rouge">BankAccount</code> is a stateful object (its balance may change), then <code class="highlighter-rouge">val x = new BankAccount</code> and <code class="highlighter-rouge">val y = new BankAccount</code> arenâ€™t equal. This makes sense, because modifying <code class="highlighter-rouge">x</code> doesnâ€™t mean modifying <code class="highlighter-rouge">y</code>, and we therefore have to different accounts.</p>

<p>In general, to determine equality, we must first specify what is meant by â€œbeing the sameâ€. The precise meaning is defined by the property of <em>operational equivalence</em>: informally, <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are operationally equivalent if <em>no possible test</em> can distinguish between them. For any arbitrary function <code class="highlighter-rouge">f</code>, <code class="highlighter-rouge">f(x, y)</code> and <code class="highlighter-rouge">f(x, x)</code> must return the same value.</p>

<h3 id="loops">Loops</h3>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="c1">// While:</span>
<span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// Do-while:</span>
<span class="k">do</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="o">)</span>

<span class="c1">// For:</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// i takes values 1, 2 but not 3</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>For-loops look similar to for-expressions, but are translated to <code class="highlighter-rouge">foreach</code> instead of <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="nf">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span><span class="o">;</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="s">"abc"</span><span class="o">)</span> <span class="nf">print</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">""</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="s">" "</span><span class="o">)</span>
<span class="c1">// translates to:</span>
<span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="s">"abc"</span> <span class="nf">foreach</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="nf">print</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">""</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="s">" "</span><span class="o">)))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This should print â€œ1a 1b 1c 2a 2b 2câ€</p>

<h2 id="lisp">Lisp</h2>
<p>I donâ€™t have a whole lot of notes on this, since most of Lisp was seen during lab sessions, and my notes on lambda-calculus are on paper (it wouldnâ€™t have been easy typing it in real time). But for future reference, Iâ€™m adding a syntax list of the Lisp dialect seen in class:</p>

<ul>
  <li><code class="highlighter-rouge">(if c a b)</code>: special form which evaluates <code class="highlighter-rouge">c</code>, and then <code class="highlighter-rouge">a</code> if <code class="highlighter-rouge">c != 0</code> and <code class="highlighter-rouge">b</code> if <code class="highlighter-rouge">c = 0</code>.</li>
  <li><code class="highlighter-rouge">(cond (c1 r1) ... (cn rn) (else relse))</code>: special form which evaluates <code class="highlighter-rouge">c1</code>, then <code class="highlighter-rouge">r1</code> if <code class="highlighter-rouge">c1</code> is true, or else continues with the other clauses.</li>
  <li><code class="highlighter-rouge">(cons first rest)</code>: constructs a list equivalent to Scalaâ€™s <code class="highlighter-rouge">x :: xs</code>. In our interpreter, <code class="highlighter-rouge">xs</code> must be a list.</li>
  <li><code class="highlighter-rouge">(car lst)</code>: returns the head of a given list.</li>
  <li><code class="highlighter-rouge">(cdr lst)</code>: returns the tail of a given list</li>
  <li><code class="highlighter-rouge">(quote x)</code>: returns x as a quoted expression, i.e. <code class="highlighter-rouge">(quote foo)</code> returns the quoted symbol <code class="highlighter-rouge">foo</code>, and <code class="highlighter-rouge">(quote (a b c))</code> returns the list equivalent to <code class="highlighter-rouge">(cons (quote a) (cons (quote b) (cons (quote c) nil)))</code></li>
  <li><code class="highlighter-rouge">(= a b)</code>: returns whether <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> are equal. In our interpreter, a and b may be numbers, symbols or
even lists.</li>
  <li><code class="highlighter-rouge">(lambda (p1 ... pn) body)</code>: creates an anonymous function.</li>
  <li><code class="highlighter-rouge">def f x</code>: creates a definition.</li>
  <li><code class="highlighter-rouge">def (f p1 ... pn) body</code>: syntactic sugar for defining a named function.</li>
</ul>

<!-- Not a part of the course, sadly (I had begun taking notes nonetheless)

## Event handling
FRP has to do with event handling, and is very useful in (among others) simulations and in user interfaces.

### Observer Pattern
The Observer pattern is widely used when views need to react to changes in a model. It's also called "publish/subscribe" or "model/view/controller" (MVC). Let's see how we can put it into code.


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Publisher</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">subscribers</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Subscriber</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span>

    <span class="k">def</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="k">:</span> <span class="kt">Subscriber</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
        <span class="n">subscribers</span> <span class="o">+=</span> <span class="n">subscriber</span>

    <span class="k">def</span> <span class="nf">unsubscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="k">:</span> <span class="kt">Subscriber</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
        <span class="n">subscribers</span> <span class="o">-=</span> <span class="n">subscriber</span>

    <span class="k">def</span> <span class="nf">publish</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
        <span class="nv">subscribers</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">handler</span><span class="o">(</span><span class="k">this</span><span class="o">))</span> <span class="c1">// this refers to the Publisher calling the handler</span>

<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Subscriber</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">handler</span><span class="o">(</span><span class="n">pub</span><span class="k">:</span> <span class="kt">Publisher</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>


Let's make a bank account, which is a publisher: it publishes its state to the model.


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">BankAccount</span> <span class="k">extends</span> <span class="nc">Publisher</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">balance</span> <span class="k">=</span> <span class="mi">0</span> <span class="c1">// private so it can't be manipulated from the outside!</span>

    <span class="k">def</span> <span class="nf">currentBalance</span> <span class="k">=</span> <span class="n">balance</span>

    <span class="k">def</span> <span class="nf">deposit</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">balance</span> <span class="o">+=</span> <span class="n">amount</span>
            <span class="nf">publish</span><span class="o">()</span>
        <span class="o">}</span>
    
    <span class="k">def</span> <span class="nf">withdraw</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">amount</span> <span class="o">&amp;&amp;</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">balance</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">balance</span> <span class="o">-=</span> <span class="n">amount</span>
            <span class="n">publish</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"insuffient funds"</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>


Now let's add a view, a `Subscriber` to maintain the total balance of a list of accounts.


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Consolidator</span><span class="o">(</span><span class="n">observed</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">BankAccount</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Subscriber</span> <span class="o">{</span>
    <span class="nv">observed</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="k">this</span><span class="o">))</span>

    <span class="k">private</span> <span class="k">var</span> <span class="n">total</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">_</span> <span class="c1">// initially uninitialized</span>
    <span class="nf">compute</span><span class="o">()</span>

    <span class="k">private</span> <span class="k">def</span> <span class="nf">compute</span><span class="o">()</span> <span class="k">=</span> <span class="c1">// computes the sum of balances of all accounts</span>
        <span class="n">total</span> <span class="k">=</span> <span class="nv">observed</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">currentBalance</span><span class="o">).</span><span class="py">sum</span>

    <span class="k">def</span> <span class="nf">handler</span><span class="o">(</span><span class="n">pub</span><span class="k">:</span> <span class="kt">Publisher</span><span class="o">)</span> <span class="k">=</span> <span class="nf">compute</span><span class="o">()</span>

    <span class="k">def</span> <span class="nf">totalBalance</span> <span class="k">=</span> <span class="n">total</span> <span class="c1">// accesser </span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>


We can now use the structure as follows


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span>
<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span>
<span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Consolidator</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>

<span class="nv">c</span><span class="o">.</span><span class="py">totalBalance</span> <span class="c1">// 0</span>
<span class="n">a</span> <span class="n">deposit</span> <span class="mi">20</span>
<span class="n">b</span> <span class="n">deposit</span> <span class="mi">30</span>
<span class="nv">c</span><span class="o">.</span><span class="py">totalBalance</span> <span class="c1">// returns 50</span>
</pre></td></tr></tbody></table></code></pre></figure>


#### The Good
- Decouples views from state
- Allows to have a varying number of views of a given state
- Simple to set up

#### The Bad
- Forces imperative style, since handlers are `Unit` typed
- Many moving parts that need to be coordinated (every publisher has to announce itself, subscriber needs to handle it, there are calls back in forth)
- Concurrency makes things more complicated
- Views are still tightly bound to one state, view update happens immediately (sometimes you want to have a looser asynchronous relationship between view and model)

#### The Ugly
This causes a lot of problems in practice; Adobe found that a third of the code was event handling, and half of the bugs were found in it. The rest of the chapter focuses on how to improve MVC.

### Functional Reactive Programming
Reactive programming is about reacting to sequences of *events* that happen in *time*. The functional paradigm means that we aggregate an event sequence into a *signal*, a value that changes over time.

A signal is represented as a function from time to the value domain.


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="c1">// Event-based: fire the event</span>
<span class="nc">MouseMoved</span><span class="o">(</span><span class="n">toPos</span><span class="k">:</span> <span class="kt">Position</span><span class="o">)</span>
<span class="c1">// FRP: </span>
<span class="n">mousePosition</span><span class="k">:</span> <span class="kt">Signal</span><span class="o">[</span><span class="kt">Position</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>


We define new signals in terms of existing ones.


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">inRectangle</span> <span class="o">(</span><span class="n">lowerleft</span><span class="k">:</span> <span class="kt">Position</span><span class="o">,</span> <span class="n">uperright</span><span class="k">:</span> <span class="kt">Position</span><span class="o">)</span><span class="k">:</span> <span class="kt">Signal</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Signal</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">pos</span> <span class="k">=</span> <span class="nf">mousPosition</span><span class="o">()</span>
        <span class="n">lowerleft</span> <span class="o">&lt;=</span> <span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">uperright</span>
    <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>


For signals varying in time, we can use a `Var`, which is a mutable subclass of `Signal`. This allows us to redefine a signal from the current time on, using the `update` operation:


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">val</span> <span class="nv">sig</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="nv">sig</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="c1">// Equivalent to:</span>
<span class="nf">sig</span><span class="o">()</span> <span class="k">=</span> <span class="mi">5</span>
<span class="c1">// Dereferencing:</span>
<span class="nf">sig</span><span class="o">()</span>
</pre></td></tr></tbody></table></code></pre></figure>



-->
:ET