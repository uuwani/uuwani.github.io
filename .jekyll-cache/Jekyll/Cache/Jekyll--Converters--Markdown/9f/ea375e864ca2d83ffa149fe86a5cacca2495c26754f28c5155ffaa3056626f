I"ĉ<ul id="markdown-toc">
  <li><a href="#links-and-books" id="markdown-toc-links-and-books">Links and books</a></li>
  <li><a href="#analyzing-algorithms" id="markdown-toc-analyzing-algorithms">Analyzing algorithms</a></li>
  <li><a href="#sorting" id="markdown-toc-sorting">Sorting</a>    <ul>
      <li><a href="#insertion-sort" id="markdown-toc-insertion-sort">Insertion sort</a>        <ul>
          <li><a href="#correctness" id="markdown-toc-correctness">Correctness</a></li>
          <li><a href="#analysis" id="markdown-toc-analysis">Analysis</a></li>
        </ul>
      </li>
      <li><a href="#merge-sort" id="markdown-toc-merge-sort">Merge Sort</a>        <ul>
          <li><a href="#correctness-1" id="markdown-toc-correctness-1">Correctness</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#recurrences" id="markdown-toc-recurrences">Recurrences</a>    <ul>
      <li><a href="#master-theorem" id="markdown-toc-master-theorem">Master Theorem</a></li>
    </ul>
  </li>
  <li><a href="#maximum-subarray-problem" id="markdown-toc-maximum-subarray-problem">Maximum-Subarray Problem</a>    <ul>
      <li><a href="#description" id="markdown-toc-description">Description</a></li>
      <li><a href="#divide-and-conquer" id="markdown-toc-divide-and-conquer">Divide and Conquer</a></li>
    </ul>
  </li>
  <li><a href="#matrix-multiplication" id="markdown-toc-matrix-multiplication">Matrix multiplication</a>    <ul>
      <li><a href="#naive-algorithm" id="markdown-toc-naive-algorithm">Naive Algorithm</a></li>
      <li><a href="#divide-and-conquer-algorithm" id="markdown-toc-divide-and-conquer-algorithm">Divide-and-Conquer algorithm</a>        <ul>
          <li><a href="#pseudocode-and-analysis" id="markdown-toc-pseudocode-and-analysis">Pseudocode and analysis</a></li>
        </ul>
      </li>
      <li><a href="#strassens-algorithm-for-matrix-multiplication" id="markdown-toc-strassens-algorithm-for-matrix-multiplication">Strassen’s Algorithm for Matrix Multiplication</a>        <ul>
          <li><a href="#notes-about-strassen" id="markdown-toc-notes-about-strassen">Notes about Strassen</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#heaps-and-heapsort" id="markdown-toc-heaps-and-heapsort">Heaps and Heapsort</a>    <ul>
      <li><a href="#heaps" id="markdown-toc-heaps">Heaps</a>        <ul>
          <li><a href="#max-heapify" id="markdown-toc-max-heapify">Max-Heapify</a></li>
          <li><a href="#building-a-heap" id="markdown-toc-building-a-heap">Building a heap</a></li>
        </ul>
      </li>
      <li><a href="#heapsort" id="markdown-toc-heapsort">Heapsort</a></li>
      <li><a href="#priority-queues" id="markdown-toc-priority-queues">Priority queues</a>        <ul>
          <li><a href="#finding-maximum-element" id="markdown-toc-finding-maximum-element">Finding maximum element</a></li>
          <li><a href="#extracting-maximum-element" id="markdown-toc-extracting-maximum-element">Extracting maximum element</a></li>
          <li><a href="#increasing-a-value" id="markdown-toc-increasing-a-value">Increasing a value</a></li>
          <li><a href="#inserting-into-the-heap" id="markdown-toc-inserting-into-the-heap">Inserting into the heap</a></li>
        </ul>
      </li>
      <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
    </ul>
  </li>
  <li><a href="#more-data-structures" id="markdown-toc-more-data-structures">More data structures</a>    <ul>
      <li><a href="#stacks" id="markdown-toc-stacks">Stacks</a></li>
      <li><a href="#queues" id="markdown-toc-queues">Queues</a></li>
      <li><a href="#linked-lists" id="markdown-toc-linked-lists">Linked Lists</a>        <ul>
          <li><a href="#search" id="markdown-toc-search">Search</a></li>
          <li><a href="#insertion" id="markdown-toc-insertion">Insertion</a></li>
          <li><a href="#deletion" id="markdown-toc-deletion">Deletion</a></li>
          <li><a href="#summary-1" id="markdown-toc-summary-1">Summary</a></li>
        </ul>
      </li>
      <li><a href="#binary-search-trees" id="markdown-toc-binary-search-trees">Binary search trees</a>        <ul>
          <li><a href="#querying-a-binary-search-tree" id="markdown-toc-querying-a-binary-search-tree">Querying a binary search tree</a>            <ul>
              <li><a href="#searching" id="markdown-toc-searching">Searching</a></li>
              <li><a href="#maximum-and-minimum" id="markdown-toc-maximum-and-minimum">Maximum and minimum</a></li>
              <li><a href="#successor" id="markdown-toc-successor">Successor</a></li>
            </ul>
          </li>
          <li><a href="#printing-a-binary-search-tree" id="markdown-toc-printing-a-binary-search-tree">Printing a binary search tree</a>            <ul>
              <li><a href="#inorder" id="markdown-toc-inorder">Inorder</a></li>
              <li><a href="#preorder" id="markdown-toc-preorder">Preorder</a></li>
              <li><a href="#postorder" id="markdown-toc-postorder">Postorder</a></li>
            </ul>
          </li>
          <li><a href="#modifying-a-binary-seach-tree" id="markdown-toc-modifying-a-binary-seach-tree">Modifying a binary seach tree</a>            <ul>
              <li><a href="#insertion-1" id="markdown-toc-insertion-1">Insertion</a></li>
              <li><a href="#deletion-1" id="markdown-toc-deletion-1">Deletion</a></li>
            </ul>
          </li>
          <li><a href="#summary-2" id="markdown-toc-summary-2">Summary</a></li>
        </ul>
      </li>
      <li><a href="#summary-3" id="markdown-toc-summary-3">Summary</a></li>
    </ul>
  </li>
  <li><a href="#dynamic-programming" id="markdown-toc-dynamic-programming">Dynamic Programming</a>    <ul>
      <li><a href="#top-down-with-memoization" id="markdown-toc-top-down-with-memoization">Top-down with memoization</a></li>
      <li><a href="#bottom-up" id="markdown-toc-bottom-up">Bottom-up</a></li>
      <li><a href="#rod-cutting-problem" id="markdown-toc-rod-cutting-problem">Rod cutting problem</a>        <ul>
          <li><a href="#structural-theorem" id="markdown-toc-structural-theorem">Structural Theorem</a></li>
          <li><a href="#algorithm" id="markdown-toc-algorithm">Algorithm</a></li>
          <li><a href="#extended-algorithm" id="markdown-toc-extended-algorithm">Extended algorithm</a></li>
        </ul>
      </li>
      <li><a href="#when-can-dynamic-programming-be-used" id="markdown-toc-when-can-dynamic-programming-be-used">When can dynamic programming be used?</a></li>
      <li><a href="#matrix-chain-multiplication" id="markdown-toc-matrix-chain-multiplication">Matrix-chain multiplication</a>        <ul>
          <li><a href="#optimal-substructure-theorem" id="markdown-toc-optimal-substructure-theorem">Optimal substructure theorem</a></li>
        </ul>
      </li>
      <li><a href="#longest-common-subsequence" id="markdown-toc-longest-common-subsequence">Longest common subsequence</a>        <ul>
          <li><a href="#theorem" id="markdown-toc-theorem">Theorem</a></li>
        </ul>
      </li>
      <li><a href="#optimal-binary-search-trees" id="markdown-toc-optimal-binary-search-trees">Optimal binary search trees</a></li>
    </ul>
  </li>
  <li><a href="#graphs" id="markdown-toc-graphs">Graphs</a>    <ul>
      <li><a href="#representation" id="markdown-toc-representation">Representation</a></li>
      <li><a href="#traversing--searching-a-graph" id="markdown-toc-traversing--searching-a-graph">Traversing / Searching a graph</a>        <ul>
          <li><a href="#breadth-first-search-bfs" id="markdown-toc-breadth-first-search-bfs">Breadth-First Search (<abbr title="Breadth-First Search">BFS</abbr>)</a></li>
          <li><a href="#depth-first-search-dfs" id="markdown-toc-depth-first-search-dfs">Depth-first search (<abbr title="Depth-First Search">DFS</abbr>)</a></li>
        </ul>
      </li>
      <li><a href="#classification-of-edges" id="markdown-toc-classification-of-edges">Classification of edges</a></li>
      <li><a href="#parenthesis-theorem" id="markdown-toc-parenthesis-theorem">Parenthesis theorem</a></li>
      <li><a href="#white-path-theorem" id="markdown-toc-white-path-theorem">White-path theorem</a></li>
      <li><a href="#topological-sort" id="markdown-toc-topological-sort">Topological sort</a>        <ul>
          <li><a href="#lemma-when-is-a-directed-graph-acyclic" id="markdown-toc-lemma-when-is-a-directed-graph-acyclic">Lemma: When is a directed graph acyclic?</a></li>
        </ul>
      </li>
      <li><a href="#strongly-connected-component" id="markdown-toc-strongly-connected-component">Strongly connected component</a>        <ul>
          <li><a href="#lemma" id="markdown-toc-lemma">Lemma</a></li>
          <li><a href="#magic-algorithm" id="markdown-toc-magic-algorithm">Magic Algorithm</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#flow-networks" id="markdown-toc-flow-networks">Flow Networks</a>    <ul>
      <li><a href="#ford-fulkerson-method" id="markdown-toc-ford-fulkerson-method">Ford-Fulkerson Method</a>        <ul>
          <li><a href="#residual-network" id="markdown-toc-residual-network">Residual network</a></li>
        </ul>
      </li>
      <li><a href="#cuts-in-flow-networks" id="markdown-toc-cuts-in-flow-networks">Cuts in flow networks</a>        <ul>
          <li><a href="#net-flow-across-a-cut" id="markdown-toc-net-flow-across-a-cut">Net flow across a cut</a></li>
          <li><a href="#capacity-of-a-cut" id="markdown-toc-capacity-of-a-cut">Capacity of a cut</a></li>
          <li><a href="#minimum-cut" id="markdown-toc-minimum-cut">Minimum cut</a></li>
          <li><a href="#max-flow-min-cut-theorem" id="markdown-toc-max-flow-min-cut-theorem">Max-flow min-cut theorem</a></li>
        </ul>
      </li>
      <li><a href="#time-for-finding-max-flow-or-min-cut" id="markdown-toc-time-for-finding-max-flow-or-min-cut">Time for finding max-flow (or min-cut)</a></li>
      <li><a href="#bipartite-matching" id="markdown-toc-bipartite-matching">Bipartite matching</a>        <ul>
          <li><a href="#why-does-it-work" id="markdown-toc-why-does-it-work">Why does it work?</a></li>
        </ul>
      </li>
      <li><a href="#edmonds-kart-algorithm" id="markdown-toc-edmonds-kart-algorithm">Edmonds-Kart algorithm</a>        <ul>
          <li><a href="#lemma-1" id="markdown-toc-lemma-1">Lemma</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#data-structures-for-disjoint-sets" id="markdown-toc-data-structures-for-disjoint-sets">Data structures for disjoint sets</a>    <ul>
      <li><a href="#application-connected-components" id="markdown-toc-application-connected-components">Application: Connected components</a></li>
      <li><a href="#implementation-linked-list" id="markdown-toc-implementation-linked-list">Implementation: Linked List</a></li>
      <li><a href="#implementation-forest-of-trees" id="markdown-toc-implementation-forest-of-trees">Implementation: Forest of trees</a></li>
    </ul>
  </li>
  <li><a href="#minimum-spanning-trees-mst" id="markdown-toc-minimum-spanning-trees-mst">Minimum Spanning Trees (<abbr title="Minimum Spanning Tree">MST</abbr>)</a>    <ul>
      <li><a href="#prims-algorithm" id="markdown-toc-prims-algorithm">Prim’s algorithm</a>        <ul>
          <li><a href="#implementation" id="markdown-toc-implementation">Implementation</a></li>
        </ul>
      </li>
      <li><a href="#kruskals-algorithm" id="markdown-toc-kruskals-algorithm">Kruskal’s algorithm</a>        <ul>
          <li><a href="#implementation-1" id="markdown-toc-implementation-1">Implementation</a></li>
        </ul>
      </li>
      <li><a href="#summary-4" id="markdown-toc-summary-4">Summary</a></li>
    </ul>
  </li>
  <li><a href="#shortest-path-problem" id="markdown-toc-shortest-path-problem">Shortest Path Problem</a>    <ul>
      <li><a href="#problem-variants" id="markdown-toc-problem-variants">Problem variants</a></li>
      <li><a href="#bellman-ford-algorithm" id="markdown-toc-bellman-ford-algorithm">Bellman-Ford algorithm</a>        <ul>
          <li><a href="#detecting-negative-cycles" id="markdown-toc-detecting-negative-cycles">Detecting negative cycles</a></li>
        </ul>
      </li>
      <li><a href="#dijkstras-algorithm" id="markdown-toc-dijkstras-algorithm">Dijkstra’s algorithm</a></li>
    </ul>
  </li>
  <li><a href="#probabilistic-analysis-and-randomized-algorithms" id="markdown-toc-probabilistic-analysis-and-randomized-algorithms">Probabilistic analysis and randomized algorithms</a>    <ul>
      <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
      <li><a href="#probabilistic-analysis-the-hiring-problem" id="markdown-toc-probabilistic-analysis-the-hiring-problem">Probabilistic Analysis: The Hiring Problem</a>        <ul>
          <li><a href="#lemma-2" id="markdown-toc-lemma-2">Lemma</a></li>
          <li><a href="#multiple-coin-flips" id="markdown-toc-multiple-coin-flips">Multiple Coin Flips</a></li>
          <li><a href="#solving-the-hiring-problem" id="markdown-toc-solving-the-hiring-problem">Solving the Hiring Problem</a></li>
          <li><a href="#bonus-trivia" id="markdown-toc-bonus-trivia">Bonus trivia</a></li>
        </ul>
      </li>
      <li><a href="#birthday-lemma" id="markdown-toc-birthday-lemma">Birthday Lemma</a></li>
      <li><a href="#hash-functions-and-tables" id="markdown-toc-hash-functions-and-tables">Hash functions and tables</a>        <ul>
          <li><a href="#hash-tables" id="markdown-toc-hash-tables">Hash tables</a></li>
          <li><a href="#collisions" id="markdown-toc-collisions">Collisions</a></li>
          <li><a href="#running-times" id="markdown-toc-running-times">Running times</a></li>
          <li><a href="#examples-of-hash-functions" id="markdown-toc-examples-of-hash-functions">Examples of Hash Functions</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#quick-sort" id="markdown-toc-quick-sort">Quick Sort</a>    <ul>
      <li><a href="#why-always-n-log-n" id="markdown-toc-why-always-n-log-n">Why always n log n?</a></li>
      <li><a href="#linear-time-sorting" id="markdown-toc-linear-time-sorting">Linear time sorting</a></li>
    </ul>
  </li>
  <li><a href="#review-of-the-course" id="markdown-toc-review-of-the-course">Review of the course</a>    <ul>
      <li><a href="#growth-of-functions" id="markdown-toc-growth-of-functions">Growth of functions</a></li>
      <li><a href="#sorting-1" id="markdown-toc-sorting-1">Sorting</a></li>
    </ul>
  </li>
</ul>

<!-- More -->

<h2 id="links-and-books">Links and books</h2>
<ul>
  <li><a href="http://theory.epfl.ch/courses/algorithms/">Course homepage</a></li>
  <li>Introduction to Algorithms, Third edition (2009), T. Cormen, C. Lerserson, R. Rivest, C. Stein (<em>book on which the course is based</em>)</li>
  <li>The Art of Computer Programming, Donald Knuth (<em>a classic</em>)</li>
</ul>

<h2 id="analyzing-algorithms">Analyzing algorithms</h2>
<p>We’ll work under a model that assumes that:</p>

<ul>
  <li>Instructions are executed one after another</li>
  <li>Basic instructions (arithmetic, data movement, control) take constant O(1) time</li>
  <li>We don’t worry about numerical precision, although it is crucial in certain
numerical applications</li>
</ul>

<p>We usually concentrate on finding the worst-case running time. This gives a guaranteed upper bound on the running time. Besides, the worst case often occurs in some algorithms, and the average is often as bad as the worst-case.</p>

<h2 id="sorting">Sorting</h2>
<p>The sorting problem’s definition is the following:</p>

<ul>
  <li><strong>Input</strong>: A sequence of $n$ numbers $(a_1, a_2, \dots, a_n)$</li>
  <li><strong>Output</strong>: A permutation (reordering) $(a_1’, a_2’, \dots, a_n’)$ of the input sequence in increasing order</li>
</ul>

<h3 id="insertion-sort">Insertion sort</h3>
<p>This algorithm works somewhat in the same way as sorting a deck of cards. We take a single element and traverse the list to insert it in the right position. This traversal works by swapping elements at each step.</p>

<figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># We start at 2 because a single element is already sorted.
</span>    <span class="c1"># The upper bound in range is exclusive, so we set it to n+1
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="c1"># Insert A[j] in to the sorted sequence A[1..j-1]
</span>        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
            <span class="c1"># swap
</span>            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
</pre></td></tr></tbody></table></code></pre></figure>

    <figcaption>Note that pseudocode arrays start at index 1</figcaption>
</figure>

<h4 id="correctness">Correctness</h4>
<p>Using induction-like logic.</p>

<p><strong>Loop invariant</strong>: At the start of each iteration of the “outer” <code class="highlighter-rouge">for</code> loop — the loop indexed by <code class="highlighter-rouge">j</code> — the subarray <code class="highlighter-rouge">A[1, ..., j-1]</code> consists of the elements originally in <code class="highlighter-rouge">A[1, ..., j-1]</code> but in sorted order.</p>

<p>We need to verify:</p>

<ul>
  <li><strong>Initialization</strong>: We start at <code class="highlighter-rouge">j=2</code> so we start with one element. One number is trivially sorted compared to itself.</li>
  <li><strong>Maintenance</strong>: We’ll assume that the invariant holds at the beginning of the iteration when <code class="highlighter-rouge">j=k</code>. The body of the <code class="highlighter-rouge">for</code> loop works by moving <code class="highlighter-rouge">A[k-1]</code>, <code class="highlighter-rouge">A[k-2]</code> ansd so on one step to the right until it finds the proper position for <code class="highlighter-rouge">A[k]</code> at which points it inserts the value of <code class="highlighter-rouge">A[k]</code>. The subarray <code class="highlighter-rouge">A[1..k]</code> then consists of the elements in a sorted order. Incrementing <code class="highlighter-rouge">j</code> to <code class="highlighter-rouge">k+1</code> preserves the loop invariant.</li>
  <li><strong>Termination</strong>: The condition of the <code class="highlighter-rouge">for</code> loop to terminate is that <code class="highlighter-rouge">j&gt;n</code>; hence, <code class="highlighter-rouge">j=n+1</code> when the loop terminates, and <code class="highlighter-rouge">A[1..n]</code> contains the original elements in sorted order.</li>
</ul>

<h4 id="analysis">Analysis</h4>

<p><img src="/images/algorithms/insertion-analysis.png" alt="Cost of each line of the insertion sort algorithm" /></p>

<ul>
  <li><strong>Best case</strong>: The array is already sorted, and we can do $\Theta(n)$</li>
  <li><strong>Worst case</strong>: The array is sorted in reverse, so $j=t_j$ and the algorithm runs in $\Theta(n^2)$:</li>
</ul>

<figure>
    $$ c_5 \sum_{j=2}^{n} t_j = c_5 \frac{n(n-1)}{2}=\mathcal{O}(n^2) $$
    <figcaption>The first equality is achieved using Gauss' summation formula</figcaption>
</figure>

<h3 id="merge-sort">Merge Sort</h3>
<p>Merge sort is a divide-and-conquer algorithm:</p>

<ul>
  <li><strong>Divide</strong> the problem into a number of subproblems that are
smaller instances of the same problem</li>
  <li><strong>Conquer</strong> the subproblems by solving them recursively. <em>Base case: If the subproblems are small enough, just solve them by brute force</em></li>
  <li><strong>Combine</strong> the subproblem solutions to give a solution to the original problem</li>
</ul>

<p><img src="/images/algorithms/merge-chart.png" alt="Dividing and merging a list to sort the numbers" /></p>

<p>Merge sort can be implemented recursively as such:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span> <span class="c1"># Check for base case
</span>        <span class="n">q</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">((</span><span class="n">p</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Divide
</span>                                    <span class="c1"># q is the index at which we split the list
</span>        <span class="n">merge_sort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="c1"># Conquer
</span>        <span class="n">merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c1"># Conquer
</span>        <span class="n">merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c1"># Combine
</span>
<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Size of the first half
</span>    <span class="n">n2</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">q</span> <span class="c1"># Size of the second half
</span>    <span class="n">let</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span> <span class="p">..</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span> <span class="p">..</span> <span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="n">be</span> <span class="n">new</span> <span class="n">arrays</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n1</span><span class="p">:</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n2</span><span class="p">:</span>
        <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">q</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
    <span class="n">L</span><span class="p">[</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">infinity</span> <span class="c1"># in practice you could use sys.maxint
</span>    <span class="n">R</span><span class="p">[</span><span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">infinity</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span> <span class="n">to</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In the <code class="highlighter-rouge">merge</code> function, instead of checking whether either of the two lists that we’re merging is empty, we can just add a <strong>sentinel</strong> to the bottom of the list, with value ∞. This works because we’re just picking the minimum value of the two.</p>

<p><img src="/images/algorithms/insertion.gif" alt="GIF of the merge step in action" /></p>

<p>This algorithm works well in parallel, because we can split the lists on separate computers.</p>

<h4 id="correctness-1">Correctness</h4>
<p>Assuming <code class="highlighter-rouge">merge</code> is correct, we can do a proof by strong induction on $n = r - p$.</p>

<ul>
  <li><strong>Base case</strong>, $n = 0$: In this case $r = p$ so <code class="highlighter-rouge">A[p..r]</code> is trivially sorted.</li>
  <li><strong>Inductive case</strong>: By  induction hypothesis <code class="highlighter-rouge">merge_sort(A, p, q)</code> and <code class="highlighter-rouge">merge_sort(A, q+1, r)</code> successfully sort the two subarrays. Therefore a correct merge procedure will successfully sort <code class="highlighter-rouge">A[p..q]</code> as required.</li>
</ul>

<h2 id="recurrences">Recurrences</h2>
<p>Let’s try to provide an analysis of the runtime of merge sort.</p>

<ul>
  <li><strong>Divide</strong>: Takes contant time, i.e., $D(n) = \Theta(1)$</li>
  <li><strong>Conquer</strong>: Recursively solve two subproblems, each of size $n/2$, so we create a problem of size $2T(n/2)$ for each step.</li>
  <li><strong>Combine</strong>: Merge on an <em>n</em>-element subarray takes $\Theta(n)$ time, so $C(n) = \Theta(n)$</li>
</ul>

<p>Our recurrence therefore looks like this:</p>

\[T(n) = 
\begin{cases}
\Theta(1) &amp; \text{if } n = 1 \\
2T(n/2) + \Theta(n) &amp; \text{otherwise} \\
\end{cases}\]

<p>Trying to substitue $T(n/2)$ multiple times yields $T(n) = 2^k T(n/2^k) + kcn$. By now, a qualified guess would be that $T(n) = \Theta(n \log{n})$. We’ll prove this the <a href="http://moodle.epfl.ch/pluginfile.php/1735456/mod_resource/content/1/Lecture3.pdf">following way</a>:</p>

<figure>
    <img src="/images/algorithms/merge-upper-bound.png" alt="Proof by induction of the upper bound" />
    <img src="/images/algorithms/merge-lower-bound.png" alt="Proof by induction of the lower bound" />
    <figcaption>When proving this, be careful: you're not allowed to change a. Ending with (a+1) is invalid.</figcaption>
    <img src="/images/algorithms/special-upper-bound.png" alt="Alternative way of doing proof by induction" />
    <figcaption>If we do end up with (a+1) or something similarly invalid, we can try to prove something stronger.</figcaption>
</figure>

<p>All-in-all, merge sort runs in $\Theta(n \log{n})$, both in worst and best case.</p>

<p>For small instances, <a href="#insertion-sort">insertion sort</a> can still be faster despite its quadratic runtime; but for bigger instances, merge sort is definitely faster.</p>

<p>However, merge sort is not <em>in-place</em>, meaning that it does not operate directly on the list that needs to be sorted, unlike insertion sort.</p>

<!-- Lecture 4 -->

<h3 id="master-theorem">Master Theorem</h3>

<p>Generally, we can solve recurrences in a black-box manner thanks to the Master Theorem:</p>

<div class="block theorem" id="theorem:master-theorem">
  <p><a class="header" href="#theorem:master-theorem">Theorem: Master Theorem</a></p>

  <p>Let $a \geq 1$ and $b &gt; 1$ be constants, let $T(n)$ be defined on the nonnegative integers by the recurrence:</p>

\[T(n) = aT(n/b) + f(n)\]

  <p>Then, $T(n)$ has the following asymptotic bounds</p>

  <ol>
    <li>If $f(n) = \mathcal{O}(n^{\log_b{a}-\epsilon})$ for some constant $\epsilon 0$, then $T(n)=\Theta(n^{\log_b a})$</li>
    <li>If $f(n) = \Theta(n^{\log_b{a}})$, then $T(n) = \Theta(n^{\log_b a} \log n)$</li>
    <li>If $f(n) = \Omega(n^{\log_b a + \epsilon})$ for some constant $\epsilon &gt; 0$, and if $a \cdot f(n/b) \leq c\cdot f(n)$ for some constant $c &lt; 1$ and all sufficiently large $n$, then $T(n) = \Theta(f(n))$</li>
  </ol>

</div>

<p>The 3 cases correspond to the following cases in a recursion tree:</p>

<ol>
  <li>Leaves dominate</li>
  <li>Each level has the same cost</li>
  <li>Roots dominate</li>
</ol>

<h2 id="maximum-subarray-problem">Maximum-Subarray Problem</h2>

<h3 id="description">Description</h3>
<p>You have the prices that a stock traded at over a period of <em>n</em> consecutive days. When should you have bought the stock? When should you have sold the stock?</p>

<p><img src="/images/algorithms/stock-chart.png" alt="An example of stock prices over a few days" /></p>

<p>The naïve approach of buying at the lowest and selling at the highest won’t work, as the lowest price might occur <em>after</em> the highest.</p>

<ul>
  <li><strong>Input</strong>: An array <code class="highlighter-rouge">A[1..n]</code> of numbers</li>
  <li><strong>Output</strong>: Indices <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">j</code> such that <code class="highlighter-rouge">A[i..j]</code> has the greatest sum of any nonempty, contiguous subarray of <code class="highlighter-rouge">A</code>, along with the sum of the values in <code class="highlighter-rouge">A[i..j]</code></li>
</ul>

<h3 id="divide-and-conquer">Divide and Conquer</h3>
<ul>
  <li><strong>Divide</strong> the subarray into two subarrays of as equal size as possible: Find the midpoint mid of the subarrays, and consider the subarrays <code class="highlighter-rouge">A[low..mid]</code> and <code class="highlighter-rouge">A[mid+1..high]</code>
    <ul>
      <li>This can run in $\Theta(1)$</li>
    </ul>
  </li>
  <li><strong>Conquer</strong> by finding maximum subarrays of <code class="highlighter-rouge">A[low..mid]</code> and <code class="highlighter-rouge">A[mid+1..high]</code>
    <ul>
      <li>Recursively solve two subproblems, each of size $n/2$, so $2T(n/2)$</li>
    </ul>
  </li>
  <li><strong>Combine</strong>: Find a maximum subarray that crosses the midpoint, and use the best solution out of the three (that is, left, midpoint and right).
    <ul>
      <li>The merge is dominated by <code class="highlighter-rouge">find_max_crossing_subarray</code> so $\Theta(n)$</li>
    </ul>
  </li>
</ul>

<p>The overall recursion is $T(n) = 2T(n/2) + \Theta(n)$, so the algorithm runs in $\Theta(n\log{n})$.</p>

<p>In pseudo-code the algorithm is:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">find_maximum_subarray</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">high</span> <span class="o">==</span> <span class="n">low</span><span class="p">:</span> <span class="c1"># base case: only one element
</span>        <span class="k">return</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">((</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">(</span><span class="n">l_low</span><span class="p">,</span> <span class="n">l_high</span><span class="p">,</span> <span class="n">l_sum</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_maximum_subarray</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
        <span class="p">(</span><span class="n">r_low</span><span class="p">,</span> <span class="n">r_high</span><span class="p">,</span> <span class="n">r_sum</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_maximum_subarray</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x_low</span><span class="p">,</span> <span class="n">x_high</span><span class="p">,</span> <span class="n">x_sum</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_max_crossing_subarray</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>

        <span class="c1"># Find the best solution of the three:
</span>        <span class="k">if</span> <span class="n">l_sum</span> <span class="o">&gt;=</span> <span class="n">r_sum</span> <span class="ow">and</span> <span class="n">l_sum</span> <span class="o">&gt;=</span> <span class="n">x_sum</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">l_low</span><span class="p">,</span> <span class="n">l_high</span><span class="p">,</span> <span class="n">l_sum</span><span class="p">)</span>
        <span class="n">elsif</span> <span class="n">r_sum</span> <span class="o">&gt;=</span> <span class="n">l_sum</span> <span class="ow">and</span> <span class="n">r_sum</span> <span class="o">&gt;=</span> <span class="n">x_sum</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">r_low</span><span class="p">,</span> <span class="n">r_high</span><span class="p">,</span> <span class="n">r_sum</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x_low</span><span class="p">,</span> <span class="n">x_high</span><span class="p">,</span> <span class="n">x_sum</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">find_max_crossing_subarray</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">):</span>
    <span class="c1"># Find a maximum subarray of the form A[i..mid]
</span>    <span class="n">l_sum</span> <span class="o">=</span> <span class="o">-</span> <span class="n">infinity</span> <span class="c1"># Lower-bound sentinel
</span>    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">mid</span><span class="p">)</span> <span class="n">downto</span> <span class="n">low</span><span class="p">:</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">sum</span> <span class="o">&gt;</span> <span class="n">l_sum</span><span class="p">:</span>
            <span class="n">l_sum</span> <span class="o">=</span> <span class="nb">sum</span>
            <span class="n">l_max</span> <span class="o">=</span> <span class="n">i</span>

    <span class="c1"># Find a maximum subarray of the form A[mid+1..j]
</span>    <span class="n">r_sum</span> <span class="o">=</span> <span class="o">-</span> <span class="n">infinity</span> <span class="c1"># Lower-bound sentinel
</span>    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="n">to</span> <span class="n">high</span><span class="p">:</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">sum</span> <span class="o">&gt;</span> <span class="n">r_sum</span><span class="p">:</span>
            <span class="n">r_sum</span> <span class="o">=</span> <span class="nb">sum</span>
            <span class="n">r_max</span> <span class="o">=</span> <span class="n">j</span>

    <span class="c1"># Return the indices and the sum of the two subarrays
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">l_max</span><span class="p">,</span> <span class="n">r_max</span><span class="p">,</span> <span class="n">l_sum</span> <span class="o">+</span> <span class="n">r_sum</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><img src="/images/algorithms/maxsubarray.png" alt="Example of how to solve the maximum subarray problem" /></p>

<h2 id="matrix-multiplication">Matrix multiplication</h2>

<ul>
  <li><strong>Input</strong>: Two $n\times n$ (square) matrices, $A = (a_{ij})$ and $B = (b_{ij})$</li>
  <li><strong>Output</strong>: $n\times n$ matrix $C = (c_{ij})$ where $C=A\cdot B$.</li>
</ul>

<h3 id="naive-algorithm">Naive Algorithm</h3>
<p>The naive algorithm simply calculates $c_{ij}=\sum_{k=1}^n a_{ik}b_{kj}$. It runs in $\Theta(n^3)$ and uses $\Theta(n^2)$ space.</p>

<p>We can do better.</p>

<h3 id="divide-and-conquer-algorithm">Divide-and-Conquer algorithm</h3>
<ul>
  <li><strong>Divide</strong> each of A, B and C into four $n/2\times n/2$ matrices so that:</li>
</ul>

<p><img src="/images/algorithms/matrices.png" alt="Matrix blocks" /></p>

<ul>
  <li><strong>Conquer</strong>: We can recursively solve 8 <em>matrix multiplications</em> that each multiply two $n/2 \times n/2$ matrices, since:
    <ul>
      <li>$ C_{11}=A_{11}B_{11} + A_{12}B_{21}, \qquad C_{12}=A_{11}B_{12} + A_{12}B_{22} $.</li>
      <li>$ C_{21}=A_{21}B_{11} + A_{22}B_{21}, \qquad C_{22}=A_{21}B_{12} + A_{22}B_{22} $.</li>
    </ul>
  </li>
  <li><strong>Combine</strong>: Make the additions to get to C.
    <ul>
      <li>$ C_{11}=A_{11}B_{11} + A_{12}B_{21} $ is $\Theta(n^2)$.</li>
    </ul>
  </li>
</ul>

<h4 id="pseudocode-and-analysis">Pseudocode and analysis</h4>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">C</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">n</span><span class="o">*</span><span class="n">n</span> <span class="n">matrix</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">c11</span> <span class="o">=</span> <span class="n">a11</span> <span class="o">*</span> <span class="n">b11</span>
    <span class="k">else</span> <span class="n">partition</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="ow">and</span> <span class="n">C</span> <span class="n">into</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="n">submatrices</span><span class="p">:</span>
        <span class="n">C11</span> <span class="o">=</span> <span class="n">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">C12</span> <span class="o">=</span> <span class="n">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">C21</span> <span class="o">=</span> <span class="n">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">C22</span> <span class="o">=</span> <span class="n">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">rec_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The whole recursion formula is $T(n) = 8\cdot T(n/2) + \Theta(n^2) = \Theta(n^3)$. So we did all of this for something that doesn’t even beat the naive implementation!!</p>

<h3 id="strassens-algorithm-for-matrix-multiplication">Strassen’s Algorithm for Matrix Multiplication</h3>
<p>What really broke the Divide-and-Conquer approach is the fact that we had to do 8 matrix multiplications. Could we do fewer matrix multiplications by increasing the number of additions?</p>

<p><em>Spoiler Alert</em>: Yes.</p>

<p>There is a way to do only 7 recursive multiplications of $n/2\times n/2$ matrices, rather than 8. Our recurrence relation is now:</p>

\[T(n) = 7\cdot T(n/2) + \Theta(n^2) = \Theta(n^{log_2(7)}) = \Theta(n^{2.807\dots})\]

<p>Strassen’s method is the following:</p>

<p><img src="/images/algorithms/strassen.png" alt="Strassen's method" /></p>

<p>Note that when our matrix’s size isn’t a power of two, we can just pad our operands with zeros until we do have a power of two size. This still runs in $\Theta(n^{log_2{(7)}})$.</p>

<h4 id="notes-about-strassen">Notes about Strassen</h4>
<ul>
  <li>First to beat $\Theta(n^3)$ time</li>
  <li>Faster methods are known today: Coppersmith and Winograd’s method runs in
time $\mathcal{O}(n^{2.376})$, which has recently been improved by Vassilevska Williams to $\mathcal{O}(n^{2.3727})$.</li>
  <li>How to multiply matrices in best way is still a big open problem</li>
  <li>The naive method is better for small instances because of hidden constants in Strassen’s method’s runtime.</li>
</ul>

<h2 id="heaps-and-heapsort">Heaps and Heapsort</h2>

<h3 id="heaps">Heaps</h3>
<p>A heap is a <em>nearly complete binary tree</em> (meaning that the last level may not be complete). The main property of a heap is:</p>

<ul>
  <li><strong>Max-heap</strong>: the key of <code class="highlighter-rouge">i</code>’s children is smaller or equal to <code class="highlighter-rouge">i</code>’s key.</li>
  <li><strong>Min-heap</strong>: the key of <code class="highlighter-rouge">i</code>’s children is greater or equal to <code class="highlighter-rouge">i</code>’s key.</li>
</ul>

<p>In a max-heap, the maximum element is at the root, while the minimum element takes that place in a min-heap.</p>

<p><img src="/images/algorithms/heats.png" alt="Max-heats and min-heats' ordering" /></p>

<p>The height of a node is the number of edges on a longest simple path from the node down to a leaf. The height of the heap is therefore simply the height of the root, $\Theta(\log{n})$.</p>

<p>We can store the heap in a list, where:</p>

<ul>
  <li><code class="highlighter-rouge">Root</code> is <code class="highlighter-rouge">A[1]</code></li>
  <li><code class="highlighter-rouge">Left(i)</code> is <code class="highlighter-rouge">2i</code></li>
  <li><code class="highlighter-rouge">Right(i)</code> is <code class="highlighter-rouge">2i + 1</code></li>
  <li><code class="highlighter-rouge">Parent(i)</code> is <code class="highlighter-rouge">floor(i/2)</code></li>
</ul>

<h4 id="max-heapify">Max-Heapify</h4>
<p>It’s a very important algorithm for manipulating heaps. Given an <em>i</em> such that the subtrees of <em>i</em> are heaps, it ensures that the subtree rooted at <em>i</em> is a heap satisfying the heap property.</p>

<ul>
  <li>Compare <code class="highlighter-rouge">A[i]</code>, <code class="highlighter-rouge">A[Left(i)]</code>, <code class="highlighter-rouge">A[Right(i)]</code></li>
  <li>If necessary, swap <code class="highlighter-rouge">A[i]</code> with the largest of the two children to preserve heap property.</li>
  <li>Continue this process of comparing and swapping down the heap, until the subtree rooted at <em>i</em> is a max-heap.</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="c1"># A is the array in which the heap is implemented
# i is the index where we want to heapify
# n is the size of A
</span><span class="k">def</span> <span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">Left</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Right</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="c1"># if left is larger than parent
</span>        <span class="n">largest</span> <span class="o">=</span> <span class="n">l</span>
    <span class="k">else</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span> <span class="c1"># if right is larger than both left and parent
</span>        <span class="n">largest</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span> <span class="c1"># If we have to make a swap
</span>        <span class="n">exchange</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">with</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span>
        <span class="n">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">largest</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This runs in $\Theta(\text{height of } i) = \mathcal{O}(\log{n})$ and uses $\Theta(n)$ space.</p>

<h4 id="building-a-heap">Building a heap</h4>
<p>Given an unordered array <code class="highlighter-rouge">A</code> of length <code class="highlighter-rouge">n</code>, <code class="highlighter-rouge">build_max_heap</code> outputs a heap.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">build_max_heap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="n">downto</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This procedure operates in place. We can start at $\lfloor{\frac{n}{2}}\rfloor$ since all elements after that threshold are leaves, so we’re not going to heapify those anyway.</p>

<p>We have $\mathcal{O}(n)$ calls to <code class="highlighter-rouge">max_heapify</code>, each of which takes $\mathcal{O}(\log{n})$ time, so we have $\mathcal{O}(n\log{n})$ in total. 
However, <strong>we can give a tighter bound</strong>: the time to run <code class="highlighter-rouge">max_heapify</code> is linear in the height of the node it’s run on. Hence, the time is bounded by:</p>

\[\sum_{h=0}^{\log{n}} \text{# of nodes of height h}\cdot\mathcal{O}(h) 
= \mathcal{O}\left( n \sum_{h=0}^{\log{n}} \frac{h}{2^h}\right)\]

<p>Which is $\Theta(n)$, since:</p>

\[\sum_{h=0}^\infty{\frac{h}{2^h}} = \frac{1/2}{(1-1/2)^2} = 2\]

<p><em>See the slides for a proof by induction.</em></p>

<h3 id="heapsort">Heapsort</h3>
<p>Heapsort is the best of both worlds: it’s $O(n\log{n})$ like merge sort, and sorts in place like insertion sort.</p>

<ul>
  <li>Starting with the root (the maximum element), the algorithm
places the maximum element into the correct place in the array by
swapping it with the element in the last position in the array.</li>
  <li>“Discard” this last node (knowing that it is in its correct place) by
<em>decreasing the heap size</em>, and calling <code class="highlighter-rouge">max_heapify</code> on the new
(possibly incorrectly-placed) root.</li>
  <li>Repeat this “discarding” process until only one node (the smallest
element) remains, and therefore is in the correct place in the array</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">heapsort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">build_max_heap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="n">downto</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">exchange</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">with</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li><code class="highlighter-rouge">build_max_heap</code>: $\mathcal{O}(n)$</li>
  <li><code class="highlighter-rouge">for</code> loop: $n-1$ times</li>
  <li>Exchange elements: $\mathcal{O}(1)$</li>
  <li><code class="highlighter-rouge">max_heapify</code>: $\mathcal{O}(\log{n})$</li>
</ul>

<p>Total time is therefore $\mathcal{O}(n\log{n})$.</p>

<h3 id="priority-queues">Priority queues</h3>
<p>In a priority queue, we want to be able to:</p>

<ul>
  <li>Insert elements</li>
  <li>Find the maximum</li>
  <li>Remove and return the largest element</li>
  <li>Increase a key</li>
</ul>

<p>A heap efficiently implements priority queues.</p>

<h4 id="finding-maximum-element">Finding maximum element</h4>
<p>This can be done in $\Theta(1)$ by simply returning the root element.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">heap_maximum</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="extracting-maximum-element">Extracting maximum element</h4>
<p>We can use <a href="#max-heapify">max heapify</a> to rebuild our heap after removing the root. This runs in $\mathcal{O}(\log{n})$, as every other operation than <code class="highlighter-rouge">max-heapify</code> runs in $\mathcal{O}(1)$.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">heap_extract_max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Check that the heap is non-empty
</span>        <span class="n">error</span> <span class="s">"Heap underflow"</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="c1"># Make the last node in the tree the new root
</span>    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># Remove the last node of the tree
</span>    <span class="n">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="c1"># Re-heapify the heap
</span>    <span class="k">return</span> <span class="nb">max</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="increasing-a-value">Increasing a value</h4>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">heap_increase_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">error</span> <span class="s">"new key is smaller than current key"</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
    <span class="c1"># Traverse the tree upward comparing new key to parent and swapping keys 
</span>    <span class="c1"># if necessary, until the new key is smaller than the parent's key:
</span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">Parent</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">exchange</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">with</span> <span class="n">A</span><span class="p">[</span><span class="n">Parent</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This traverses the tree upward, and runs in $\mathcal{O}(\log{n})$.</p>

<h4 id="inserting-into-the-heap">Inserting into the heap</h4>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">max_heap_insert</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Increment the size of the heap
</span>    <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">infinity</span> <span class="c1"># Insert a sentinel node in the last pos
</span>    <span class="n">heap_increase_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="c1"># Increase the value to key</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We know that this runs in the time for <code class="highlighter-rouge">heap_increase_key</code>, which is $\mathcal{O}(\log{n})$.</p>

<h3 id="summary">Summary</h3>
<ul>
  <li>Heapsort runs in $\mathcal{O}(n\log{n})$ and is in-place. However, a well implemented quicksort usually beats it in practice.</li>
  <li>Heaps efficiently implement priority queues:
    <ul>
      <li><code class="highlighter-rouge">insert(S, x)</code>: $\mathcal{O}(\log{n})$</li>
      <li><code class="highlighter-rouge">maximum(S)</code>: $\mathcal{O}(1)$</li>
      <li><code class="highlighter-rouge">extract_max(S)</code>: $\mathcal{O}(\log{n})$</li>
      <li><code class="highlighter-rouge">increase_key(S, x, k)</code>: $\mathcal{O}(\log{n})$</li>
    </ul>
  </li>
</ul>

<h2 id="more-data-structures">More data structures</h2>

<h3 id="stacks">Stacks</h3>
<p>Stacks are LIFO (last-in, first out). It has two basic operations:</p>

<ul>
  <li>Insertion with <code class="highlighter-rouge">push(S, x)</code></li>
  <li>Delete operation with <code class="highlighter-rouge">pop(S)</code></li>
</ul>

<p>We can implement a stack using an array where <code class="highlighter-rouge">S[1]</code> is the bottom element, and <code class="highlighter-rouge">S[S.top]</code> is the element at the top.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">stack_empty</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">false</span>

<span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Increment the pointer to the top
</span>    <span class="n">S</span><span class="p">[</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># Store element
</span>
<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">stack_empty</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="n">error</span> <span class="s">"underflow"</span>
    <span class="k">else</span>
        <span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># Decrement the pointer to the top
</span>        <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="n">S</span><span class="p">.</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># Return what we've removed</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>These operations are all $\mathcal{O}(1)$.</p>

<h3 id="queues">Queues</h3>
<p>Queues are FIFO (first-in, first-out). They have two basic operations:</p>

<ul>
  <li>Insertion with <code class="highlighter-rouge">enqueue(Q, x)</code></li>
  <li>Deletion with <code class="highlighter-rouge">dequeue(Q)</code></li>
</ul>

<p>Again, queues can be implemented using arrays with two pointers: <code class="highlighter-rouge">Q[Q.head]</code>  is the first element, <code class="highlighter-rouge">Q[Q.tail]</code> is the next location where a newly arrived element will be placed.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">Q</span><span class="p">[</span><span class="n">Q</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">x</span><span class="p">]</span>
    <span class="c1"># Now, update the tail pointer:
</span>    <span class="k">if</span> <span class="n">Q</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">length</span><span class="p">:</span> <span class="c1"># Q.length is the length of the array
</span>        <span class="n">Q</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Wrap it around
</span>    <span class="k">else</span> <span class="n">Q</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">Q</span><span class="p">.</span><span class="n">head</span><span class="p">]</span>
    <span class="c1"># Now, update the head pointer
</span>    <span class="k">if</span> <span class="n">Q</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">length</span><span class="p">:</span>
        <span class="n">Q</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="n">Q</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Notice that we’re not deleting anything <em>per se</em>. We’re just moving the boundaries of the queue and sometimes replacing elements.</p>

<p>Positives:</p>

<ul>
  <li>Very efficient</li>
  <li>Natural operations</li>
</ul>

<p>Negatives:</p>

<ul>
  <li>Limited support: for example, no search</li>
  <li>Implementations using arrays have <em>fixed</em> capacity</li>
</ul>

<h3 id="linked-lists">Linked Lists</h3>
<figure>
    <img src="/images/algorithms/linked-list.png" alt="Linked list" />
    <figcaption>This linked list is doubly linked and unsorted. The <code>/</code> symbol represents Nil.</figcaption>
</figure>

<p>Let’s take a look at the operations in linked lists.</p>

<h4 id="search">Search</h4>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">list_search</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">head</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">nil</span> <span class="ow">and</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nb">next</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This runs in $\mathcal{O}(n)$. If no element with key <code class="highlighter-rouge">k</code> exists, it will return <code class="highlighter-rouge">nil</code>.</p>

<h4 id="insertion">Insertion</h4>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">list_insert</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">x</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">head</span>
    <span class="k">if</span> <span class="n">L</span><span class="p">.</span><span class="n">head</span> <span class="o">!=</span> <span class="n">nil</span><span class="p">:</span>
        <span class="n">L</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">L</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># Rewrite the head pointer
</span>    <span class="n">x</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">nil</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This runs in $\mathcal{O}(1)$. This linked list doesn’t implement a tail pointer, so it’s important to add the element to the start of the list and not the end, as that would mean traversing the list before adding the element.</p>

<h4 id="deletion">Deletion</h4>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">list_delete</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">nil</span><span class="p">:</span>
        <span class="n">x</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nb">next</span>
    <span class="k">else</span> <span class="n">L</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nb">next</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="nb">next</span> <span class="o">!=</span> <span class="n">nil</span><span class="p">:</span>
        <span class="n">x</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">prev</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is $\mathcal{O}(1)$.</p>

<h4 id="summary-1">Summary</h4>
<ul>
  <li>Insertion: $\mathcal{O}(1)$</li>
  <li>Deletion: $\mathcal{O}(1)$</li>
  <li>Search: $\mathcal{O}(n)$</li>
</ul>

<p>Search in linear time is no fun! Let’s see how else we can do this.</p>

<h3 id="binary-search-trees">Binary search trees</h3>
<p>The key property of binary search trees is:</p>

<ul>
  <li>If <code class="highlighter-rouge">y</code> is in the left subtree of <code class="highlighter-rouge">x</code>, then <code class="highlighter-rouge">y.key &lt; x.key</code></li>
  <li>If <code class="highlighter-rouge">y</code> is in the right subtree of <code class="highlighter-rouge">x</code>, then <code class="highlighter-rouge">y.key &gt;= x.key</code></li>
</ul>

<p>The tree <code class="highlighter-rouge">T</code> has a root <code class="highlighter-rouge">T.root</code>, and a height <code class="highlighter-rouge">h</code> (not necessarily log(<em>n</em>), it can vary depending on the organization of the tree).</p>

<h4 id="querying-a-binary-search-tree">Querying a binary search tree</h4>
<p>All of the following algorithms can be implemented in $\mathcal{O}(h)$.</p>

<h5 id="searching">Searching</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">tree_search</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="maximum-and-minimum">Maximum and minimum</h5>
<p>By the key property, the minimum is in the leftmost node, and the maximum in rightmost.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">tree_minimum</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">x</span><span class="p">.</span><span class="n">left</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">left</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">tree_maximum</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h5 id="successor">Successor</h5>
<p>The successor or a node <code class="highlighter-rouge">x</code> is the node <code class="highlighter-rouge">y</code> such that <code class="highlighter-rouge">y.key</code> is the smallest key that is strictly larger than <code class="highlighter-rouge">x.key</code>.</p>

<p>There are 2 cases when finding the successor of <code class="highlighter-rouge">x</code>:</p>

<ol>
  <li><strong><code class="highlighter-rouge">x</code> has a non-empty right subtree</strong>: <code class="highlighter-rouge">x</code>’s successor is the minimum in the right subtree</li>
  <li><strong><code class="highlighter-rouge">x</code> has an empty right subtree</strong>: We go left up the tree as long as we can (until node <code class="highlighter-rouge">y</code>), and and <code class="highlighter-rouge">x</code>’s successor is the parent of <code class="highlighter-rouge">y</code> (or <code class="highlighter-rouge">y</code> if it is the root)</li>
</ol>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">tree_successor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tree_minimum</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">parent</span>
    <span class="k">while</span> <span class="n">y</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">parent</span>
    <span class="k">return</span> <span class="n">y</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In the worst-case, this will have to traverse the tree upward, so it indeed runs in $\mathcal{O}(h)$.</p>

<h4 id="printing-a-binary-search-tree">Printing a binary search tree</h4>
<p>Let’s consider the following tree:</p>

<p><img src="/images/algorithms/binary_tree.png" alt="A sample binary search tree" /></p>

<h5 id="inorder">Inorder</h5>
<ul>
  <li>Print left subtree recursively</li>
  <li>Print root</li>
  <li>Print right subtree recursively</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span>
        <span class="n">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This would print:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">1, 2, 3, 4, 5, 6, 7, 8, 9 10, 11, 12</code></pre></figure>

<p>This runs in $\Theta(n)$.</p>

<details><summary><p>Proof of runtime</p>
</summary><div class="details-content">
<p>We have $T(n) =$ runtime of <code class="highlighter-rouge">inorder_tree_walk</code> on a tree with $n$ nodes.</p>

\[T(n)\leq (c+d)n + c, \qquad c, d &gt; 0\]

<p><strong>Base</strong>: $n = 0, \quad T(0) = c$</p>

<p><strong>Induction</strong>: Suppose that the tree rooted at $x$ has $k$ nodes in its left subtree, and $n-k-1$ nodes in the right.</p>

\[\begin{align}
T(n)     &amp; \leq T(k) + T(n-k-1) + c  \\
T(k)     &amp; \leq (c+d)k + c \\
T(n-k-1) &amp; \leq (c+d)(n-k-1) + c \\
\end{align}\]

<p>Therefore:</p>

\[\begin{align}
T(n) &amp; \leq (c+d)k + c + (c+d)(n-k-1) + c + d
     &amp; = (c+d)n + c - (c+d) + 2c
     &amp; \leq (c+d)n + c + (c -d) \leq (c+d)n + c
\end{align}\]

<p>Therefore, we do indeed have $\Theta(n)$.</p>

<p>Preorder and postorder follow a very similar idea.</p>
</div></details>

<h5 id="preorder">Preorder</h5>
<ul>
  <li>Print root</li>
  <li>Print left subtree recursively</li>
  <li>Print right subtree recursively</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span>
        <span class="n">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This would print:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">8, 4, 2, 1, 3, 6, 5, 12, 10, 9, 11</code></pre></figure>

<h5 id="postorder">Postorder</h5>
<ul>
  <li>Print left subtree recursively</li>
  <li>Print right subtree recursively</li>
  <li>Print root</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">inorder_tree_walk</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This would print:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">1, 3, 2, 5, 6, 4, 9, 11, 10, 12, 8</code></pre></figure>

<h4 id="modifying-a-binary-seach-tree">Modifying a binary seach tree</h4>
<p>The data structure must be modified to reflect the change, but in such a way that the binary-search-tree property continues to hold.</p>

<h5 id="insertion-1">Insertion</h5>
<ul>
  <li>Search for <code class="highlighter-rouge">z.key</code></li>
  <li>When arrived at <code class="highlighter-rouge">Nil</code> insert <code class="highlighter-rouge">z</code> at that position</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">tree_insert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="c1"># Search phase:
</span>    <span class="n">y</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">root</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span>
    <span class="n">z</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">y</span>

    <span class="c1"># Insert phase
</span>    <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="n">Nil</span><span class="p">:</span>
        <span class="n">T</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">z</span> <span class="c1"># Tree T was empty
</span>    <span class="n">elsif</span> <span class="n">z</span><span class="p">.</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
        <span class="n">y</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">z</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">z</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This runs in $\mathcal{O}(h)$.</p>

<h5 id="deletion-1">Deletion</h5>
<p>Conceptually, there are 3 cases:</p>

<ol>
  <li>If <code class="highlighter-rouge">z</code> has no children, remove it</li>
  <li>If <code class="highlighter-rouge">z</code> has one child, then make that child take <code class="highlighter-rouge">z</code>’s position in the tree</li>
  <li>If <code class="highlighter-rouge">z</code> has two children, then find its successor <code class="highlighter-rouge">y</code> and replace <code class="highlighter-rouge">z</code> by <code class="highlighter-rouge">y</code></li>
</ol>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="c1"># Replaces subtree rooted at u with that rooted at v
</span><span class="k">def</span> <span class="nf">transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">Nil</span><span class="p">:</span> <span class="c1"># If u is the root
</span>        <span class="n">T</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">v</span>
    <span class="n">elsif</span> <span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">left</span><span class="p">:</span> <span class="c1"># If u is to the left
</span>        <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># If u is to the right
</span>        <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">v</span> 
    <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">Nil</span><span class="p">:</span> <span class="c1"># If v isn't the root
</span>        <span class="n">v</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span>

<span class="c1"># Deletes the subtree rooted at z
</span><span class="k">def</span> <span class="nf">tree_delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">Nil</span><span class="p">:</span> <span class="c1"># z has no left child
</span>        <span class="n">transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1"># move up the right child
</span>    <span class="k">if</span> <span class="n">z</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">Nil</span><span class="p">:</span> <span class="c1"># z has just a left child
</span>        <span class="n">transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1"># move up the left child
</span>    <span class="k">else</span><span class="p">:</span> <span class="c1"># z has two children
</span>        <span class="n">y</span> <span class="o">=</span> <span class="n">tree_minimum</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1"># y is z's successor
</span>        <span class="k">if</span> <span class="n">y</span><span class="p">.</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">z</span><span class="p">:</span>
            <span class="c1"># y lies within z's right subtree but not at the root of it
</span>            <span class="c1"># We must therefore extract y from its position
</span>            <span class="n">transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">y</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">right</span>
            <span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">y</span>
        <span class="c1"># Replace z by y:
</span>        <span class="n">transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">y</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">left</span>
        <span class="n">y</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">y</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="summary-2">Summary</h4>
<ul>
  <li><strong>Query operations</strong>: Search, max, min, predecessor, successor: $\mathcal{O}(h)$</li>
  <li><strong>Modifying operations</strong>: Insertion, deletion: $\mathcal{O}(h)$</li>
</ul>

<p>There are efficient procedures to keep the tree balanced (AVL trees, red-black trees, etc.).</p>

<h3 id="summary-3">Summary</h3>
<ul>
  <li><strong>Stacks</strong>: LIFO, insertion and deletion in $\mathcal{O}(1)$, with an array implementation with fixed capacity</li>
  <li><strong>Queues</strong>: FIFO, insertion and deletion in $\mathcal{O}(1)$, with an array implementation with fixed capacity</li>
  <li><strong>Linked Lists</strong>: No fixed capcity, insertion and deletion in $\mathcal{O}(1)$, supports search but $\mathcal{O}(n)$ time.</li>
  <li><strong>Binary Search Trees</strong>: No fixed capacity, supports most operations (insertion, deletion, search, max, min) in time $\mathcal{O}(h)$.</li>
</ul>

<h2 id="dynamic-programming">Dynamic Programming</h2>
<p>The main idea is to remember calculations already made. This saves enormous amounts of computation, as we don’t have to do the same calculations again and again.</p>

<p>There are two different ways to implement this:</p>

<h3 id="top-down-with-memoization">Top-down with memoization</h3>
<p>Solve recursively but store each result in a table. <em>Memoizing</em> is remembering what we have computed previously.</p>

<p>As an example, let’s calculate Fibonacci numbers with this technique:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">memoized_fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">..</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">infinity</span> <span class="c1"># Initialize memory to -inf
</span>    <span class="k">return</span> <span class="n">memoized_fib_aux</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">memoized_fib_aux</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">memoized_fib_aux</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">memoized_fib_aux</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This runs in $\Theta(n)$.</p>

<h3 id="bottom-up">Bottom-up</h3>
<p>Sort the subproblems and solve the smaller ones first. That way, when solving a subproblem, we have already solved the smaller subproblems we need.</p>

<p>As an example, let’s calculate Fibonacci numbers with this technique:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">bottom_up_fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">array</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is also $\Theta(n)$.</p>

<h3 id="rod-cutting-problem">Rod cutting problem</h3>
<p>The instance of the problem is:</p>

<ul>
  <li>A length $n$ of a metal rods</li>
  <li>A table of prices $p_i$ for rods of lengths $i = 1, …, n$</li>
</ul>

<p><img src="/images/algorithms/rod_prices.png" alt="List of prices for different rod lengths" /></p>

<p>The objective is to decide how to cut the rod into pieces and maximize the price.</p>

<p>There are $2^{n-1}$ possible solutions (not considering symmetry), so we can’t just try them all. Let’s introduce the following theorem in an attempt at finding a better way:</p>

<hr />

<h4 id="structural-theorem">Structural Theorem</h4>
<p>If:</p>

<ul>
  <li>The leftmost cut in an optimal solution is after $i$ units</li>
  <li>An optimal way to cut a solution of size $n-i$ is into rods of sizes $s_1, s_2, …, s_k$</li>
</ul>

<p>Then, an optimal way to cut our rod is into rods of size $i, s_1, s_2, …, s_k$.</p>

<hr />

<p>Essentially, the theorem say that to obtain an optimal solution, we need to cut the remaining pieces in an optimal way. This is the <a href="https://en.wikipedia.org/wiki/Optimal_substructure">optimal substructure property</a>. Hence, if we let $r(n)$ be the optimal revenue from a rod of length $n$, we can express $r(n)$ <em>recursively</em> as follows:</p>

\[r(n) = \begin{cases}
0 &amp; \text{if } n = 0\\
max_{1\leq i \leq n}\{p_i + r(n-i)\} &amp; \text{otherwise if } n \geq 1\\
\end{cases}\]

<h4 id="algorithm">Algorithm</h4>
<p>Let’s try to implement a first algorithm. This is a direct implementation of the recurrence relation above:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">cut_rod</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="nb">id</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">cut_rod</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">q</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>But implementing this, we see that it isn’t terribly efficient — in fact, it’s exponential. Let’s try to do this with dynamic programming. Here, we’ll do it in a memoized top-down approach.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">memoized_cut_rod</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">r</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">array</span>
    <span class="n">Initialize</span> <span class="nb">all</span> <span class="n">entries</span> <span class="n">to</span> <span class="o">-</span><span class="n">infinity</span>
    <span class="k">return</span> <span class="n">memoized_cut_rod_aux</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">memoized_cut_rod_aux</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if it has been calculated
</span>        <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="o">-</span> <span class="n">infinity</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">memoized_cut_rod_aux</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
    <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
    <span class="k">return</span> <span class="n">q</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Every problem needs to check all the subproblems. Thanks to dynamic programming, we can just sum them instead of multiplying them, as every subproblem is computed once at most. As we’ve seen earlier on with <a href="#analysis">insertion sort</a>, this is:</p>

\[\sum_{i=1}^n {\Theta(i)} = \Theta(n^2)\]

<p>The total time complexity is $\mathcal{O}(n^2)$. This is even clearer with the bottom up approach:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">bottom_up_cut_rod</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">r</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">array</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="o">-</span> <span class="n">infinity</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There’s a for-loop in a for-loop, so we clearly have $\Theta(n^2)$.</p>

<p>Top-down only solves the subproblems actually needed, but recursive calls introduce overhead.</p>

<h4 id="extended-algorithm">Extended algorithm</h4>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">extended_bottom_up_cut_rod</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">r</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">new</span> <span class="n">arrays</span>
    <span class="c1"># r[n] will be the price you can get for a rod of length n
</span>    <span class="c1"># s[n] the cuts of optimum location for a rod of length n
</span>    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="n">infinity</span>
        <span class="k">for</span> <span class="n">i</span> <span class="n">to</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">]:</span> <span class="c1"># best cut so far?
</span>                <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="c1"># save its price
</span>                <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># and save the index!
</span>    <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">print_cut_rod_solution</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">extended_bottom_up_cut_rod</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="when-can-dynamic-programming-be-used">When can dynamic programming be used?</h3>
<ul>
  <li>Optimal substructure
    <ul>
      <li>An optimal solution can be built by combining optimal solutions for the subproblems</li>
      <li>Implies that the optimal value can be given by a recursive formula</li>
    </ul>
  </li>
  <li>Overlapping subproblems</li>
</ul>

<h3 id="matrix-chain-multiplication">Matrix-chain multiplication</h3>
<ul>
  <li><strong>Input</strong>: A chain $(A_1, A_2, …, A_n)$ of $n$ matrices, where for $i=1, 2, …, n$, matrix $A_i$ has dimension $p_{i-1}\times p_i$.</li>
  <li><strong>Output</strong>: A full parenthesization of the product $A_1 A_2 … A_n$ in a way that minimizes the number of scalar multiplications.</li>
</ul>

<p>We are not asked to calculate the product, only find the best parenthesization. Multiplying a matrix of size $p\times q$ with one of $q\times r$ takes $pqr$ scalar multiplications.</p>

<p>We’ll have to use the following theorem:</p>

<hr />

<h4 id="optimal-substructure-theorem">Optimal substructure theorem</h4>
<p>If:</p>

<ul>
  <li>The outermost parenthesization in an optimal solution is $(A_1 A_2 … A_i)(A_{i+1}A_{i+2}…A_n)$</li>
  <li>$P_L$ and $P_R$ are optimal pernthesizations for $A_1 A_2 … A_i$ and $A_{i+1}A_{i+2}…A_n$ respectively</li>
</ul>

<p>Then $((P_L)\cdot (P_R))$ is an optimal parenthesization for $A_1 A_2 … A_n$</p>

<hr />

<p>See <a href="http://moodle.epfl.ch/pluginfile.php/1745790/mod_resource/content/1/Lecture11.pdf">the slides</a> for proof.</p>

<p>Essentially, to obtain an optimal solution, we need to parenthesize the two remaining expressions in an optimal way.</p>

<p>Hence, if we let $m[i, j]$ be the optimal value for chain multiplication of matrices $A_i, …, A_j$ (meaning, how many multiplications we can do at best), we can express $m[i, j]$ <em>recursively</em> as follows:</p>

\[m[i, j] = 
\begin{cases}
0 &amp; \text{if } i=j \\
\min_{i \leq k &lt; j} \{m[i, k] + m[k+1, j] + p_{i-1} p_k p_j\} &amp; \text{otherwise if } i &lt; j \\
\end{cases}\]

<p>That is the minimum of the left, the right, and the number of operations to combine them.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">matrix_chain_order</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">let</span> <span class="n">m</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">,</span> <span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">,</span> <span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">new</span> <span class="n">tables</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># Initialize all to 0
</span>        <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># l is the chain length
</span>        <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">infinity</span>
            <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="n">to</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span> <span class="c1"># store the number of multiplications
</span>                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="c1"># store the optimal choice
</span>    <span class="k">return</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">s</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The runtime of this is $\Theta(n^3)$.</p>

<p><img src="/images/algorithms/matrix-mult-tables.png" alt="Matrix multiplication tables, flipped by 45 degrees" /></p>

<p>To know how to split up $A_i A_{i+1} … A_j$ we look in <code class="highlighter-rouge">s[i, j]</code>. This split corresponds to <code class="highlighter-rouge">m[i, j]</code> operations. To print it, we can do:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">print_optimal_parens</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">"A_"</span> <span class="o">+</span> <span class="n">i</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">"("</span>
        <span class="n">print_optimal_parens</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="n">print_optimal_parens</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">")"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="longest-common-subsequence">Longest common subsequence</h3>
<ul>
  <li><strong>Input</strong>: 2 sequences, $X = (x_1, …, x_m)$ and $Y = (y_1, …, y_n)$</li>
  <li><strong>Output</strong>: A subsequence common to both whose length is longest. A subsequence doesn’t have to be consecutive, but it has to be in order.</li>
</ul>

<hr />

<h4 id="theorem">Theorem</h4>
<p>Let $Z = (z_1, z_2, …, z_k)$ be any LCS of $X_i$ and $Y_j$</p>

<ol>
  <li>If $x_i = y_j$ then $z_k = x_i = y_j$ and $Z_{k-1}$ is an LCS of $X_{i-1}$ and $Y_{j-1}$</li>
  <li>If $x_i \neq y_j$ then $z_k \neq x_i$ and $Z$ is an LCS of $X_{i-1}$ and $Y_j$</li>
  <li>If $x_i \neq y_j$ then $z_k \neq y_i$ and $Z$ is an LCS of $X_i$ and $Y_{j-1}$</li>
</ol>

<details><summary><p>Proof</p>
</summary><div class="details-content">
<ol>
  <li>If $z_k \neq x_i$ then we can just append $x_i = y_j$ to $Z$ to obtain a common subsequence of $X$ and $Y$ of length $k+1$, which would contradict the supposition that $Z$ is the <em>longest</em> common subsequence. Therefore, $z_k = x_i = y_j$</li>
</ol>

<p>Now onto the second part: $Z_{k-1}$ is an LCS of $X_{i-1}$ and $Y_{j-1}$ of length $(k-1)$. Let’s prove this by contradiction; suppose that there exists a common subsequence $W$ with length greater than $k-1$. Then, appending $x_i = y_j$ to W produces a common subsequence of X and Y whose length is greater than $k$, which is a contradiction.</p>

<ol>
  <li>
    <p>If there were a common subsequence $W$ of $X_{i-1}$ and $Y$ with length greater than $k$, then $W$ would also be a common subsequence of $X$ and $Y$ length greater than $k$, which contradicts the supposition that $Z$ is the LCS.</p>
  </li>
  <li>
    <p>This proof is symmetric to 2.</p>
  </li>
</ol>
</div></details>

<hr />

<p>If $c[i, j]$ is the length of a LCS of $X_i$ and $Y_i$, then:</p>

\[c[i, j] =
\begin{cases}
0 &amp; \text{if } i = 0 \text{ or } j = 0 \\
c[i-1, j-1] + 1 &amp; \text{if } i,j&gt;0 \text{ and } x_i = y_j \\
\max{(c[i-1, j], c[i, j-1])} &amp; \text{if } i,j&gt;0 \text{ and } x_i \neq y_j \\
\end{cases}\]

<p>Using this recurrence, we can fill out a table of dimensions $i \times j$. The first row and the first colum will obviously be filled with <code class="highlighter-rouge">0</code>s. Then we traverse the table row by row to fill out the values according to the following rules.</p>

<ol>
  <li>If the characters at indices <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">j</code> are equal, then we take the diagonal value (above and left) and add 1.</li>
  <li>If the characters at indices <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">j</code> are different, then we take the max of the value above and that to the left.</li>
</ol>

<p>Along with the values in the table, we’ll also store where the information of each cell was taken from: left, above or diagonally (the max defaults to the value above if left and above are equal). This produces a table of of numbers and arrows that we can follow from bottom right to top left:</p>

<figure>
    <img src="/images/algorithms/lcs-table.png" alt="An i*j table of values and arrows, as generated by the LCS algorithm below" />
    <figcaption>$X = (B, A, B, D, B, A), \quad Y = (D, A, C,B, C, B, A)$</figcaption>
</figure>

<p>The diagonal arrows in the path correspond to the characters in the LCS. In our case, the LCS has length 4 and it is <code class="highlighter-rouge">ABBA</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">lcs_length</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">b</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="mf">0.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">new</span> <span class="n">tables</span>
    <span class="c1"># Initialize 1st row and column to 0
</span>    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">"↖"</span> <span class="c1"># up left
</span>            <span class="n">elsif</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">"↑"</span> <span class="c1"># up
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">"←"</span> <span class="c1"># left
</span>    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>


<span class="k">def</span> <span class="nf">print_lcs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"↖"</span><span class="p">:</span> <span class="c1"># up left
</span>        <span class="k">print</span><span class="o">-</span><span class="n">lcs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">elsif</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"↑"</span><span class="p">:</span> <span class="c1"># up
</span>        <span class="k">print</span><span class="o">-</span><span class="n">lcs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="n">elsif</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">"←"</span><span class="p">:</span> <span class="c1"># left
</span>        <span class="k">print</span><span class="o">-</span><span class="n">lcs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The runtime of <code class="highlighter-rouge">lcs-length</code> is dominated by the two nested loops; runtime is $\Theta(m\cdot n)$.</p>

<p>The runtime of <code class="highlighter-rouge">print-lcs</code> is $\mathcal(O)(n)$, where $n=i+j$.</p>

<h3 id="optimal-binary-search-trees">Optimal binary search trees</h3>
<p>Given a sequence of keys $K=(k_1, k_2, \dots, k_n)$ of distinct keys, sorted so that $k_1 &lt; k_2 &lt; \dots &lt; k_n$. We want to build a BST. Some keys are more popular than others: key $K_i$ has probability $p_i$ of being searched for. Our BST should have a minimum expected search cost.</p>

<p>The cost of searching for a key $k_i$ is $\text{depth}_T (k_i) + 1$ (we add one because the root is at height 0 but has a cost of 1). The expected search cost would then be:</p>

\[\mathbb{E}[\text{seach cost in } T] 
    = \sum_{i=1}^n {(\text{depth}_T(k_i) + 1)}p_i = 1 + \sum_{i=1}^n {\text{depth}_T(k_i)}\cdot p_i\]

<p>Optimal BSTs might not have the smallest height, and optimal BSTs might not have highest-probability key at root.</p>

<p>Let $e[i, j]$ denote the expected search cost of an optimal BST of $k_i \dots k_j$.</p>

\[e[i, j] = \begin{cases}
0 &amp; \text{if } i = j + 1 \\
min_{i\leq r \leq j}{(e[i, r-1] + e[r+1, j]) + \sum_{\ell =i}^j {p_\ell}}&amp; \text{if } i \leq j\\
\end{cases}\]

<p>With the following inputs:</p>

<p><img src="/images/algorithms/optimal-bst-input.png" alt="An example set of inputs" /></p>

<p>We can fill out the table as follows:</p>

<p><img src="/images/algorithms/optimal-bst-table.png" alt="The optimal BST table filled out according to the recurrence relationship" /></p>

<p>To compute something in this table, we should have already computed everything to the left, and everything below. We can start out by filling out the diagonal, and then filling out the diagonals to its right.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">optimal_bst</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">e</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">table</span>
    <span class="n">let</span> <span class="n">w</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">table</span>
    <span class="n">let</span> <span class="n">root</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">,</span> <span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">table</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">infinity</span>
            <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="o">=</span> <span class="n">i</span> <span class="n">to</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                    <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
                    <span class="n">root</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li><code class="highlighter-rouge">e[i, j]</code> records the expected search cost of optimal BST of $k_i, \dots, k_j$</li>
  <li><code class="highlighter-rouge">r[i, j]</code> records the best root of optimal BST of $k_i, \dots, k_j$</li>
  <li><code class="highlighter-rouge">w[i, j]</code> records $\sum_{\ell=i}^j{p_\ell}$</li>
</ul>

<p>The runtime is $\Theta(n^3)$: there are $\Theta(n^2)$ cells to fill in, most of which take $\Theta(n)$ to fill in.</p>

<!-- Lecture 14-->

<h2 id="graphs">Graphs</h2>

<h3 id="representation">Representation</h3>
<p>One way to store a graph is in an adjacency list. Every vertex has a list of vertices to which it is connected. In this representation, every edge is stored twice for undirected graphs, and once for directed graphs.</p>

<p><img src="/images/algorithms/adjacency-list.png" alt="Example of an adjacency list" /></p>

<ul>
  <li><strong>Space</strong>: $\Theta(V+E)$</li>
  <li><strong>Time</strong>: to list all vertices adjacent to $u$: $\Theta(\text{degree}(u))$</li>
  <li><strong>Time</strong>: to determine whether $(u, v)\in E: \mathcal{O}(\text{degree}(u))$</li>
</ul>

<p>The other way to store this data is in an adjacency matrix. This is a matrix where:</p>

\[a_{ij} = \begin{cases}
1 &amp; \text{if } (i, j)\in E \\
0 &amp; \text{otherwise} \\
\end{cases}\]

<p><img src="/images/algorithms/adjacency-matrix.png" alt="Example of an adjacency matrix" /></p>

<p>In an undirected graph, this makes for a symmetric matrix. The requirements of this implementation are:</p>

<ul>
  <li><strong>Space</strong>: $\Theta(V^2)$</li>
  <li><strong>Time</strong>: to list all vertices adjacent to $u$: $\Theta(V)$</li>
  <li><strong>Time</strong>: to determine whether $(u, v)\in E: \Theta(1)$.</li>
</ul>

<p>We can extend both representations to include other attributes such as edge weights.</p>

<h3 id="traversing--searching-a-graph">Traversing / Searching a graph</h3>

<h4 id="breadth-first-search-bfs">Breadth-First Search (<abbr title="Breadth-First Search">BFS</abbr>)</h4>

<ul>
  <li><strong>Input</strong>: Graph $G=(V, E)$, either directed or undirected and source vertex $s\in V$.</li>
  <li><strong>Output</strong>: $v.d = $ distance (smallest number of edges) from s to v for all vertices v.</li>
</ul>

<p>The idea is to:</p>

<ul>
  <li>Send a wave out from $s$</li>
  <li>First hits all vertices 1 edge from it</li>
  <li>From there, it hits all vertices 2 edges from it…</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf"><abbr title="Breadth-First Search">BFS</abbr></span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="c1"># This is Theta(V):
</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">V</span> <span class="o">-</span> <span class="p">{</span><span class="n">s</span><span class="p">}:</span> <span class="c1"># init all distances to infinity
</span>        <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">infinity</span>
    <span class="c1"># This is Theta(1):
</span>    <span class="n">s</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">Ø</span>
    <span class="n">enqueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="c1"># This is Theta(E):
</span>    <span class="k">while</span> <span class="n">Q</span> <span class="o">!=</span> <span class="n">Ø</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">dequeue</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">==</span> <span class="n">infinity</span><span class="p">:</span>
                <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">enqueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is $\mathcal{O}(V+E)$:</p>

<ul>
  <li>$\mathcal{O}(V)$ because each vertex is enqueued at most once</li>
  <li>$\mathcal{O}(E)$ because every vertex is dequeued at most once and we examine the edge $(u, v)$ only when $u$ is dequeued. Therefore, every edge is examined at most once if directed, and at most twice if undirected.</li>
</ul>

<p><abbr title="Breadth-First Search">BFS</abbr> may not reach all vertices. We can save the shortest path tree by keeping track of the edge that discovered the vertex.</p>

<h4 id="depth-first-search-dfs">Depth-first search (<abbr title="Depth-First Search">DFS</abbr>)</h4>

<ul>
  <li><strong>Input</strong>: Graph $G = (V, E)$, either directed or undirected</li>
  <li><strong>Output</strong>: 2 timestamps on each vertex: discovery time <code class="highlighter-rouge">v.d</code> and finishing time <code class="highlighter-rouge">v.f</code></li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf"><abbr title="Depth-First Search">DFS</abbr></span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">:</span>
        <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">WHITE</span>
    <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>                <span class="c1"># global variable
</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span><span class="p">:</span>
            <span class="n">DFS_visit</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DFS_visit</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">time</span>
    <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">GRAY</span>           <span class="c1"># discover u
</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>  <span class="c1"># explore (u, v)
</span>        <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span><span class="p">:</span>
            <span class="n">DFS_visit</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">u</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">time</span>               <span class="c1"># finish u</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This runs in $\Theta(V+E)$.</p>

<p><img src="/images/algorithms/dfs.gif" alt="GIF of DFS in action" /></p>

<h3 id="classification-of-edges">Classification of edges</h3>

<p><img src="/images/algorithms/edges-classification.png" alt="Classification of edges: tree edge, back edge, forward edge, cross edge" /></p>

<p>In <abbr title="Depth-First Search">DFS</abbr> of an undirected graph we get only tree and back edges; no forward or back-edges.</p>

<h3 id="parenthesis-theorem">Parenthesis theorem</h3>
<p>$\forall u, v$, exactly one of the following holds:</p>

<ol>
  <li>If <em>v</em> is a descendant of <em>u</em>: <code class="highlighter-rouge">u.d &lt; v.d &lt; v.f &lt; u.f</code></li>
  <li>If <em>u</em> is a descendant of <em>v</em>: <code class="highlighter-rouge">v.d &lt; u.d &lt; u.f &lt; v.f</code></li>
  <li>If neither <em>u</em> nor <em>v</em> are descendants of each other: <code class="highlighter-rouge">[u.d, u.f]</code> and <code class="highlighter-rouge">[v.d, v.f]</code> are disjoint (alternatively, we can say <code class="highlighter-rouge">u.d &lt; u.f &lt; v.d &lt; v.f</code> or <code class="highlighter-rouge">v.d &lt; v.f &lt; u.d &lt; u.f</code>)</li>
</ol>

<h3 id="white-path-theorem">White-path theorem</h3>
<p>Vertex <em>v</em> is a descendant of <em>u</em> <strong>if and only if</strong> at time <code class="highlighter-rouge">u.d</code> there is a path from <em>u</em> to <em>v</em> consisting of only white vertices (except for <code class="highlighter-rouge">u</code>, which has just been colored gray).</p>

<h3 id="topological-sort">Topological sort</h3>
<ul>
  <li><strong>Input</strong>: a directed acyclic graph (DAG)</li>
  <li><strong>Output</strong>: a linear ordering of vertices such that if $(u, v) \in E$, then <em>u</em> appears somewhere before <em>v</em></li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">topological</span> <span class="n">sort</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n"><abbr title="Depth-First Search">DFS</abbr></span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c1"># to compute finishing times v.f forall v
</span>    <span class="n">output</span> <span class="n">vertices</span> <span class="ow">in</span> <span class="n">order</span> <span class="n">of</span> <span class="n">decreasing</span> <span class="n">finishing</span> <span class="n">time</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Same running time as <abbr title="Depth-First Search">DFS</abbr>, $\Theta(V+E)$.</p>

<p>Topological sort can be useful for ordering dependencies, for instance. Given a dependency graph, it produces a sequential order in which to load them, so that no dependency is loaded before its prerequisite. However, this only works for acyclic dependency graphs; a sequential order cannot arise from cyclic dependencies.</p>

<details><summary><p>Proof of correctness</p>
</summary><div class="details-content">
<p>We need to show that if $(u, v) \in E$ then <code class="highlighter-rouge">v.f &lt; u.f</code>.<br />
When we explore <em>(u, v)</em>, what are the colors of <em>u</em> and <em>v</em>?</p>

<ul>
  <li><em>u</em> is gray</li>
  <li>Is <em>v</em> gray too?
    <ul>
      <li><strong>No</strong> because then <em>v</em> would be an ancestor of <em>u</em> which implies that there is a back edge so the graph is not acyclic (view lemma below)</li>
    </ul>
  </li>
  <li>Is <em>v</em> white?
    <ul>
      <li>Then it becomes a descendent of <em>u</em>, and by the parenthesis theorem, <code class="highlighter-rouge">u.d &lt; v.d &lt; v.f &lt; u.f</code></li>
    </ul>
  </li>
  <li>Is <em>v</em> black?
    <ul>
      <li>Then <em>v</em> is already finished. Since we are exploring <em>(u, v)</em>, we have not yet finished <em>u</em>. Therefore, <code class="highlighter-rouge">v.f &lt; u.f</code></li>
    </ul>
  </li>
</ul>
</div></details>

<!-- Lecture 15 -->

<h4 id="lemma-when-is-a-directed-graph-acyclic">Lemma: When is a directed graph acyclic?</h4>
<p>A directed graph G is acyclic <strong>if and only if</strong> a <abbr title="Depth-First Search">DFS</abbr> of G yields no back edges.</p>

<h3 id="strongly-connected-component">Strongly connected component</h3>
<p>A strongly connected component (SCC) of a directed graph is a <strong>maximal</strong> set of vertices $C \subseteq V$ such that $\forall u, v\in C,  u \leadsto v \text{ and } v\leadsto u$.</p>

<p>Below is a depiction of all SCCs on a graph:</p>

<p><img src="/images/algorithms/scc.png" alt="A depiction of all SCCs on a graph" /></p>

<p>If two SCCs overlap, then they are actually one SCC (and the two parts weren’t really SCCs because they weren’t maximal). Therefore, there cannot be overlap between SCCs.</p>

<h4 id="lemma">Lemma</h4>
<p>$G^{SCC}$ is a <a href="#lemma-when-is-a-directed-graph-acyclic">directed acyclic graph</a>.</p>

<p><img src="/images/algorithms/gscc.png" alt="G^SCC is the graph comprised of the SCCs and the links between them" /></p>

<h4 id="magic-algorithm">Magic Algorithm</h4>
<p>The following algorithm computes SCC in a graph G:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">SCC</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n"><abbr title="Depth-First Search">DFS</abbr></span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c1"># to  compute finishing times u.f for all u
</span>    <span class="n">compute</span> <span class="n">G</span><span class="o">^</span><span class="n">T</span>
    <span class="n"><abbr title="Depth-First Search">DFS</abbr></span><span class="p">(</span><span class="n">G</span><span class="o">^</span><span class="n">T</span><span class="p">)</span> <span class="n">but</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">main</span> <span class="n">loop</span> <span class="n">consider</span> <span class="n">vertices</span> <span class="ow">in</span> <span class="n">order</span> <span class="n">of</span> <span class="n">decreasing</span> <span class="n">u</span><span class="p">.</span><span class="n">f</span> <span class="c1"># as computed in first <abbr title="Depth-First Search">DFS</abbr>
</span>    <span class="n">Output</span> <span class="n">the</span> <span class="n">vertices</span> <span class="ow">in</span> <span class="n">each</span> <span class="n">tree</span> <span class="n">of</span> <span class="n">the</span> <span class="n"><abbr title="Depth-First Search">DFS</abbr></span> <span class="n">forest</span> <span class="n">formed</span> <span class="ow">in</span> <span class="mi">2</span><span class="n">nd</span> <span class="n"><abbr title="Depth-First Search">DFS</abbr></span> <span class="k">as</span> <span class="n">a</span> <span class="n">separate</span> <span class="n">SCC</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><img src="/images/algorithms/scc.gif" alt="SCC algorithm gif" /></p>

<p>Where $G^T$ is <em>G</em> with all edges reversed. They have the same SCCs. Using adjacency lists, we can create $G^T$ in $\Theta(V+E)$ time.</p>

<h2 id="flow-networks">Flow Networks</h2>
<p>A flow network is a directed graph with weighted edges: each edge has a capacity $c(u, v) \geq 0,   (c(u, v) = 0 \text{ if } (u, v) \notin E)$</p>

<p><img src="/images/algorithms/flow.png" alt="Example of a flow between cities" /></p>

<p>We talk about a source <em>s</em> and a sink <em>t</em>, where the flow goes from <em>s</em> to <em>t</em>.</p>

<p>We assume that there are no antiparallel edges, but this is without loss of generality; we make this assumption to simplify our descriptions of our algorithms. In fact, we can just represent antiparallel edges by adding a “temporary” node to split one of the anti-parallel edges in two.</p>

<p><img src="/images/algorithms/antiparallel.png" alt="Replacement of antiparallel edges" /></p>

<p>Likewise, vertices can’t have capacities <em>per se</em>, but we can simulate this by replacing a vertex <em>u</em> by vertices <em>u<sub>in</sub></em> and <em>u<sub>out</sub></em> linked by an edge of capacity <em>c<sub>u</sub></em>.</p>

<p>Possible applications include:</p>

<ul>
  <li>Fire escape plan: exits are sinks, rooms are sources</li>
  <li>Railway networks</li>
  <li>…</li>
</ul>

<p>We can model the flow as a function $f : V\times V \rightarrow \mathbb{R}$. This function satisfies:</p>

<p><strong>Capacity constraint</strong>: We do not use more flow than our capacity:</p>

\[\forall u, v \in V : 0 \leq f(u, v) \leq c(u, v)\]

<p><strong>Flow conservation</strong>: The flow into <em>u</em> must be equal to the flow out of <em>u</em></p>

\[\forall u \in V \setminus (s, t), \quad \sum_{v\in V}{f(v, u)} = \sum_{v\in V}{f(u, v)}\]

<p>The value of a flow is calculated by measuring at the source; it’s the flow out of the source minus the flow into the source:</p>

\[\| f \| = \sum_{v\in V}{f(s, v)} - \sum_{v\in V}{f(v, s)}\]

<h3 id="ford-fulkerson-method">Ford-Fulkerson Method</h3>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">ford_fulkerson_method</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">initialize</span> <span class="n">flow</span> <span class="n">f</span> <span class="n">to</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">exists</span><span class="p">(</span><span class="n">augmenting</span> <span class="n">path</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">residual</span> <span class="n">network</span> <span class="n">Gf</span><span class="p">):</span>
        <span class="n">augment</span> <span class="n">flow</span> <span class="n">f</span> <span class="n">along</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">f</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>As long as there is a path from source to sink, with available capacity on all edges in the path, send flow along one of these paths and then we find another path and so on.</p>

<h4 id="residual-network">Residual network</h4>
<p>The residual network network consists of edges with capacities that represent how we can change the flow on the edges. The residual capacity is:</p>

\[c_f(u, v) = \begin{cases}
c(u, v) - f(u, v) &amp; \text{if } (u, v) \in E \\
f(v, u) &amp; \text{if } (v, u) \in E \\
0 &amp; \text{otherwise} \end{cases}\]

<p>We can now define the residual network $G_f = (V, E_f)$, where:</p>

\[E_f =\{(u, v)\in V\times V : c_f(u, v) &gt; 0\}\]

<p>See the diagram below for more detail:</p>

<p><img src="/images/algorithms/residual-network.png" alt="Residual network along Ford-Fulkerson's method's steps" /></p>

<h3 id="cuts-in-flow-networks">Cuts in flow networks</h3>
<p>A cut of a flow network is a partition of <em>V</em> into two groups of vertices, <em>S</em> and <em>T</em>.</p>

<h4 id="net-flow-across-a-cut">Net flow across a cut</h4>
<p>The <strong>net flow across the cut</strong> <em>(S, T)</em> is the flow leaving <em>S</em> minus the flow entering <em>S</em>.</p>

\[f(S, T) = \sum_{u\in S, v\in T}{f(u, v)} - \sum_{u\in S, v\in T}{f(v, u)}\]

<p>The <strong>net flow across a cut</strong> is always equal to the <strong>value of the flow</strong>, which is the flow out of the source minus the flow into the source. For any cut $(S, T), | f | = f(S, T)$.</p>

<p>The proof is done simply by induction using flow conservation.</p>

<h4 id="capacity-of-a-cut">Capacity of a cut</h4>
<p>The capacity of a cut <em>(S, T)</em> is:</p>

\[c(S, T) = \sum_{u\in S, v\in T}{c(u, v)}\]

<p>The flow is <em>at most</em> the capacity of a cut.</p>

<h4 id="minimum-cut">Minimum cut</h4>
<p>A <strong>minimum cut</strong> of a network is a cut whose capacity is minimum over all cuts of the network.</p>

<p>The left side of the minimum cut is found by running Ford-Fulkerson and seeing what nodes can be reached from the source in the residual graph; the right side is the rest.</p>

<h4 id="max-flow-min-cut-theorem">Max-flow min-cut theorem</h4>
<p>The max-flow is <strong>equal</strong> to the capacity of the min-cut.</p>

<p>The proof is important and should be learned for the exam.</p>

<details><summary><p>Proof of the max-flow min-cut theorem</p>
</summary><div class="details-content">
<p>We’ll prove equivalence between the following:</p>

<ol>
  <li>$f$ has a maximum flow</li>
  <li>$G_f$ has no augmenting path</li>
  <li>$| f | = c(S, T)$ for a minimum cut $(S, T)$</li>
</ol>

<p>$(1) \Rightarrow (2)$: Suppose toward contradiction that $G_f$ has an augmenting path <em>p</em>. However, the Ford-Fulkerson method would augment <em>f</em> by <em>p</em> to obtain a flow if increased value which contradicts that <em>f</em> is a maximum flow.</p>

<p>$(2) \Rightarrow (3)$: Let <em>S</em> be the set of nodes reachable from <em>s</em> in a residual network. Every edge flowing out of <em>S</em> in <em>G</em> must be at capacity, otherwise we can reach a node outside <em>S</em> in the residual network.</p>

<p>$(3) \Rightarrow (1)$: Recall that $| f| \leq c(S, T) \forall \text{cut } (S, T)$. Therefore, if the value of a flow is equal to the capacity of some cut, then it cannot be further improved.</p>
</div></details>

<h3 id="time-for-finding-max-flow-or-min-cut">Time for finding max-flow (or min-cut)</h3>
<ul>
  <li>It takes $\mathcal{O}(E)$ time to find a a path in the residual network (using for example <abbr title="Breadth-First Search">BFS</abbr>).</li>
  <li>Each time the flow value is increased by at least 1</li>
  <li>So running time is $\mathcal{O}(E\cdot | f_{\text{max}} |)$, where $| f_{\text{max}} |$ is the value of a max flow.</li>
</ul>

<p>If capacities are irrational then the Ford-Fulkerson might not terminate. However, if we take the <strong>shortest path</strong> or <strong>fattest path</strong> then this will not happen if the capacities are integers (without proof).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Augmenting path</th>
      <th style="text-align: left">Number of iterations</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><abbr title="Breadth-First Search">BFS</abbr> Shortest path</td>
      <td style="text-align: left">$ \leq\frac{1}{2}E\cdot V $</td>
    </tr>
    <tr>
      <td style="text-align: left">Fattest path</td>
      <td style="text-align: left">$ \leq E\cdot \log{(E\cdot U)} $</td>
    </tr>
  </tbody>
</table>

<p>Where $U$ is the maximum flow value, and the fattest path is the path with largest minimum capacity (the bottleneck).</p>

<h3 id="bipartite-matching">Bipartite matching</h3>
<p>Say we have <em>N</em> students applying for <em>M</em> jobs. Each gets several offers. Is there a way to match all students to jobs?</p>

<p>If we add a source and a sink, give all edges capacity 1, from left to right. If we run <a href="#ford-fulkerson-method">Ford-Fulkerson</a>, we get a result.</p>

<p><img src="/images/algorithms/bipartite.png" alt="Bipartite matching example" /></p>

<h4 id="why-does-it-work">Why does it work?</h4>
<p>Every matching defines a flow of value equal to the number of edges in the matching. We put flow 1 on the edges of the matching, and to edges to and from the source and sink. All other edges have 0 flow.</p>

<p>Works because flow conservation is equivalent to: no student is matched more than once, no job is matched more than once.</p>

<h3 id="edmonds-kart-algorithm">Edmonds-Kart algorithm</h3>
<p>It’s just like <a href="#ford-fulkerson-method">Ford-Fulkerson</a>, but we pick the <strong>shortest</strong> augmenting path (in the sense of the minimal number of edges, found with <abbr title="Depth-First Search">DFS</abbr>).</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">edmonds_kart</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">there</span> <span class="n">exists</span> <span class="n">an</span> <span class="n">augmenting</span> <span class="n">path</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">...,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Gf</span><span class="p">:</span>
        <span class="n">find</span> <span class="n">shortest</span> <span class="n">augmenting</span> <span class="n">path</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.</span> <span class="n">using</span> <span class="n"><abbr title="Breadth-First Search">BFS</abbr></span><span class="p">)</span>
        <span class="n">compute</span> <span class="n">bottleneck</span> <span class="o">=</span> <span class="nb">min</span> <span class="n">capacity</span>
        <span class="n">augment</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The runtime is $\mathcal{O}(VE^2)$</p>

<h4 id="lemma-1">Lemma</h4>
<p>Let $\delta_f(s, u)$ be the shortest path distance from <em>s</em> to <em>u</em> in $G_f, u\in V$.</p>

<p>$\forall u\in V,  S_f(s, u)$ are monotonically non-decreasing throughout the execution of the algorithm.</p>

<details><summary><p>Proof of runtime</p>
</summary><div class="details-content">
<p>Edmonds-Kart terminates in $\mathcal{O}(V\cdot E)$ iterations. An edge <em>(u, v)</em> is said to be <strong>critical</strong> if its capacity is smallest on the augmenting path.</p>

<p>Every edge in G becomes critical $\mathcal{O}(V)$ times (a critical edge is removed, but it can reappear later).</p>
</div></details>

<!-- Lecture 18 -->

<h2 id="data-structures-for-disjoint-sets">Data structures for disjoint sets</h2>
<ul>
  <li>Also known as “union find”</li>
  <li>Maintain collection $\mathcal{S} = { S_1, \dots, S_k }$ of disjoint dynamic (changing over time) sets</li>
  <li>Each set is identified by a representative, which is some member of the set. It doesn’t matter which member is the representative, as long as if we ask for the representative twice without modifying the set, we get the same answer both
times</li>
</ul>

<p>We want to support the following operations:</p>

<ul>
  <li><code class="highlighter-rouge">make_set(x)</code>: Makes a new set $S_i={x}$ and add it to $\mathcal{S}$</li>
  <li><code class="highlighter-rouge">union(x, y)</code>: If $x \in S_x, y \in S_y$, then $\mathcal{S} = \mathcal{S} - S_x - S_y \cup { S_x \cup S_y }$
    <ul>
      <li>Representative of new set is any member in $S_x \cup S_y$, often the
representative of one of $S_x$ and $S_y$</li>
      <li>Destroys $S_x$ and $S_y$ (since sets must be disjoint)</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">find(x)</code>: Return the representative of the set containing <code class="highlighter-rouge">x</code>.</li>
</ul>

<h3 id="application-connected-components">Application: Connected components</h3>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">:</span>
        <span class="n">make_set</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">E</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">find_set</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><img src="/images/algorithms/connected-components.gif" alt="Connected components algorithm in action" /></p>

<p>This algorithm runs in $\mathcal{O}(V\log{(V)}+E)$ in linked-lists with weighted union heuristic, and $\mathcal{O}(V+E)$ in forests with union-by-rank and path-compression.</p>

<h3 id="implementation-linked-list">Implementation: Linked List</h3>
<p>This is not the fastest implementation, but it certainly is the easiest. Each set is a single linked list represented by a set object that has:</p>

<ul>
  <li>A pointer to the <em>head</em> of the list (assumed to be the representative)</li>
  <li>A pointer to the <em>tail</em> of the list</li>
</ul>

<p>Each object in the list has:</p>

<ul>
  <li>Attributes for the set member (its value for instance)</li>
  <li>A pointer to the set object</li>
  <li>A pointer to the next object</li>
</ul>

<p><img src="/images/algorithms/linked-list-union-find.png" alt="Representation of disjoint sets using linked lists" /></p>

<p>Our operations are now:</p>

<ul>
  <li><code class="highlighter-rouge">make_set(x)</code>: Create a singleton list in time $\Theta(1)$</li>
  <li><code class="highlighter-rouge">find(x)</code>: Follow the pointer back to the list object, and then follow the head pointer to the representative; time $\Theta(1)$.</li>
</ul>

<p>Union can be implemented in a couple of ways. We can either append <code class="highlighter-rouge">y</code>’s list onto the end of <code class="highlighter-rouge">x</code>’s list, and update <code class="highlighter-rouge">x</code>’s tail pointer to the end.</p>

<p>Otherwise, we can use <strong>weighted-union heuristic</strong>: we always append the smaller list to the larger list. As a theorem, <em>m</em> operations on <em>n</em> elements takes $\mathcal{O}(m+n\log{n})$ time.</p>

<h3 id="implementation-forest-of-trees">Implementation: Forest of trees</h3>
<ul>
  <li>One tree per set, where the root is the representative.</li>
  <li>Each node only point to its parent (the root points to itself).</li>
</ul>

<p>The operations are now:</p>

<ul>
  <li><code class="highlighter-rouge">make_set(x)</code>: make a single-node tree</li>
  <li><code class="highlighter-rouge">find(x)</code>: follow pointers to the root</li>
  <li><code class="highlighter-rouge">union(x, y)</code>: make one root a child of another</li>
</ul>

<p>To implement the union, we can make the root of the smaller tree a child of the root of the larger tree. In a good implementation, we use the rank instead of the size to compare the trees, since measuring the size takes time, and rank is an upper bound on the height of a node anyway. Therefore, a proper implementation would make the root with the <em>smaller rank</em> a child of the root with the <em>larger rank</em>; this is <strong>union-by-rank</strong>.</p>

<p><code class="highlighter-rouge">find-set</code> can be implemented with path compression, where every node it meets while making its way to the top is made a child of the root; this is <strong>path-compression</strong>.</p>

<figure>
    <img src="/images/algorithms/path-compression.png" alt="Example of path compression" />
    <figcaption>The result of running <code class="highlighter-rouge">find_set(a)</code></figcaption>
</figure>

<p>Below is one implementation of the operations on this data structure.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">make_set</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">x</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">x</span><span class="p">.</span><span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">find_set</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">parent</span>
        <span class="n">x</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span> <span class="c1"># path compression
</span>    <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">parent</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">link</span><span class="p">(</span><span class="n">find_set</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">find_set</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="c1"># path compression here as well
</span>
<span class="k">def</span> <span class="nf">link</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">rank</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">.</span><span class="n">rank</span><span class="p">:</span> <span class="c1"># union by rank
</span>        <span class="n">y</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if they have the same rank, the 2nd argument becomes parent
</span>        <span class="n">x</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">rank</span> <span class="o">==</span> <span class="n">y</span><span class="p">.</span><span class="n">rank</span><span class="p">:</span>
            <span class="n">y</span><span class="p">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="minimum-spanning-trees-mst">Minimum Spanning Trees (<abbr title="Minimum Spanning Tree">MST</abbr>)</h2>

<p>A spanning tree of a graph is a set of edges that is:</p>

<ol>
  <li>Acyclic</li>
  <li>Spanning (connects all vertices)</li>
</ol>

<p>We want to find the <em>minimum</em> spanning tree of a graph, that is, a spanning tree of minimum total weights.</p>

<ul>
  <li><strong>Input</strong>: an undirected graph G with weight <em>w(u, v)</em> for each edge $(u, v)\in E$.</li>
  <li><strong>Output</strong>: an <abbr title="Minimum Spanning Tree">MST</abbr>: a spanning tree of minimum total weights</li>
</ul>

<p>There are 2 natural greedy algorithms for this.</p>

<h3 id="prims-algorithm">Prim’s algorithm</h3>
<p>Prim’s algorithm is a greedy algorithm. It works by greedily growing the tree <em>T</em>  by adding a minimum weight crossing edge with respect to the cut induced by <em>T</em> at each step.</p>

<p><img src="/images/algorithms/prim.gif" alt="GIF of Prim's algorithm in action" /></p>

<p>See the slides for a proof.</p>

<h4 id="implementation">Implementation</h4>
<p>How do we find the minimum crossing edges at every iteration?</p>

<p>We need to check all the outgoing edges of every node, so the running time could be as bad as $\mathcal{O}(V E)$. But there’s a more clever solution!</p>

<ul>
  <li>For every node <em>w</em> keep value <em>dist(w)</em> that measures the “distance” of <em>w</em> from the current tree.</li>
  <li>When a new node <em>u</em> is added to the tree, check whether neighbors of <em>u</em> decreases their distance to tree; if so, decrease distance</li>
  <li>Maintain a <a href="#priority-queues">min-priority queue</a> for the nodes and their distances</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">prim</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">:</span>
        <span class="n">u</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">infinity</span>   <span class="c1"># set all keys to infinity
</span>        <span class="n">u</span><span class="p">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">Nil</span>
        <span class="n">insert</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">decrease_key</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># root.key = 0
</span>    <span class="k">while</span> <span class="ow">not</span> <span class="n">Q</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">extract_min</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Q</span> <span class="ow">and</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">key</span><span class="p">:</span>
                <span class="n">v</span><span class="p">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">decrease_key</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>When we start every node has the key <code class="highlighter-rouge">infinity</code> and our root has key 0, so we pick up the root. Now we need to find the edge with the minimal weight that crosses the cut.</p>

<ul>
  <li>Initialize <em>Q</em> and first for loop: $\mathcal{O}(V\log{V})$</li>
  <li><code class="highlighter-rouge">decrease_key</code> is $\mathcal{O}(\log{V})$</li>
  <li>The while loop:
    <ul>
      <li>We run <em>V</em> times <code class="highlighter-rouge">extract_min</code> ($\mathcal{O}(V\log{V})$)</li>
      <li>We run <em>E</em> times <code class="highlighter-rouge">decrease_key</code> ($\mathcal{O}(E\log{V})$)</li>
    </ul>
  </li>
</ul>

<p>The total runtime is the max of the above, so $\mathcal{O}(E\log{V})$ (which can be made $\mathcal{O}(V\log{V})$ with careful queue implementation).</p>

<h3 id="kruskals-algorithm">Kruskal’s algorithm</h3>
<p>Start from an empty forest <em>T</em> and greedily maintain forest <em>T</em> which will become an <abbr title="Minimum Spanning Tree">MST</abbr> at the end. At each step, add the cheapest edge that does not create a cycle.</p>

<p><img src="/images/algorithms/kruskal.gif" alt="Kruskal's algorithm in action" /></p>

<h4 id="implementation-1">Implementation</h4>
<p>In each iteration, we need to check whether the cheapest edge creates a cycle.</p>

<p>This is the same thing as checking whether its endpoints belong to the same component. Therefore, we can use a <a href="#data-structures-for-disjoint-sets">disjoint sets</a> (union-find) data structure.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">kruskal</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">:</span>
        <span class="n">make_set</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">sort</span> <span class="n">the</span> <span class="n">edges</span> <span class="n">of</span> <span class="n">G</span><span class="p">.</span><span class="n">E</span> <span class="n">into</span> <span class="n">nondecreasing</span> <span class="n">order</span> <span class="n">by</span> <span class="n">weight</span> <span class="n">w</span>
    <span class="k">for</span> <span class="n">each</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">sorted</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">find_set</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">v</span><span class="p">):</span> <span class="c1"># do they belong to the same CC?
</span>            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="n">union</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)}</span> <span class="c1"># Add the edge to the <abbr title="Minimum Spanning Tree">MST</abbr>
</span>            <span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="c1"># add the new node to the CC
</span>    <span class="k">return</span> <span class="n">A</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>Initialize A: $\mathcal{O}(1)$</li>
  <li>First for loop: <em>V</em> times <code class="highlighter-rouge">make_set</code></li>
  <li>Sort <em>E</em>: $\mathcal{O}(E\log{E})$</li>
  <li>Second for loop: $\mathcal{O}(E)$ times <code class="highlighter-rouge">find_sets</code> and <code class="highlighter-rouge">unions</code></li>
</ul>

<p>So this can run in $\mathcal{O}(E\log{V})$ (or, equivalently, $\mathcal{O}(E\log{E})$ since $E=V^2$ at most); runtime is dominated by the sorting algorithm.</p>

<h3 id="summary-4">Summary</h3>
<ul>
  <li>Greedy is good (sometimes)</li>
  <li>Prim’s algorithm relies on priority queues for the implementation</li>
  <li>Kruskal’s algorithm uses union-find</li>
</ul>

<h2 id="shortest-path-problem">Shortest Path Problem</h2>
<ul>
  <li><strong>Input</strong>: directed, weighted graph</li>
  <li><strong>Output</strong>: a path of minimal weight (there may be multiple solutions)</li>
</ul>

<p>The weight of a path $(v_0, v1, \dots, v_k): \sum_{i=1}^k{w(v_{i-1}, v_i)}$.</p>

<h3 id="problem-variants">Problem variants</h3>
<ul>
  <li><strong>Single-source</strong>: Find shortest paths from source vertex to every vertex</li>
  <li><strong>Single-destination</strong>: Find shortest paths to given destination vertex. This can be solved by reversing edge directions in single-source.</li>
  <li><strong>Single pair</strong>: Find shortest path from <em>u</em> to <em>v</em>. No algorithm known that is better in worst case than solving single-source.</li>
  <li><strong>All pairs</strong>: Find shortest path from <em>u</em> to <em>v</em> for all pairs <em>u</em>, <em>v</em> of vertices. This <em>can</em> be solved with single-pair for each vertex, but better algorithms are knowns</li>
</ul>

<h3 id="bellman-ford-algorithm">Bellman-Ford algorithm</h3>
<p>Bellman-Ford runs in $\Theta(E\cdot V)$. Unlike Dijkstra, it allows negative edge weights, as long as no negative-weight cycle (a cycle where the weights add up to a negative number) is reachable from the source. The algorithm is easy to implement in distributed settings (e.g. IP routing): each vertex repeatedly asks their neighbors for the best path.</p>

<ul>
  <li><strong>Input</strong>: Directed graph with weighted edges, source <em>s</em>, no negative cycles.</li>
  <li><strong>Ouput</strong>: The shortest path from <em>s</em> to <em>t</em></li>
</ul>

<p>It starts by trivial initialization, in which the distance of every vertex is set to infinity, and their predecessor is non-existent:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">init_single_source</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">:</span>
        <span class="n">v</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">infinity</span>
        <span class="n">v</span><span class="p">.</span><span class="n">predecessor</span> <span class="o">=</span> <span class="n">Nil</span>
    <span class="n">s</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Bellman-Ford updates shortest-path estimates iteratively by using <code class="highlighter-rouge">relax</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">.</span><span class="n">distance</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="c1"># if our attempt improves the distance
</span>        <span class="n">v</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">distance</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">v</span><span class="p">.</span><span class="n">predecessor</span> <span class="o">=</span> <span class="n">u</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This function reduces the distance of <code class="highlighter-rouge">v</code> if it is possible to reach it in a shorter path thanks to the <code class="highlighter-rouge">(u, v)</code> edge. It runs in $\mathcal{O}(1)$.</p>

<p>The entire algorithm is then:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">bellman_ford</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">init_single_source</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="o">|</span><span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="o">|</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">E</span><span class="p">:</span>
            <span class="n">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="c1"># Optional: detecting negative cycles
</span>    <span class="c1"># Essentially we're just checking whether relax()
</span>    <span class="c1"># would change anything on an additional iteration
</span>    <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">E</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">.</span><span class="n">distance</span> <span class="o">+</span> <span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span> <span class="c1"># there is a negative cycle
</span>    <span class="k">return</span> <span class="bp">True</span> <span class="c1"># there are no negative cycles</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><img src="/images/algorithms/bellman-ford.gif" alt="GIF of Bellman-Ford in action" /></p>

<p>A property of Bellman-Ford:</p>

<ul>
  <li>After one iteration, we have found all shortest paths that are one edge long</li>
  <li>After two iterations, we have found all shortest paths that are two edges long</li>
  <li>After three iterations, we have found all shortest paths that are three edges long</li>
  <li>…</li>
</ul>

<p>Let’s assume that the longest shortest path (in terms of number of edges) is from source <em>s</em> to vertex <em>t</em>. Let’s assume that there are <em>n</em> vertices in total; then the shortest path from <em>s</em> to <em>t</em> can at most be <em>n-1</em> edges long, which is why we terminate at <em>n-1</em> iterations in the above pseudocode.</p>

<p>Indeed, if there are no negative cycles, Bellman-Ford returns the correct answer after <em>n-1</em> iterations. But we may in reality already be done before the <em>n-1<sup>st</sup></em> iteration. If the longest shortest path (in terms of number of edges) is <em>m</em> edges long, then the <em>m<sup>th</sup></em> iteration will produce the final result. The algorithm has no way of knowing the value of <em>m</em>, but what it could do is run an <em>m+1<sup>st</sup></em> iteration and see if any distances change; if not, then it is done.</p>

<p>At any iteration, if Bellman-Ford doesn’t change any vertex distances, then it is done (it won’t change anything after this point anyway).</p>

<h4 id="detecting-negative-cycles">Detecting negative cycles</h4>
<p>There is no negative cycle reachable from the source if and only if no distances change when we run one more (<em>n<sup>th</sup></em>) iteration of Bellman-Ford.</p>

<h3 id="dijkstras-algorithm">Dijkstra’s algorithm</h3>
<ul>
  <li>This algorithm only works when all weights are nonnegative.</li>
  <li>It’s greedy, and faster than Bellman-Ford.</li>
  <li>It’s very similar to Prim’s algorithm; could also be described as a weighted version of <abbr title="Breadth-First Search">BFS</abbr>.</li>
</ul>

<p>We start with a Source $S = { s }$, and greedily grow <em>S</em>. At each step, we add to <em>S</em> the vertex that is closest to <em>S</em> (where distance is defined <code class="highlighter-rouge">u.d + w(u, v)</code>).</p>

<p><img src="/images/algorithms/dijkstra.gif" alt="GIF of Dijkstra's algorithm in action" /></p>

<p>This creates the shortest-path tree: we can give the shortest path between the source and any vertex in the tree.</p>

<p>Since Dijkstra’s algorithm is greedy (it doesn’t have to consider all edges, only the ones in the immediate vicinity), it is more efficient. Using a binary heap, we can run in $\mathcal{O}(E\log{V})$ (though a more careful implementation can optimize it to $\mathcal{O}(V\log{V}+E)$).</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">init_single_source</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>   <span class="c1"># insert all vertices into Q
</span>    <span class="k">while</span> <span class="n">Q</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">extract_min</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="n">union</span> <span class="p">{</span><span class="n">u</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="probabilistic-analysis-and-randomized-algorithms">Probabilistic analysis and randomized algorithms</h2>

<h3 id="motivation">Motivation</h3>
<ul>
  <li>Worst case does not usually happen
    <ul>
      <li>Average case analysis</li>
      <li>Amortized analysis</li>
    </ul>
  </li>
  <li>Randomization sometimes helps avoid worst-case and attacks by evil users
    <ul>
      <li>Choosing the pivot in quick-sort at random</li>
    </ul>
  </li>
  <li>Randomization necessary in cryptography</li>
  <li>Can we get randomness?
    <ul>
      <li>How to extract randomness (extractors)</li>
      <li>Longer “random behaving” strings from small seed (pseudorandom generators)</li>
    </ul>
  </li>
</ul>

<h3 id="probabilistic-analysis-the-hiring-problem">Probabilistic Analysis: The Hiring Problem</h3>
<p>A basketball team wants to hire a new player. The taller the better. Each candidate that is taller than the current tallest is hired. How many players did we (temporarily) hire?</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">hire_player</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">candidate</span> <span class="n">i</span> <span class="ow">is</span> <span class="n">taller</span> <span class="n">than</span> <span class="n">best</span> <span class="n">candidate</span> <span class="n">so</span> <span class="n">far</span><span class="p">:</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">hire</span> <span class="n">i</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Worst-case scenario is that the candidates come in sorted order, from lowest to tallest; in this case we hire <em>n</em> players.</p>

<p>What is the expected number of hires we make over all the permutations of the candidates?</p>

<p>There are $n!$ permutations, each equally likely. The expectation is the sum of hires in each permutation divided by $n!$:</p>

\[\frac{A_1 + A_2 + \dots + A_{n!}}{n!}\]

<p>For 5 players, we have 120 terms, but for 10 we have 3 628 800… We need to find a better way of calculating this than pure brute force.</p>

<p>Given a sample space and an event A, we define the <strong>indicator random variable</strong>:</p>

\[I\{A\}= \begin{cases}
1 &amp; \text{if } A \text{ occurs} \\
0 &amp; \text{if } A \text{ does not occur} \\
\end{cases}\]

<h4 id="lemma-2">Lemma</h4>
<p>For an event A, let $X_A = I{A}$. Then $\mathbb{E}[X_A] = Pr[A]$</p>

<details><summary><p>Proof</p>
</summary><div class="details-content">
\[\mathbb{E}[X_A] = 1\cdot Pr[A] + 0\cdot Pr[\bar{A}] = Pr[A]\]
</div></details>

<h4 id="multiple-coin-flips">Multiple Coin Flips</h4>
<p>What about multiple coin flips? We want to determine the expected number of heads when we flip <em>n</em> coins. Let $X$ be a random variable for the number of heads in <em>n</em> flips. We could calculate:</p>

\[\mathbb{E}[X] = \sum_{k=0}^n {k\cdot Pr\{X=k\}}\]

<p>… but that is cumbersome. Instead, we can use indicator variables.</p>

<p>For $i = 1, \dots, n$, define $X_i = I{\text{the ith flip results in event H}}$. Then:</p>

\[\mathbb{E}[X] = \mathbb{E}[X_1 + X_2 + \dots + X_n]\]

<p>By linearity of expectation (which holds even if <em>X</em> and <em>Y</em> are independent), i.e. that $\mathbb{E}[aX + bY] = a\mathbb{E}[X] + b\mathbb{E}[Y]$, we have:</p>

\[\mathbb{E}[X] = \mathbb{E}[X_1 + X_2 + \dots + X_n] = \mathbb{E}[X_1] + \mathbb{E}[X_2] + \dots + \mathbb{E}[X_n]\]

<p>For <em>n</em> coin flips, the above yields $\frac{n}{2}$.</p>

<h4 id="solving-the-hiring-problem">Solving the Hiring Problem</h4>
<p>Back to our hiring problem:</p>

\[Pr[\text{candidate } i \text{ is hired}] = \frac{1}{i}\]

<p>Therefore, the number of candidates we can expect to hire is:</p>

\[\mathbb{E}[X] = Pr[\text{#} 1 \text{ hired}] + Pr[\text{#} 2 \text{ hired}] + \dots = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n} = H_n\]

<p>This is the harmonic number, which is $H_n = \ln{n}+\mathcal{O}(1)$.</p>

<p>The probability of hiring one candidate is $\frac{1}{n}$ (this is the probability of the first being the tallest), while the probability of hiring all candidates is $\frac{1}{n!}$ (which is the probability of the exact permutation where all candidates come in decreasing sorted order).</p>

<h4 id="bonus-trivia">Bonus trivia</h4>
<p>Given a function <code class="highlighter-rouge">RANDOM</code> that return <code class="highlighter-rouge">1</code> with probability $p$ and <code class="highlighter-rouge">0</code> with probability $1-p$.</p>

\[\mathbb{E}[\text{# trials until success}] = \frac{1}{2p(1-p)}\]

<h3 id="birthday-lemma">Birthday Lemma</h3>
<p>If $q &gt; 1.78 \sqrt{|M|}$ then the probability that a function chosen uniformly at random $f: {1, 2, \dots, q} \rightarrow M$ is injective is at most $\frac{1}{2}$.</p>

<p>Note that this is a weaker statement than finding the <em>q</em> and <em>m</em> for which <em>f</em> is 50% likely to be injective. The real probability of a such function being injective is $e^{-q(q-1)/(2m)}$, as in the proof below (plugging in $q=23, m=365$ shows that in a group of 23, there’s a 50% chance of two people having the same birthday).</p>

<details><summary><p>Proof</p>
</summary><div class="details-content">
<p>Let $m = | M|$. The probability that the function is injective is:</p>

\[\frac{m}{m}\cdot\frac{m-1}{m}\cdot\frac{m-2}{m}\cdot\dots\cdot\frac{m-(q-1)}{m}\]

<p>Since $e^{-x} &gt; 1-x$ we have that this is less than:</p>

\[e^{-0}\cdot e^{-1/m}\cdot e^{-2/m}\dots e^{-(q-1)/m} = e^{-q(q-1)/(2m)}\]

<p>Which itself is less than ½ if:</p>

\[q \geq\frac{1+\sqrt{1+8\ln{2}}}{2}\sqrt{m}\approx 1.78\sqrt{m}\]

</div></details>

<h3 id="hash-functions-and-tables">Hash functions and tables</h3>
<p>We want to design a computer system for a library, where we can:</p>

<ul>
  <li>Insert a new book</li>
  <li>Delete book</li>
  <li>Search book</li>
  <li>All operations in (expected) constant time</li>
</ul>

<p>There are multiple approaches to this; let’s start with a very naive one: a direct-address table, in which we save an array/table T with a position for each possible book (for every possible ISBN).</p>

<p>This is terribly inefficient; sure, the running time of each of the above operations is $\mathcal{O}(1)$, but it takes space $\mathcal{O}(U)$, where U is the size of the universe.</p>

<h4 id="hash-tables">Hash tables</h4>
<p>Instead, let’s use hash tables. Their running time is the same (constant, in average case), but their space requirement is $\mathcal{O}(K)$, the size of the key space (instead of the universe).</p>

<p>In hash tables an element with key <em>k</em> is stored in slot <em>h(k)</em>. $h: U \rightarrow{0, 1, \dots, m-1}$ is called the <strong>hash function</strong>.</p>

<p>A good hash function is efficiently computable, should distribute keys uniformly (seemingly at random over our sample space, though the output should of course be deterministic, the same every time we run the function). This is the principle of <strong>simple uniform hashing</strong>:</p>

<blockquote>
  <p>The hashing function <strong>h</strong> hashes a new key equally likely to any of the <strong>m</strong> slots, independently of where any other key has hashed to</p>
</blockquote>

<h4 id="collisions">Collisions</h4>
<p>When two items with keys <em>k<sub>i</sub></em> and <em>k<sub>j</sub></em> have <em>h(k<sub>i</sub>) = h(k<sub>j</sub>)</em>, we have a collision. How big of a table do we need to avoid collisions with high probability? This is the same problem as the <a href="#birthday-lemma">Birthday Lemma</a>. It says that for <em>h</em> to be injective with good probability (meaning that the expected number of collisions is lower than 1) then we need $m &gt; K^2$.</p>

<p>This means that if a library has $K = 10 000$ books then it needs an array of size $ m = K^2 = 10^8 $ (at least).</p>

<p>Even then, we can’t avoid collisions, but we can still deal with them. We can place all elements that hash to the same slot into the same <strong>doubly linked list</strong>.</p>

<p><img src="/images/algorithms/hash-collision.png" alt="A hash collision and its representation in memory" /></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">chained_hash_search</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">search</span> <span class="k">for</span> <span class="n">an</span> <span class="n">element</span> <span class="k">with</span> <span class="n">key</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span> <span class="n">T</span><span class="p">[</span><span class="n">h</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
    <span class="c1"># (this list will often only contain 1 element)
</span>
<span class="k">def</span> <span class="nf">chained_hash_insert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">insert</span> <span class="n">x</span> <span class="n">at</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="nb">list</span> <span class="n">T</span><span class="p">[</span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">chained_hash_delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">delete</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">list</span> <span class="n">T</span><span class="p">[</span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">)]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>See <a href="#linked-lists">linked lists</a> for details on how to do operations on the lists.</p>

<h4 id="running-times">Running times</h4>
<ul>
  <li><code class="highlighter-rouge">Insert</code>: $\mathcal{O}(1)$</li>
  <li><code class="highlighter-rouge">Delete</code>: $\mathcal{O}(1)$</li>
  <li><code class="highlighter-rouge">Search</code>: Expected $\mathcal{O}(\frac{n}{m})$ (if good hash function)</li>
</ul>

<p>Insertion and deletion are $\mathcal{O}(1)$, and the space requirement is $\mathcal{O}(m+K)$.</p>

<p>The worst case is that all <em>n</em> elements are hashed to the same slot, in which case search takes $\Theta(n)$, since we’re searching through a linked list. But this is <em>exceedingly rare</em> with a correct <em>m</em> and <em>n</em> (we cannot avoid collisions without having $m \gg n^2$).</p>

<p>Let the following be a <strong>theorem</strong> for running time of search: a search takes expected time $\Theta(1+\alpha)$, where $\alpha = \frac{n}{m}$ is the expected length of the list.</p>

<p>See the slides for extended proof!</p>

<p>If we choose the size of our hash table to be proportional to the number of elements stored, we have $m = \Theta(n)$. Insertion, deletion are then in constant time.</p>

<h4 id="examples-of-hash-functions">Examples of Hash Functions</h4>
<ul>
  <li><strong>Division method</strong>: $h(k) = k \text{ mod } m$, where <em>m</em> often selected to be a prime not too close to a power of 2</li>
  <li><strong>Multiplicative method</strong>: $h(k) = \lfloor m\times\text{ fractional part of}(Ak)\rfloor$. Knut suggests chosing $A\approx \frac{\sqrt{5}-1}{2}$.</li>
</ul>

<h2 id="quick-sort">Quick Sort</h2>
<p><img src="/images/algorithms/quicksort.png" alt="Quicksort example" /></p>

<p>We recursively select an element at random, the <strong>pivot</strong>, and split the list into two sublist; the smaller or equal elements to the left, the larger ones to the right. When we only have single elements left, we can combine them with the pivot in the middle.</p>

<p>This is a simple divide-and-conquer algorithm. The divide step looks like this:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="c1"># pivot = last element
</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># i is the separator between left and right
</span>    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">p</span> <span class="n">to</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># iterate over all elements
</span>        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">swap</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c1"># if it needs to go left, set it to 
</span>    <span class="n">swap</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># pivot's new index</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>See <a href="https://visualgo.net/sorting">this visualization</a> for a better idea of how this operates.</p>

<p>The running time is $\Theta(n)$ for an array of length <em>n</em>; it’s proportional to the number of comparisons we use (the number of times that line 5 is run).</p>

<p>The loop invariant is:</p>
<ol>
  <li>All entries in <code class="highlighter-rouge">A[p..i]</code> are $\leq$ pivot</li>
  <li>All entries in <code class="highlighter-rouge">A[i+1 .. j-1]</code> are $&gt;$ pivot</li>
  <li><code class="highlighter-rouge">A[r]</code> is the pivot</li>
</ol>

<p>The algorithm uses the above like so:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># to the left
</span>        <span class="n">quicksort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="c1"># to the right</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Quicksort runs in $\mathcal{O}(n \log{n})$ if the split is balanced (two equal halves), that is, if we’ve chosen a good pivot. In this case we have our favorite recurrence:</p>

\[T(n) = 2T(n/2) + \Theta(n)\]

<p>Which indeed is $\mathcal{O}(n \log{n})$.</p>

<p>But what if we choose a bad pivot every time? We would just have elements to the left of the pivot, and it would run in $\mathcal{O}(n^2)$. But this is very unlikely.</p>

<p>If we select the pivot at random, the algorithm will perform well on <em>any</em> input. Therefore, as a small modification to the partitioning algorithm, we should select a random number in the list instead of the last number.</p>

<p>Total running time is proportional to $\mathbb{E}[\text{# comparisons}]$. We can calculate this by using a <strong>random indicator variable</strong>:</p>

\[X_{ij} = \begin{cases}
1 &amp; \text{ if } i^\text{th}\text{ smallest number is compared with }j^\text{th}\text{ smallest number} \\
0 &amp; \text{ otherwise}
\end{cases}\]

<p><strong>Note:</strong> two numbers are only compared when one is the pivot; therefore, no nunmbers are compared to each other twice (we could also say that two numbers are compared at most once). The total number of comparisons formed by the algorithm is therefore:</p>

\[X = \sum_{i=1}^n {\sum_{j=i+1}^n {X_{ij}}}\]

<p>The expectancy is thus:</p>

\[\mathbb{E}[\text{# comparisons}] = \mathbb{E}\left[X\right] = 
\mathbb{E}\left[\sum_{i=1}^n{\sum_{j=i+1}^n{X_{ij}}}\right]\]

<p>Using linearity of expectation, this is equal to:</p>

\[\sum_{i=1}^n {\sum_{j=i+1}^n {\mathbb{E}\left[X_{ij}\right]}} 
=  \sum_{i=1}^n {\sum_{j=i+1}^n {Pr\left[z_i \text{ is compared to } z_j\right]}}\]

<ul>
  <li>If a pivot $x$ such that $z_i &lt; x &lt; z_j$ is chosen then $z_i$ and $z_j$ will never be compared at any later time.</li>
  <li>If either $z_i$ or $z_j$ is chosen before any other element of $Z_ij$ then it will compared to all other elements of $Z_ij$.</li>
  <li>The probability that $z_i$ is compared to $z_j$ is the probability that either $z_i$ or $z_j$ is the element first chosen</li>
  <li>There are $j-i+1$ elements and pivots chosen at random, independently. Thus the probability that any one of them is the first chosen one is $1 / (j-i+1)$</li>
</ul>

<p>Therefore:</p>

\[Pr\left[z_i \text{ is compared to } z_j\right] = \frac{2}{j-i+1}\]

<p>To wrap it up:</p>

\[\begin{align}
&amp; \sum_{i=1}^n {\sum_{j=i+1}^n {Pr\left[z_i \text{ is compared to } z_j\right]}} \\
&amp; = \sum_{i=1}^n {\sum_{j=i+1}^n {\frac{2}{j-i+1}}}
  = \sum_{i=1}^{n-1} {\sum_{k=1}^{n-i} {\frac{2}{k+1}}} \\
&amp; &lt; \sum_{i=1}^{n-1} {\sum_{k=1}^{n} {\frac{2}{k}}} 
  = \sum_{i=1}^{n-1} {\mathcal{O}(\log{n})} \\
&amp; = \mathcal{O}(n\log{n}) \\
\end{align}\]

<p>Quicksort is $\mathcal{O}(n\log{n})$.</p>

<h3 id="why-always-n-log-n">Why always n log n?</h3>
<p>Let’s look at all the sorting algorithms we’ve looked at or just mentioned during the course:</p>

<ul>
  <li>Quick Sort</li>
  <li>Merge sort</li>
  <li>Heap sort</li>
  <li>Bubble sort</li>
  <li>Insertion sort</li>
</ul>

<p>All algorithms we have seen so far have a running time based on the number of <em>comparisons</em> ($a \leq b$). Let’s try to analyze the number of comparisons to give an absolute lower bound on sorting algorithms; we’ll find out that it is impossible to do better than $\mathcal{O}(n\log{n})$.</p>

<p>We need $\Omega(n)$ to even examine the inputs. If we look at the comparisons we need no make, we can represent them as a decision tree:</p>

<p><img src="/images/algorithms/decision-tree.png" alt="Decision tree of the list (1, 2, 3)" /></p>

<p>There are $n!$ leaves in the decision tree (this is the number of output permutations), and its height is $\Omega(\log{n!})=\Omega(n\log{n})$. Therefore, if we have an algorithm that takes all its information from comparisons (<em>comparison sorting</em>) gives us a decision tree, and <strong>cannot run in better time than</strong> $\mathcal{O}(n\log{n})$. In that sense, merge-sort, heapsort and quicksort are optimal.</p>

<h3 id="linear-time-sorting">Linear time sorting</h3>
<p>Also known as <em>non-comparison sort</em>.</p>

<ul>
  <li><strong>Input</strong>: <code class="highlighter-rouge">A[1..n]</code>, where $A[j] \in { 0, 1, \dots, k }$ for $j = 1, 2, \dots, n$. Array <code class="highlighter-rouge">A</code> and values <code class="highlighter-rouge">n</code> and <code class="highlighter-rouge">k</code> are given as parameters</li>
  <li><strong>Output</strong>: <code class="highlighter-rouge">B[1..n]</code> sorted</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">counting_sort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">let</span> <span class="n">C</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">k</span><span class="p">]</span> <span class="n">be</span> <span class="n">a</span> <span class="n">new</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">k</span><span class="p">:</span> <span class="c1"># initialize C[i] to 0
</span>        <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span> <span class="c1"># count elements of A
</span>        <span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">k</span><span class="p">:</span> <span class="c1"># number of elements with value at most i
</span>        <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="n">downto</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="n">B</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># decrement number of el &lt;= j</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The for-loops run in $\Theta(k), \Theta(n), \Theta(k), \Theta(n)$ respectively, so runtime is $\Theta(n+k)$.</p>

<p><img src="/images/algorithms/counting-sort.gif" alt="GIF of non-comparison sort in action" /></p>

<p>How big a <em>k</em> is practical?</p>

<ul>
  <li>32-bit values? No</li>
  <li>16-bit values? Probably not</li>
  <li>8-bit values? Maybe depending on <em>n</em> (if it’s big then yes)</li>
  <li>4-bit values? Probably, unless <em>n</em> is very small (if it’s small then no, comparison sorting is fine)</li>
</ul>

<h2 id="review-of-the-course">Review of the course</h2>

<h3 id="growth-of-functions">Growth of functions</h3>
<ol>
  <li>The logs: $\log{N}, \log^2{N}, \dots$</li>
  <li>The polynomials: $\sqrt{N}, 20N, N^2, \dots$</li>
  <li>The exponentials: $\sqrt{4^N}=2^N, 3^N, …$</li>
</ol>

<h3 id="sorting-1">Sorting</h3>
<ul>
  <li><strong>Insertion sort</strong>: Put the numers in their correct order one at a time. $\Theta(n^2)$, worst case occurs when the input is in reverse sorted order</li>
  <li><strong>Merge sort</strong>: A divide and conquer algorithm. The merge works by having two stacks of cards, adding a sentinel at the bottom, and then repeatedly  just taking the smallest of the two.
    <ul>
      <li><em>Time to divide</em>: $\Theta(1)$</li>
      <li><em>Time to combine</em> $\Theta(n), \text{ where } n=r-p$</li>
      <li><em>Number of subproblems and their size</em>: 2 subproblems of size $n/2$.</li>
      <li><em>Recurrence</em>:</li>
    </ul>
  </li>
</ul>

\[T(n) = \begin{cases}
\Theta(1) &amp; \text{if } n \leq 1 \\
2T(n/2)+\Theta(n) &amp; \text{otherwise} \\
\end{cases}\]
:ET