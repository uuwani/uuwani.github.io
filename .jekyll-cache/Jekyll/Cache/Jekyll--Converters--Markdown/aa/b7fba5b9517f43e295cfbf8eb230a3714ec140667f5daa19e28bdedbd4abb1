I"÷Ä<!-- More -->

<ul id="markdown-toc">
  <li><a href="#writing-a-parser-with-parser-combinators" id="markdown-toc-writing-a-parser-with-parser-combinators">Writing a parser with parser combinators</a>    <ul>
      <li><a href="#boilerplate" id="markdown-toc-boilerplate">Boilerplate</a></li>
      <li><a href="#the-basic-idea" id="markdown-toc-the-basic-idea">The basic idea</a></li>
      <li><a href="#simple-parser-primitives" id="markdown-toc-simple-parser-primitives">Simple parser primitives</a></li>
      <li><a href="#parser-combinators" id="markdown-toc-parser-combinators">Parser combinators</a></li>
      <li><a href="#shorthands" id="markdown-toc-shorthands">Shorthands</a></li>
      <li><a href="#example-json-parser" id="markdown-toc-example-json-parser">Example: JSON parser</a></li>
      <li><a href="#the-trouble-with-left-recursion" id="markdown-toc-the-trouble-with-left-recursion">The trouble with left-recursion</a></li>
    </ul>
  </li>
  <li><a href="#arithmetic-expressions--abstract-syntax-and-proof-principles" id="markdown-toc-arithmetic-expressions--abstract-syntax-and-proof-principles">Arithmetic expressions â€” abstract syntax and proof principles</a>    <ul>
      <li><a href="#basics-of-induction" id="markdown-toc-basics-of-induction">Basics of induction</a></li>
      <li><a href="#mathematical-representation-of-syntax" id="markdown-toc-mathematical-representation-of-syntax">Mathematical representation of syntax</a>        <ul>
          <li><a href="#mathematical-representation-1" id="markdown-toc-mathematical-representation-1">Mathematical representation 1</a></li>
          <li><a href="#mathematical-representation-2" id="markdown-toc-mathematical-representation-2">Mathematical representation 2</a></li>
          <li><a href="#mathematical-representation-3" id="markdown-toc-mathematical-representation-3">Mathematical representation 3</a></li>
          <li><a href="#comparison-of-the-representations" id="markdown-toc-comparison-of-the-representations">Comparison of the representations</a></li>
        </ul>
      </li>
      <li><a href="#induction-on-terms" id="markdown-toc-induction-on-terms">Induction on terms</a></li>
      <li><a href="#inductive-function-definitions" id="markdown-toc-inductive-function-definitions">Inductive function definitions</a>        <ul>
          <li><a href="#what-is-a-function" id="markdown-toc-what-is-a-function">What is a function?</a></li>
          <li><a href="#induction-example-1" id="markdown-toc-induction-example-1">Induction example 1</a></li>
          <li><a href="#induction-example-2" id="markdown-toc-induction-example-2">Induction example 2</a></li>
        </ul>
      </li>
      <li><a href="#operational-semantics-and-reasoning" id="markdown-toc-operational-semantics-and-reasoning">Operational semantics and reasoning</a>        <ul>
          <li><a href="#evaluation" id="markdown-toc-evaluation">Evaluation</a></li>
          <li><a href="#derivations" id="markdown-toc-derivations">Derivations</a></li>
          <li><a href="#inversion-lemma" id="markdown-toc-inversion-lemma">Inversion lemma</a></li>
        </ul>
      </li>
      <li><a href="#abstract-machines" id="markdown-toc-abstract-machines">Abstract machines</a></li>
      <li><a href="#normal-forms" id="markdown-toc-normal-forms">Normal forms</a>        <ul>
          <li><a href="#values-that-are-normal-form" id="markdown-toc-values-that-are-normal-form">Values that are normal form</a></li>
          <li><a href="#values-that-are-not-normal-form" id="markdown-toc-values-that-are-not-normal-form">Values that are not normal form</a></li>
        </ul>
      </li>
      <li><a href="#multi-step-evaluation" id="markdown-toc-multi-step-evaluation">Multi-step evaluation</a></li>
      <li><a href="#termination-of-evaluation" id="markdown-toc-termination-of-evaluation">Termination of evaluation</a></li>
    </ul>
  </li>
  <li><a href="#lambda-calculus" id="markdown-toc-lambda-calculus">Lambda calculus</a>    <ul>
      <li><a href="#pure-lambda-calculus" id="markdown-toc-pure-lambda-calculus">Pure lambda calculus</a>        <ul>
          <li><a href="#scope" id="markdown-toc-scope">Scope</a></li>
          <li><a href="#operational-semantics" id="markdown-toc-operational-semantics">Operational semantics</a></li>
          <li><a href="#evaluation-strategies" id="markdown-toc-evaluation-strategies">Evaluation strategies</a></li>
        </ul>
      </li>
      <li><a href="#classical-lambda-calculus" id="markdown-toc-classical-lambda-calculus">Classical lambda calculus</a>        <ul>
          <li><a href="#confluence-in-full-beta-reduction" id="markdown-toc-confluence-in-full-beta-reduction">Confluence in full beta reduction</a></li>
          <li><a href="#alpha-conversion" id="markdown-toc-alpha-conversion">Alpha conversion</a></li>
        </ul>
      </li>
      <li><a href="#programming-in-lambda-calculus" id="markdown-toc-programming-in-lambda-calculus">Programming in lambda-calculus</a>        <ul>
          <li><a href="#multiple-arguments" id="markdown-toc-multiple-arguments">Multiple arguments</a></li>
          <li><a href="#booleans" id="markdown-toc-booleans">Booleans</a></li>
          <li><a href="#pairs" id="markdown-toc-pairs">Pairs</a></li>
          <li><a href="#numbers" id="markdown-toc-numbers">Numbers</a></li>
          <li><a href="#lists" id="markdown-toc-lists">Lists</a></li>
        </ul>
      </li>
      <li><a href="#recursion-in-lambda-calculus" id="markdown-toc-recursion-in-lambda-calculus">Recursion in lambda-calculus</a></li>
      <li><a href="#equivalence-of-lambda-terms" id="markdown-toc-equivalence-of-lambda-terms">Equivalence of lambda terms</a></li>
    </ul>
  </li>
  <li><a href="#types" id="markdown-toc-types">Types</a>    <ul>
      <li><a href="#properties-of-the-typing-relation" id="markdown-toc-properties-of-the-typing-relation">Properties of the Typing Relation</a>        <ul>
          <li><a href="#inversion-lemma-1" id="markdown-toc-inversion-lemma-1">Inversion lemma</a></li>
          <li><a href="#canonical-form" id="markdown-toc-canonical-form">Canonical form</a></li>
          <li><a href="#progress-theorem" id="markdown-toc-progress-theorem">Progress Theorem</a></li>
          <li><a href="#preservation-theorem" id="markdown-toc-preservation-theorem">Preservation Theorem</a></li>
        </ul>
      </li>
      <li><a href="#messing-with-it" id="markdown-toc-messing-with-it">Messing with it</a>        <ul>
          <li><a href="#removing-a-rule" id="markdown-toc-removing-a-rule">Removing a rule</a></li>
          <li><a href="#changing-type-checking-rule" id="markdown-toc-changing-type-checking-rule">Changing type-checking rule</a></li>
          <li><a href="#adding-bit" id="markdown-toc-adding-bit">Adding bit</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#simply-typed-lambda-calculus" id="markdown-toc-simply-typed-lambda-calculus">Simply typed lambda calculus</a>    <ul>
      <li><a href="#type-annotations" id="markdown-toc-type-annotations">Type annotations</a></li>
      <li><a href="#typing-rules" id="markdown-toc-typing-rules">Typing rules</a></li>
      <li><a href="#inversion-lemma-2" id="markdown-toc-inversion-lemma-2">Inversion lemma</a></li>
      <li><a href="#canonical-form-1" id="markdown-toc-canonical-form-1">Canonical form</a></li>
      <li><a href="#progress" id="markdown-toc-progress">Progress</a></li>
      <li><a href="#preservation" id="markdown-toc-preservation">Preservation</a>        <ul>
          <li><a href="#weakening-lemma" id="markdown-toc-weakening-lemma">Weakening lemma</a></li>
          <li><a href="#permutation-lemma" id="markdown-toc-permutation-lemma">Permutation lemma</a></li>
          <li><a href="#substitution-lemma" id="markdown-toc-substitution-lemma">Substitution lemma</a></li>
          <li><a href="#proof" id="markdown-toc-proof">Proof</a></li>
        </ul>
      </li>
      <li><a href="#erasure" id="markdown-toc-erasure">Erasure</a></li>
      <li><a href="#curry-howard-correspondence" id="markdown-toc-curry-howard-correspondence">Curry-Howard Correspondence</a></li>
      <li><a href="#extensions-to-stlc" id="markdown-toc-extensions-to-stlc">Extensions to STLC</a>        <ul>
          <li><a href="#base-types" id="markdown-toc-base-types">Base types</a></li>
          <li><a href="#unit-type" id="markdown-toc-unit-type">Unit type</a></li>
          <li><a href="#sequencing" id="markdown-toc-sequencing">Sequencing</a></li>
          <li><a href="#ascription" id="markdown-toc-ascription">Ascription</a></li>
          <li><a href="#pairs-1" id="markdown-toc-pairs-1">Pairs</a></li>
          <li><a href="#tuples" id="markdown-toc-tuples">Tuples</a></li>
          <li><a href="#records" id="markdown-toc-records">Records</a></li>
        </ul>
      </li>
      <li><a href="#sums-and-variants" id="markdown-toc-sums-and-variants">Sums and variants</a>        <ul>
          <li><a href="#sum-type" id="markdown-toc-sum-type">Sum type</a></li>
          <li><a href="#sums-and-uniqueness-of-type" id="markdown-toc-sums-and-uniqueness-of-type">Sums and uniqueness of type</a></li>
          <li><a href="#variants" id="markdown-toc-variants">Variants</a></li>
        </ul>
      </li>
      <li><a href="#recursion" id="markdown-toc-recursion">Recursion</a></li>
      <li><a href="#references" id="markdown-toc-references">References</a>        <ul>
          <li><a href="#mutability" id="markdown-toc-mutability">Mutability</a></li>
          <li><a href="#aliasing" id="markdown-toc-aliasing">Aliasing</a></li>
          <li><a href="#typing-rules-1" id="markdown-toc-typing-rules-1">Typing rules</a></li>
          <li><a href="#evaluation-1" id="markdown-toc-evaluation-1">Evaluation</a></li>
          <li><a href="#store-typing" id="markdown-toc-store-typing">Store typing</a></li>
          <li><a href="#safety" id="markdown-toc-safety">Safety</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#type-reconstruction-and-polymorphism" id="markdown-toc-type-reconstruction-and-polymorphism">Type reconstruction and polymorphism</a>    <ul>
      <li><a href="#constraint-based-typing-algorithm" id="markdown-toc-constraint-based-typing-algorithm">Constraint-based Typing Algorithm</a>        <ul>
          <li><a href="#constraint-generation" id="markdown-toc-constraint-generation">Constraint generation</a></li>
          <li><a href="#soundness-and-completeness" id="markdown-toc-soundness-and-completeness">Soundness and completeness</a></li>
          <li><a href="#substitutions" id="markdown-toc-substitutions">Substitutions</a></li>
          <li><a href="#unification" id="markdown-toc-unification">Unification</a></li>
          <li><a href="#single-pass-unification" id="markdown-toc-single-pass-unification">Single-pass unification</a></li>
          <li><a href="#strong-normalization" id="markdown-toc-strong-normalization">Strong normalization</a></li>
        </ul>
      </li>
      <li><a href="#polymorphism" id="markdown-toc-polymorphism">Polymorphism</a>        <ul>
          <li><a href="#explicit-polymorphism" id="markdown-toc-explicit-polymorphism">Explicit polymorphism</a></li>
          <li><a href="#implicit-polymorphism" id="markdown-toc-implicit-polymorphism">Implicit polymorphism</a></li>
          <li><a href="#alternative-hindley-milner" id="markdown-toc-alternative-hindley-milner">Alternative Hindley Milner</a></li>
        </ul>
      </li>
      <li><a href="#principal-types" id="markdown-toc-principal-types">Principal types</a></li>
    </ul>
  </li>
  <li><a href="#subtyping" id="markdown-toc-subtyping">Subtyping</a>    <ul>
      <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
      <li><a href="#rules" id="markdown-toc-rules">Rules</a>        <ul>
          <li><a href="#general-rules" id="markdown-toc-general-rules">General rules</a></li>
          <li><a href="#records-1" id="markdown-toc-records-1">Records</a></li>
          <li><a href="#arrow-types" id="markdown-toc-arrow-types">Arrow types</a></li>
          <li><a href="#top-type" id="markdown-toc-top-type">Top type</a></li>
          <li><a href="#aside-structural-vs-declared-subtyping" id="markdown-toc-aside-structural-vs-declared-subtyping">Aside: structural vs. declared subtyping</a></li>
        </ul>
      </li>
      <li><a href="#properties-of-subtyping" id="markdown-toc-properties-of-subtyping">Properties of subtyping</a>        <ul>
          <li><a href="#safety-1" id="markdown-toc-safety-1">Safety</a></li>
          <li><a href="#inversion-lemma-for-subtyping" id="markdown-toc-inversion-lemma-for-subtyping">Inversion lemma for subtyping</a></li>
          <li><a href="#inversion-lemma-for-typing" id="markdown-toc-inversion-lemma-for-typing">Inversion lemma for typing</a></li>
          <li><a href="#preservation-1" id="markdown-toc-preservation-1">Preservation</a></li>
        </ul>
      </li>
      <li><a href="#subtyping-features" id="markdown-toc-subtyping-features">Subtyping features</a>        <ul>
          <li><a href="#casting" id="markdown-toc-casting">Casting</a></li>
          <li><a href="#variants-1" id="markdown-toc-variants-1">Variants</a></li>
          <li><a href="#covariance" id="markdown-toc-covariance">Covariance</a></li>
          <li><a href="#invariance" id="markdown-toc-invariance">Invariance</a></li>
        </ul>
      </li>
      <li><a href="#algorithmic-subtyping" id="markdown-toc-algorithmic-subtyping">Algorithmic subtyping</a></li>
    </ul>
  </li>
  <li><a href="#objects" id="markdown-toc-objects">Objects</a>    <ul>
      <li><a href="#classes" id="markdown-toc-classes">Classes</a></li>
      <li><a href="#object-generators" id="markdown-toc-object-generators">Object generators</a></li>
      <li><a href="#dynamic-dispatch" id="markdown-toc-dynamic-dispatch">Dynamic dispatch</a></li>
      <li><a href="#encapsulation" id="markdown-toc-encapsulation">Encapsulation</a></li>
      <li><a href="#inheritance-and-subtyping" id="markdown-toc-inheritance-and-subtyping">Inheritance and subtyping</a></li>
      <li><a href="#this" id="markdown-toc-this">This</a></li>
      <li><a href="#using-this" id="markdown-toc-using-this">Using <code class="highlighter-rouge">this</code></a></li>
    </ul>
  </li>
  <li><a href="#featherweight-java" id="markdown-toc-featherweight-java">Featherweight Java</a>    <ul>
      <li><a href="#structural-vs-nominal-type-systems" id="markdown-toc-structural-vs-nominal-type-systems">Structural vs. Nominal type systems</a></li>
      <li><a href="#representing-objects" id="markdown-toc-representing-objects">Representing objects</a></li>
      <li><a href="#syntax" id="markdown-toc-syntax">Syntax</a></li>
      <li><a href="#subtyping-1" id="markdown-toc-subtyping-1">Subtyping</a></li>
      <li><a href="#auxiliary-definitions" id="markdown-toc-auxiliary-definitions">Auxiliary definitions</a></li>
      <li><a href="#evaluation-2" id="markdown-toc-evaluation-2">Evaluation</a></li>
      <li><a href="#typing" id="markdown-toc-typing">Typing</a></li>
      <li><a href="#evaluation-context" id="markdown-toc-evaluation-context">Evaluation context</a></li>
      <li><a href="#properties" id="markdown-toc-properties">Properties</a>        <ul>
          <li><a href="#progress-1" id="markdown-toc-progress-1">Progress</a></li>
          <li><a href="#preservation-2" id="markdown-toc-preservation-2">Preservation</a></li>
          <li><a href="#correspondence-with-java" id="markdown-toc-correspondence-with-java">Correspondence with Java</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#foundations-of-scala" id="markdown-toc-foundations-of-scala">Foundations of Scala</a>    <ul>
      <li><a href="#modeling-lists" id="markdown-toc-modeling-lists">Modeling lists</a></li>
      <li><a href="#abstract-types" id="markdown-toc-abstract-types">Abstract types</a></li>
      <li><a href="#dot" id="markdown-toc-dot">DOT</a>        <ul>
          <li><a href="#example-1-twice" id="markdown-toc-example-1-twice">Example 1: Twice</a></li>
          <li><a href="#example-2-church-booleans" id="markdown-toc-example-2-church-booleans">Example 2: Church booleans</a></li>
          <li><a href="#example-3-lists" id="markdown-toc-example-3-lists">Example 3: Lists</a></li>
        </ul>
      </li>
      <li><a href="#evaluation-3" id="markdown-toc-evaluation-3">Evaluation</a></li>
      <li><a href="#type-assignment-and-subtyping" id="markdown-toc-type-assignment-and-subtyping">Type assignment and subtyping</a></li>
      <li><a href="#abstract-types-1" id="markdown-toc-abstract-types-1">Abstract types</a></li>
      <li><a href="#progress-and-preservation" id="markdown-toc-progress-and-preservation">Progress and preservation</a></li>
    </ul>
  </li>
</ul>

<h2 id="writing-a-parser-with-parser-combinators">Writing a parser with parser combinators</h2>
<p>In Scala, you can (ab)use the operator overload to create an embedded DSL (EDSL) for grammars. While a grammar may look as follows in a grammar description language (Bison, Yak, ANTLR, â€¦):</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>Expr ::= Term {'+' Term | 'âˆ’' Term}
Term ::= Factor {'âˆ—' Factor | '/' Factor}
Factor ::= Number | '(' Expr ')'
</pre></td></tr></tbody></table></code></pre></figure>

<p>In Scala, we can model it as follows:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">expr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">term</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="s">"+"</span> <span class="o">~</span> <span class="n">term</span> <span class="o">|</span> <span class="s">"âˆ’"</span> <span class="o">~</span> <span class="n">term</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">term</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">factor</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="s">"âˆ—"</span> <span class="o">~</span> <span class="n">factor</span> <span class="o">|</span> <span class="s">"/"</span> <span class="o">~</span> <span class="n">factor</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">"("</span> <span class="o">~</span> <span class="n">expr</span> <span class="o">~</span> <span class="s">")"</span> <span class="o">|</span> <span class="n">numericLit</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is perhaps a little less elegant, but allows us to encode it directly into our language, which is often useful for interop.</p>

<p>The <code class="highlighter-rouge">~</code>, <code class="highlighter-rouge">|</code>, <code class="highlighter-rouge">rep</code> and <code class="highlighter-rouge">opt</code> are <strong>parser combinators</strong>. These are primitives with which we can construct a full parser for the grammar of our choice.</p>

<h3 id="boilerplate">Boilerplate</h3>

<p>First, letâ€™s define a class <code class="highlighter-rouge">ParseResult[T]</code> as an ad-hoc monad; parsing can either succeed or fail:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Success</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">result</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">msg</span> <span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>ðŸ‘‰ <code class="highlighter-rouge">Nothing</code> is the bottom type in Scala; it contains no members, and nothing can extend it</p>
</blockquote>

<p>Letâ€™s also define the tokens produced by the lexer (which we wonâ€™t define) as case classes extending <code class="highlighter-rouge">Token</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Token</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Keyword</span><span class="o">(</span><span class="n">chars</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Token</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">NumericLit</span><span class="o">(</span><span class="n">chars</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Token</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">StringLit</span><span class="o">(</span><span class="n">chars</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Token</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Identifier</span><span class="o">(</span><span class="n">chars</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Token</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Input into the parser is then a lazy stream of tokens (with positions for error diagnostics, which weâ€™ll omit here):</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">type</span> <span class="kt">Input</span> <span class="o">=</span> <span class="nc">Reader</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can then define a standard, sample parser which looks as follows on the type-level:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">StandardTokenParsers</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="nc">Input</span> <span class="k">=&gt;</span> <span class="nc">ParseResult</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="the-basic-idea">The basic idea</h3>
<p>For each language (defined by a grammar symbol <code class="highlighter-rouge">S</code>), define a function <code class="highlighter-rouge">f</code> that, given an input stream <code class="highlighter-rouge">i</code> (with tail <code class="highlighter-rouge">i'</code>):</p>

<ul>
  <li>if a prefix of <code class="highlighter-rouge">i</code> is in <code class="highlighter-rouge">S</code>, return <code class="highlighter-rouge">Success(Pair(x, i'))</code>, where <code class="highlighter-rouge">x</code> is a result for <code class="highlighter-rouge">S</code></li>
  <li>otherwise, return <code class="highlighter-rouge">Failure(msg, i)</code>, where <code class="highlighter-rouge">msg</code> is an error message string</li>
</ul>

<p>The first is called <em>success</em>, the second is <em>failure</em>. We can compose operations on this somewhat conveniently, like we would on a monad (like <code class="highlighter-rouge">Option</code>).</p>

<h3 id="simple-parser-primitives">Simple parser primitives</h3>
<p>All of the above boilerplate allows us to define a parser, which succeeds if the first token in the input satisfies some given predicate <code class="highlighter-rouge">pred</code>. When it succeeds, it reads the token string, and splits the input there.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">token</span><span class="o">(</span><span class="n">kind</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">pred</span><span class="k">:</span> <span class="kt">Token</span> <span class="o">=&gt;</span> <span class="n">boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">in</span> <span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span>
        <span class="nf">if</span> <span class="o">(</span><span class="nf">pred</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">head</span><span class="o">))</span> <span class="nc">Success</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">head</span><span class="o">.</span><span class="py">chars</span><span class="o">,</span> <span class="nv">in</span><span class="o">.</span><span class="py">tail</span><span class="o">)</span>
        <span class="k">else</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">kind</span> <span class="o">+</span> <span class="s">" expected "</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can use this to define a keyword parser:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">implicit</span> <span class="k">def</span> <span class="nf">keyword</span><span class="o">(</span><span class="n">chars</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nf">token</span><span class="o">(</span><span class="s">"'"</span> <span class="o">+</span> <span class="n">chars</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Keyword</span><span class="o">(</span><span class="n">chars1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">chars</span> <span class="o">==</span> <span class="n">chars1</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Marking it as <code class="highlighter-rouge">implicit</code> allows us to write keywords as normal strings, where we can omit the <code class="highlighter-rouge">keyword</code> call (this helps us simplify the notation in our DSL; we can write <code class="highlighter-rouge">"if"</code> instead of <code class="highlighter-rouge">keyword("if")</code>).</p>

<p>We can make other parsers for our other case classes quite simply:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">numericLit</span> <span class="k">=</span> <span class="nf">token</span><span class="o">(</span><span class="s">"number"</span><span class="o">)(</span><span class="nv">_</span><span class="o">.</span><span class="py">isInstanceOf</span><span class="o">[</span><span class="kt">NumericLit</span><span class="o">])</span>
<span class="k">def</span> <span class="nf">stringLit</span> <span class="k">=</span> <span class="nf">token</span><span class="o">(</span><span class="s">"string literal"</span><span class="o">)(</span><span class="nv">_</span><span class="o">.</span><span class="py">isInstanceOf</span><span class="o">[</span><span class="kt">StringLit</span><span class="o">])</span>
<span class="k">def</span> <span class="nf">ident</span> <span class="k">=</span> <span class="nf">token</span><span class="o">(</span><span class="s">"identifier"</span><span class="o">)(</span><span class="nv">_</span><span class="o">.</span><span class="py">isInstanceOf</span><span class="o">[</span><span class="kt">Identifier</span><span class="o">])</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="parser-combinators">Parser combinators</h3>
<p>We are going to define the following parser combinators:</p>

<ul>
  <li><code class="highlighter-rouge">~</code>: sequential composition</li>
  <li><code class="highlighter-rouge">&lt;~</code>, <code class="highlighter-rouge">&gt;~</code>: sequential composition, keeping left / right only</li>
  <li><code class="highlighter-rouge">|</code>: alternative</li>
  <li><code class="highlighter-rouge">opt(X)</code>: option (like a <code class="highlighter-rouge">?</code> quantifier in a regex)</li>
  <li><code class="highlighter-rouge">rep(X)</code>: repetition (like a <code class="highlighter-rouge">*</code> quantifier in a regex)</li>
  <li><code class="highlighter-rouge">repsep(P, Q)</code>: interleaved repetition</li>
  <li><code class="highlighter-rouge">^^</code>: result conversion (like a <code class="highlighter-rouge">map</code> on an <code class="highlighter-rouge">Option</code>)</li>
  <li><code class="highlighter-rouge">^^^</code>: constant result (like a <code class="highlighter-rouge">map</code> on an <code class="highlighter-rouge">Option</code>, but returning a constant value regardless of result)</li>
</ul>

<p>But first, weâ€™ll write some very basic parser combinators: <code class="highlighter-rouge">success</code> and <code class="highlighter-rouge">failure</code>, that respectively always succeed and always fail:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">success</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">result</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Success</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">failure</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>All of the above are methods on a <code class="highlighter-rouge">Parser[T]</code> class. Thanks to infix space notation in Scala, we can denote <code class="highlighter-rouge">x.y(z)</code> as <code class="highlighter-rouge">x y z</code>, which allows us to simplify our DSL notation; for instance <code class="highlighter-rouge">A ~ B</code> corresponds to <code class="highlighter-rouge">A.~(B)</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="c1">// An abstract method that defines the parser function</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">in</span> <span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">ParseResult</span>

    <span class="k">def</span> <span class="nf">~</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span> <span class="kt">~</span> <span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nv">Parser</span><span class="o">.</span><span class="py">this</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">rhs</span><span class="o">(</span><span class="n">tail</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
                <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="k">new</span> <span class="o">~(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">rest</span><span class="o">)</span>
                <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">failure</span>
            <span class="o">}</span>
            <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">failure</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">|</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">in</span> <span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nv">Parser</span><span class="o">.</span><span class="py">this</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">s1</span> <span class="k">@</span> <span class="nc">Success</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s1</span>
            <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="nf">rhs</span><span class="o">(</span><span class="n">in</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">^^</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">in</span> <span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nv">Parser</span><span class="o">.</span><span class="py">this</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">tail</span><span class="o">)</span>
            <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">^^^</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="o">^^(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>ðŸ‘‰ In Scala, <code class="highlighter-rouge">T ~ U</code> is syntactic sugar for <code class="highlighter-rouge">~[T, U]</code>, which is the type of the case class weâ€™ll define below</p>
</blockquote>

<p>For the <code class="highlighter-rouge">~</code> combinator, when everything works, weâ€™re using <code class="highlighter-rouge">~</code>, a case class that is equivalent to <code class="highlighter-rouge">Pair</code>, but prints the way we want to and allows for the concise type-level notation above.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">~</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">_1</span> <span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">_2</span> <span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="s">"("</span> <span class="o">+</span> <span class="n">_1</span> <span class="o">+</span> <span class="s">" ~ "</span> <span class="o">+</span> <span class="n">_2</span> <span class="o">+</span><span class="s">")"</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>At this point, we thus have <strong>two</strong> different meanings for <code class="highlighter-rouge">~</code>: a <em>function</em> <code class="highlighter-rouge">~</code> that produces a <code class="highlighter-rouge">Parser</code>, and the <code class="highlighter-rouge">~(a, b)</code> <em>case class</em> pair that this parser returns (all of this is encoded in the function signature of the <code class="highlighter-rouge">~</code> function).</p>

<p>Note that the <code class="highlighter-rouge">|</code> combinator takes the right-hand side parser as a call-by-name argument. This is because we donâ€™t want to evaluate it unless it is strictly neededâ€”that is, if the left-hand side fails.</p>

<p><code class="highlighter-rouge">^^</code> is like a <code class="highlighter-rouge">map</code> operation on <code class="highlighter-rouge">Option</code>; <code class="highlighter-rouge">P ^^ f</code> succeeds iff <code class="highlighter-rouge">P</code> succeeds, in which case it applies the transformation <code class="highlighter-rouge">f</code> on the result of P. Otherwise, it fails.</p>

<h3 id="shorthands">Shorthands</h3>

<p>We can now define shorthands for common combinations of parser combinators:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">opt</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="n">p</span> <span class="o">^^</span> <span class="nc">Some</span> <span class="o">|</span> <span class="nf">success</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">rep</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> 
    <span class="n">p</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="o">~</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">}</span> <span class="o">|</span> <span class="nf">success</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">repsep</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">p</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">q</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> 
    <span class="n">p</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="n">q</span> <span class="o">~&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">r</span> <span class="o">~</span> <span class="n">rs</span> <span class="k">=&gt;</span> <span class="n">r</span> <span class="o">::</span> <span class="n">rs</span> <span class="o">}</span> <span class="o">|</span> <span class="nf">success</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that none of the above can fail. They may, however, return <code class="highlighter-rouge">None</code> or <code class="highlighter-rouge">Nil</code> wrapped in <code class="highlighter-rouge">success</code>.</p>

<p>As an exercise, we can implement the <code class="highlighter-rouge">rep1(P)</code> parser combinator, which corresponds to the <code class="highlighter-rouge">+</code> regex quantifier:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">rep1</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="n">p</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="example-json-parser">Example: JSON parser</h3>
<p>Letâ€™s define a JSON parser. Scalaâ€™s parser combinator library has a <code class="highlighter-rouge">StandardTokenParsers</code> that give us a variety of utility methods for lexing, like <code class="highlighter-rouge">lexical.delimiters</code>, <code class="highlighter-rouge">lexical.reserved</code>, <code class="highlighter-rouge">stringLit</code> and <code class="highlighter-rouge">numericLit</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">JSON</span> <span class="k">extends</span> <span class="nc">StandardTokenParsers</span> <span class="o">{</span>
    <span class="nv">lexical</span><span class="o">.</span><span class="py">delimiters</span> <span class="o">+=</span> <span class="o">(</span><span class="s">"{"</span><span class="o">,</span> <span class="s">"}"</span><span class="o">,</span> <span class="s">"["</span><span class="o">,</span> <span class="s">"]"</span><span class="o">,</span> <span class="s">":"</span><span class="o">)</span>
    <span class="nv">lexical</span><span class="o">.</span><span class="py">reserved</span> <span class="o">+=</span> <span class="o">(</span><span class="s">"null"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">)</span>

    <span class="c1">// Return Map</span>
    <span class="k">def</span> <span class="nf">obj</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">"{"</span> <span class="o">~</span> <span class="nf">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">","</span><span class="o">)</span> <span class="o">~</span> <span class="s">"}"</span> <span class="o">^^</span> <span class="o">(</span><span class="n">ms</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">()</span> <span class="o">++</span> <span class="n">ms</span><span class="o">)</span>

    <span class="c1">// Return List</span>
    <span class="k">def</span> <span class="nf">arr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">"["</span> <span class="o">~&gt;</span> <span class="nf">repsep</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="s">","</span><span class="o">)</span> <span class="o">&lt;~</span> <span class="s">"]"</span>

    <span class="c1">// Return name/value pair:</span>
    <span class="k">def</span> <span class="nf">member</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">stringLit</span> <span class="o">~</span> <span class="s">":"</span> <span class="o">~</span> <span class="n">value</span> <span class="o">^^</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">name</span> <span class="o">~</span> <span class="s">":"</span> <span class="o">~</span> <span class="n">value</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> 
    <span class="o">}</span>

    <span class="c1">// Return correct Scala type</span>
    <span class="k">def</span> <span class="nf">value</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">obj</span> 
        <span class="o">|</span> <span class="n">arr</span> 
        <span class="o">|</span> <span class="n">stringLit</span>
        <span class="o">|</span> <span class="n">numericLit</span> <span class="o">^^</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">toInt</span><span class="o">)</span>
        <span class="o">|</span> <span class="s">"null"</span> <span class="o">^^^</span> <span class="kc">null</span>
        <span class="o">|</span> <span class="s">"true"</span> <span class="o">^^^</span> <span class="kc">true</span>
        <span class="o">|</span> <span class="s">"false"</span> <span class="o">^^^</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="the-trouble-with-left-recursion">The trouble with left-recursion</h3>

<p>Parser combinators work top-down and therefore do not allow for left-recursion. For example, the following would go into an infinite loop, where the parser keeps recursively matching the same token unto <code class="highlighter-rouge">expr</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">expr</span> <span class="k">=</span> <span class="n">expr</span> <span class="o">~</span> <span class="s">"-"</span> <span class="o">~</span> <span class="n">term</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Letâ€™s take a look at an arithmetic expression parser:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">Arithmetic</span> <span class="k">extends</span> <span class="nc">StandardTokenParsers</span> <span class="o">{</span>
    <span class="nv">lexical</span><span class="o">.</span><span class="py">delimiters</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"("</span><span class="o">,</span> <span class="s">")"</span><span class="o">,</span> <span class="s">"+"</span><span class="o">,</span> <span class="s">"âˆ’"</span><span class="o">,</span> <span class="s">"âˆ—"</span><span class="o">,</span> <span class="s">"/"</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">expr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">term</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="s">"+"</span> <span class="o">~</span> <span class="n">term</span> <span class="o">|</span> <span class="s">"âˆ’"</span> <span class="o">~</span> <span class="n">term</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">term</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">factor</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="s">"âˆ—"</span> <span class="o">~</span> <span class="n">factor</span> <span class="o">|</span> <span class="s">"/"</span> <span class="o">~</span> <span class="n">factor</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">"("</span> <span class="o">~</span> <span class="n">expr</span> <span class="o">~</span> <span class="s">")"</span> <span class="o">|</span> <span class="n">numericLit</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This definition of <code class="highlighter-rouge">expr</code>, namely <code class="highlighter-rouge">term ~ rep("-" ~ term)</code> produces a right-leaning tree. For instance, <code class="highlighter-rouge">1 - 2 - 3</code> produces <code class="highlighter-rouge">1 ~ List("-" ~ 2, ~ "-" ~ 3)</code>.</p>

<p>The solution is to combine calls to <code class="highlighter-rouge">rep</code> with a final foldLeft on the list:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">Arithmetic</span> <span class="k">extends</span> <span class="nc">StandardTokenParsers</span> <span class="o">{</span>
    <span class="nv">lexical</span><span class="o">.</span><span class="py">delimiters</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"("</span><span class="o">,</span> <span class="s">")"</span><span class="o">,</span> <span class="s">"+"</span><span class="o">,</span> <span class="s">"âˆ’"</span><span class="o">,</span> <span class="s">"âˆ—"</span><span class="o">,</span> <span class="s">"/"</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">expr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">term</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="s">"+"</span> <span class="o">~</span> <span class="n">term</span> <span class="o">|</span> <span class="s">"âˆ’"</span> <span class="o">~</span> <span class="n">term</span><span class="o">)</span> <span class="o">^^</span> <span class="n">reduceList</span>
    <span class="k">def</span> <span class="nf">term</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">factor</span> <span class="o">~</span> <span class="nf">rep</span><span class="o">(</span><span class="s">"âˆ—"</span> <span class="o">~</span> <span class="n">factor</span> <span class="o">|</span> <span class="s">"/"</span> <span class="o">~</span> <span class="n">factor</span><span class="o">)</span> <span class="o">^^</span> <span class="n">reduceList</span>
    <span class="k">def</span> <span class="nf">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">"("</span> <span class="o">~</span> <span class="n">expr</span> <span class="o">~</span> <span class="s">")"</span> <span class="o">|</span> <span class="n">numericLit</span>

    <span class="k">private</span> <span class="k">def</span> <span class="nf">reduceList</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Expr</span> <span class="kt">~</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span> <span class="kt">~</span> <span class="kt">Expr</span><span class="o">])</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">list</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">x</span> <span class="o">~</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="n">foldLeft</span> <span class="n">ps</span><span class="o">)(</span><span class="n">reduce</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">private</span> <span class="k">def</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">~</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">r</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="s">"+"</span> <span class="o">~</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
        <span class="k">case</span> <span class="s">"âˆ’"</span> <span class="o">~</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">âˆ’</span> <span class="n">y</span>
        <span class="k">case</span> <span class="s">"âˆ—"</span> <span class="o">~</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">âˆ—</span> <span class="n">y</span>
        <span class="k">case</span> <span class="s">"/"</span> <span class="o">~</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
        <span class="k">case</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">MatchError</span><span class="o">(</span><span class="s">"illegal case: "</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>ðŸ‘‰ It used to be that the standard library contained parser combinators, but those are now a <a href="https://github.com/scala/scala-parser-combinators">separate module</a>. This module contains a <code class="highlighter-rouge">chainl</code> (chain-left) method that reduces after a <code class="highlighter-rouge">rep</code> for you.</p>
</blockquote>

<h2 id="arithmetic-expressions--abstract-syntax-and-proof-principles">Arithmetic expressions â€” abstract syntax and proof principles</h2>
<p>This section follows Chapter 3 in TAPL.</p>

<h3 id="basics-of-induction">Basics of induction</h3>
<p>Ordinary induction is simply:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Suppose P is a predicate on natural numbers.
Then:
    If P(0)
    and, for all i, P(i) implies P(i + 1)
    then P(n) holds for all n
</code></pre></div></div>

<p>We can also do complete induction:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Suppose P is a predicate on natural numbers.
Then:
    If for each natural number n,
    given P(i) for all i &lt; n we can show P(n)
    then P(n) holds for all n
</code></pre></div></div>

<p>It proves exactly the same thing as ordinary induction, it is simply a restated version. Theyâ€™re <em>interderivable</em>; assuming one, we can prove the other. Which one to use is simply a matter of style or convenience. Weâ€™ll see some more equivalent styles as we go along.</p>

<h3 id="mathematical-representation-of-syntax">Mathematical representation of syntax</h3>
<p>Letâ€™s assume the following grammar:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>t ::= 
    true
    false
    if t then t else t
    0
    succ t
    pred t
    iszero t
</pre></td></tr></tbody></table></code></pre></figure>

<p>What does this really define? A few suggestions:</p>

<ul>
  <li>A set of character strings</li>
  <li>A set of token lists</li>
  <li>A set of abstract syntax trees</li>
</ul>

<p>It depends on how you read it; a grammar like the one above contains information about all three.</p>

<p>However, we are mostly interested in the ASTs. The above grammar is therefore called an <strong>abstract grammar</strong>. Its main purpose is to suggest a mapping from character strings to trees.</p>

<p>For our use of these, we wonâ€™t be too strict with these. For instance, weâ€™ll freely use parentheses to disambiguate what tree we mean to describe, even though theyâ€™re not strictly supported by the grammar. What matters to us here arenâ€™t strict implementation semantics, but rather that we have a framework to talk about ASTs. For our purposes, weâ€™ll consider that two terms producing the same AST are basically the same; still, weâ€™ll distinguish terms that only have the same evaluation result, as they donâ€™t necessarily have the same AST.</p>

<p>How can we express our grammar as mathematical expressions? A grammar describes the legal <em>set</em> of terms in a program by offering a recursive definition. While recursive definitions may seem obvious and simple to a programmer, we have to go through a few hoops to make sense of them mathematically.</p>

<h4 id="mathematical-representation-1">Mathematical representation 1</h4>
<p>We can use a set $\mathcal{T}$ of terms. The grammar is then the smallest set such that:</p>

<ol>
  <li>$\left\{ \text{true}, \text{false}, 0 \right\} \subseteq \mathcal{T}$,</li>
  <li>If $t_1 \in \mathcal{T}$ then $\left\{ \text{succ } t_1, \text{pred } t_1, \text{iszero } t_1 \right\} \subseteq \mathcal{T}$,</li>
  <li>If $t_1, t_2, t_3 \in \mathcal{T}$ then we also have $\text{if } t_1 \text{ then } t_2 \text{ else } t_3 \in \mathcal{T}$.</li>
</ol>

<h4 id="mathematical-representation-2">Mathematical representation 2</h4>
<p>We can also write this somewhat more graphically:</p>

\[\newcommand{\abs}[1]{\left\lvert#1\right\rvert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\if}{\text{if }}
\newcommand{\then}{\text{ then }}
\newcommand{\else}{\text{ else }}
\newcommand{\ifelse}{\if t_1 \then t_2 \else t_3}
\newcommand{\defeq}{\overset{\text{def}}{=}}
\newenvironment{rcases}
  {\left.\begin{aligned}}
  {\end{aligned}\right\rbrace}

\text{true } \in \mathcal{T},  \quad
\text{false } \in \mathcal{T}, \quad
0 \in \mathcal{T}              \\ \\

\frac{t_1 \in \mathcal{T}}{\text{succ } t_1 \in \mathcal{T}}, \quad
\frac{t_1 \in \mathcal{T}}{\text{pred } t_1 \in \mathcal{T}}, \quad
\frac{t_1 \in \mathcal{T}}{\text{iszero } t_1 \in \mathcal{T}} \\ \\

\frac{t_1 \in \mathcal{T}, \quad t_2 \in \mathcal{T}, \quad t_3 \in \mathcal{T}}{\ifelse \in \mathcal{T}}\]

<p>This is exactly equivalent to representation 1, but we have just introduced a different notation. Note that â€œthe smallest set closed underâ€¦â€ is often not stated explicitly, but implied.</p>

<h4 id="mathematical-representation-3">Mathematical representation 3</h4>
<p>Alternatively, we can build up our set of terms as an infinite union:</p>

\[\begin{align}
\mathcal{S}_0 = &amp; &amp; \emptyset \\
\mathcal{S}_{i+1} = 
    &amp;      &amp; \set{\text{true}, \text{ false}, 0} \\
    &amp; \cup &amp; \set{\text{succ } t_1, \text{pred } t_1, \text{iszero } t_1 \mid t_1 \in \mathcal{S}_i} \\
    &amp; \cup &amp; \set{\ifelse \mid t_1, t_2, t_3 \in \mathcal{S}_i}
\end{align}\]

<p>We can thus build our final set as follows:</p>

\[\mathcal{S} = \bigcup_i{\mathcal{S}_i}\]

<p>Note that we can â€œpull outâ€ the definition into a generating function $F$:</p>

\[\begin{align}
\mathcal{S}_0     &amp; = \emptyset \\
\mathcal{S}_{i+1} &amp; = F(\mathcal{S}_i) \\
\mathcal{S}       &amp; = \bigcup_i{\mathcal{S}_i} \\
\end{align}\]

<p>The generating function is thus defined as:</p>

\[\begin{align}
F_1(U) &amp; = \set{\text{true}} \\
F_2(U) &amp; = \set{\text{false}} \\
F_3(U) &amp; = \set{0} \\
F_4(U) &amp; = \set{\text{succ } t_1 \mid t_1 \in U} \\
F_5(U) &amp; = \set{\text{pred } t_1 \mid t_1 \in U} \\
F_6(U) &amp; = \set{\text{iszero } t_1 \mid t_1 \in U} \\
F_7(U) &amp; = \set{\ifelse \mid t_1, t_2, t_3 \in U} \\
\end{align} \\

F(U) = \bigcup_{i=1}^7{F_i(U)}\]

<p>Each function takes a set of terms $U$ as input and produces â€œterms justified by $U$â€ as output; that is, all terms that have the items of $U$ as subterms.</p>

<p>The set $U$ is said to be <strong>closed under F</strong> or <strong>F-closed</strong> if $F(U) \subseteq U$.</p>

<p>The set of terms $T$ as defined above is the smallest F-closed set. If $O$ is another F-closed set, then $T \subseteq O$.</p>

<h4 id="comparison-of-the-representations">Comparison of the representations</h4>
<p>Weâ€™ve seen essentially two ways of defining the set (as representation 1 and 2 are equivalent, but with different notation):</p>

<ol>
  <li>The smallest set that is closed under certain rules. This is compact and easy to read.</li>
  <li>The limit of a series of sets. This gives us an <em>induction principle</em> on which we can prove things on terms by induction.</li>
</ol>

<p>The first one defines the set â€œfrom aboveâ€, by intersecting F-closed sets.</p>

<p>The second one defines it â€œfrom belowâ€, by starting with $\emptyset$ and getting closer and closer to being F-closed.</p>

<p>These are equivalent (we wonâ€™t prove it, but Proposition 3.2.6 in TAPL does so), but can serve different uses in practice.</p>

<h3 id="induction-on-terms">Induction on terms</h3>
<p>First, letâ€™s define depth: the <strong>depth</strong> of a term $t$ is the smallest $i$ such that $t\in\mathcal{S_i}$.</p>

<p>The way we defined $\mathcal{S}_i$, it gets larger and larger for increasing $i$; the depth of a term $t$ gives us the step at which $t$ is introduced into the set.</p>

<p>We see that if a term $t$ is in \(\mathcal{S}_i\), then all of its immediate subterms must be in $\mathcal{S}_{i-1}$, meaning that they must have smaller depth.</p>

<p>This justifies the principle of <strong>induction on terms</strong>, or <strong>structural induction</strong>. Let P be a predicate on a term:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If, for each term s,
    given P(r) for all immediate subterms r of s we can show P(s)
    then P(t) holds for all t
</code></pre></div></div>

<p>All this says is that if we can prove the induction step from subterms to terms (under the induction hypothesis), then we have proven the induction.</p>

<p>We can also express this structural induction using generating functions, which we <a href="#mathematical-representation-3">introduced previously</a>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Suppose T is the smallest F-closed set.
If, for each set U,
    from the assumption "P(u) holds for every u âˆˆ U",
    we can show that "P(v) holds for every v âˆˆ F(U)"
then
    P(t) holds for all t âˆˆ T
</code></pre></div></div>

<p>Why can we use this?</p>

<ul>
  <li>We assumed that $T$ was the smallest F-closed set, which means that $T\subseteq O$ for any other F-closed set $O$.</li>
  <li>Showing the pre-condition (â€œfor each set $U$, from the assumptionâ€¦â€) amounts to showing that the set of all terms satisfying $P$ (call it $O$) is itself an F-closed set.</li>
  <li>Since $T\subseteq O$, every element of $T$ satisfies $P$.</li>
</ul>

<h3 id="inductive-function-definitions">Inductive function definitions</h3>
<p>An <a href="https://en.wikipedia.org/wiki/Recursive_definition">inductive definition</a> is used to define the elements in a set recursively, as we have done above. The <a href="https://en.wikipedia.org/wiki/Recursion#The_recursion_theorem">recursion theorem</a> states that a well-formed inductive definition defines a function. To understand what being well-formed means, letâ€™s take a look at some examples.</p>

<p>Letâ€™s define our grammar function a little more formally. Constants are the basic values that canâ€™t be expanded further; in our example, they are <code class="highlighter-rouge">true</code>, <code class="highlighter-rouge">false</code>, <code class="highlighter-rouge">0</code>. As such, the set of constants appearing in a term $t$, written $\text{Consts}(t)$, is defined recursively as follows:</p>

\[\begin{align}
\text{Consts}(\text{true})  &amp; = \set{\text{true}}  \\
\text{Consts}(\text{false}) &amp; = \set{\text{false}} \\
\text{Consts}(0)            &amp; = \set{0}            \\

\text{Consts}(\text{succ } t_1) &amp; = \text{Consts}(t_1) \\
\text{Consts}(\text{pred } t_1) &amp; = \text{Consts}(t_1) \\
\text{Consts}(\text{iszero } t_1) &amp; = \text{Consts}(t_1) \\
\text{Consts}(\ifelse &amp; = \text{Consts}(t_1) \cup \text{Consts}(t_2) \cup \text{Consts}(t_3) \\
\end{align}\]

<p>This seems simple, but these semantics arenâ€™t perfect. First off, a mathematical definition simply assigns a convenient name to some previously known thing. But here, weâ€™re defining the thing in terms of itself, recursively. And the semantics above also allow us to define ill-formed inductive definitions:</p>

\[\begin{align}
\text{BadConsts}(\text{true})  &amp; = \set{\text{true}}  \\
\text{BadConsts}(\text{false}) &amp; = \set{\text{false}} \\
\text{BadConsts}(0)            &amp; = \set{0}            \\
\text{BadConsts}(0)            &amp; = \set{} = \emptyset \\

\text{BadConsts}(\text{succ } t_1) &amp; = \text{BadConsts}(t_1) \\
\text{BadConsts}(\text{pred } t_1) &amp; = \text{BadConsts}(t_1) \\
\text{BadConsts}(\text{iszero } t_1) &amp; = \text{BadConsts}(\text{iszero iszero }t_1) \\
\end{align}\]

<p>The last rule produces infinitely large rules (if we implemented it, weâ€™d expect some kind of stack overflow). Weâ€™re missing the rules for if-statements, and we have a useless rule for <code class="highlighter-rouge">0</code>, producing empty sets.</p>

<p>How do we tell the difference between a well-formed inductive definition, and an ill-formed one as above? What is well-formedness anyway?</p>

<h4 id="what-is-a-function">What is a function?</h4>

<p>A relation over $T, U$ is a subset of $T \times U$, where the Cartesian product is defined as:</p>

\[T\times U = \set{(t, u) : t\in T, u\in U}\]

<p>A function $f$ from $A$ (domain) to $B$ (co-domain) can be viewed as a two-place relation, albeit with two additional properties:</p>

<ul>
  <li>It is <strong>total</strong>: $\forall a \in A, \exists b \in B : (a, b) \in f$</li>
  <li>It is <strong>deterministic</strong>: $(a, b_1) \in f, (a, b_2) \in f \implies b_1 = b_2$</li>
</ul>

<p>Totality ensures that the A domain is covered, while being deterministic just means that the function always produces the same result for a given input.</p>

<h4 id="induction-example-1">Induction example 1</h4>
<p>As previously stated, $\text{Consts}$ is a <em>relation</em>. It maps terms (A) into the set of constants that they contain (B). The induction theorem states that it is also a <em>function</em>. The proof is as follows.</p>

<p>$\text{Consts}$ is total and deterministic: for each term $t$ there is exactly one set of terms $C$ such that $(t, C) \in \text{Consts}$<sup id="fnref:in-relation-notation" role="doc-noteref"><a href="#fn:in-relation-notation" class="footnote">1</a></sup> . The proof is done by induction on $t$.</p>

<p>To be able to apply the induction principle for terms, we must first show that for an arbitrary term $t$, under the following induction hypothesis:</p>

<blockquote>
  <p>For each immediate subterm $s$ of $t$, there is exactly one set of terms $C_s$ such that $(s, C_s) \in \text{Consts}$</p>
</blockquote>

<p>Then the following needs to be proven as an induction step:</p>

<blockquote>
  <p>There is <strong>exactly one</strong> set of terms $C$ such that $(t, C) \in \text{Consts}$</p>
</blockquote>

<p>We proceed by cases on $t$:</p>

<ul>
  <li>
    <p>If $t$ is $0$, $\text{true}$ or $\text{false}$</p>

    <p>We can immediately see from the definition that of $\text{Consts}$ that there is exactly one set of terms $C = \set{t}$) such that $(t, C) \in \text{Consts}$.</p>

    <p>This constitutes our base case.</p>
  </li>
  <li>
    <p>If $t$ is $\text{succ } t_1$, $\text{pred } t_1$ or $\text{iszero } t_1$</p>

    <p>The immediate subterm of $t$ is $t_1$, and the induction hypothesis tells us that there is exactly one set of terms $C_1$ such that $(t_1, C_1) \in \text{Consts}$. But then it is clear from the definition that there is exactly one set of terms $C = C_1$ such that $(t, C) \in \text{Consts}$.</p>
  </li>
  <li>
    <p>If $t$ is $\ifelse$</p>

    <p>The induction hypothesis tells us:</p>

    <ul>
      <li>There is exactly one set of terms $C_1$ such that $(t_1, C_1) \in \text{Consts}$</li>
      <li>There is exactly one set of terms $C_2$ such that $(t_2, C_2) \in \text{Consts}$</li>
      <li>There is exactly one set of terms $C_3$ such that $(t_3, C_3) \in \text{Consts}$</li>
    </ul>

    <p>It is clear from the definition of $\text{Consts}$ that there is exactly one set $C = C_1 \cup C_2 \cup C_3$ such that $(t, C) \in \text{Consts}$.</p>
  </li>
</ul>

<p>This proves that $\text{Consts}$ is indeed a function.</p>

<p>But what about $\text{BadConsts}$? It is also a relation, but it isnâ€™t a function. For instance, we have $\text{BadConsts}(0) = \set{0}$ and $\text{BadConsts}(0) = \emptyset$, which violates determinism. To reformulate this in terms of the above, there are two sets $C$ such that $(0, C) \in \text{BadConsts}$, namely $C = \set{0}$ and $C = \emptyset$.</p>

<p>Note that there are many other problems with $\text{BadConsts}$, but this is sufficient to prove that it isnâ€™t a function.</p>

<h4 id="induction-example-2">Induction example 2</h4>
<p>Letâ€™s introduce another inductive definition:</p>

\[\begin{align}
\text{size}(\text{true})  &amp; = 1 \\
\text{size}(\text{false}) &amp; = 1 \\
\text{size}(0)            &amp; = 1 \\
\text{size}(\text{succ}\ t_1)   &amp; = \text{size}(t_1) + 1 \\
\text{size}(\text{pred}\ t_1)   &amp; = \text{size}(t_1) + 1 \\
\text{size}(\text{iszero}\ t_1) &amp; = \text{size}(t_1) + 1 \\
\text{size}(\ifelse) &amp; = \text{size}(t_1) + \text{size}(t_2) + \text{size}(t_3)\\
\end{align}\]

<p>Weâ€™d like to prove that the number of distinct constants in a term is at most the size of the term. In other words, that $\abs{\text{Consts}(t)} \le \text{size}(t)$</p>

<p>The proof is by induction on $t$:</p>

<ul>
  <li>
    <p>$t$ is a constant; $t=\text{true}$, $t=\text{false}$ or $t=0$</p>

    <p>The proof is immediate. For constants, the number of constants and the size are both one: $\abs{\text{Consts(t)}} = \abs{\set{t}} = 1 = \text{size}(t)$</p>
  </li>
  <li>
    <p>$t$ is a function; $t = \text{succ}\ t_1$, $t = \text{pred}\ t_1$ or $t = \text{iszero}\ t_1$</p>

    <p>By the induction hypothesis, $\abs{\text{Consts}(t1)} \le \text{size}(t_1)$.</p>

    <p>We can then prove the proposition as follows: $\abs{\text{Consts}(t)} = \abs{\text{Consts}(t_1)} \overset{\text{IH}}{\le} \text{size}(t_1) = \text{size}(t) + 1 &lt; \text{size}(t)$</p>
  </li>
  <li>
    <p>$t$ is an if-statement: $t = \ifelse$</p>

    <p>By the induction hypothesis, $\abs{\text{Consts}(t_1)} \le \text{size}(t_1)$, $\abs{\text{Consts}(t_2)} \le \text{size}(t_2)$ and $\abs{\text{Consts}(t_3)} \le \text{size}(t_3)$.</p>

    <p>We can then prove the proposition as follows:</p>
  </li>
</ul>

\[\begin{align}
\abs{\text{Consts}}
    &amp; = \abs{\text{Consts}(t_1)\cup\text{Consts}(t_2)\cup\text{Consts}(t_3)} \\
    &amp; \le \abs{\text{Consts}(t_1)}+\abs{\text{Consts}(t_2)}+\abs{\text{Consts}(t_3)} \\
    &amp; \overset{\text{IH}}{\le} \text{size}(t_1) + \text{size}(t_2) + \text{size}(t_3) \\
    &amp; &lt; \text{size}(t)
\end{align}\]

<h3 id="operational-semantics-and-reasoning">Operational semantics and reasoning</h3>

<h4 id="evaluation">Evaluation</h4>
<p>Suppose we have the following syntax</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre>t ::=                  // terms
    true                   // constant true
    false                  // constant false 
    if t then t else t     // conditional
</pre></td></tr></tbody></table></code></pre></figure>

<p>The evaluation relation $t \longrightarrow tâ€™$ is the smallest relation closed under the following rules.</p>

<p>The following are <em>computation rules</em>, defining the â€œrealâ€ computation steps:</p>

\[\begin{align}
\text{if true then } t_2 \else t_3 \longrightarrow t_2 
\tag{E-IfTrue}
\label{eq:e-iftrue} \\

\text{if false then } t_2 \else t_3 \longrightarrow t_3 
\tag{E-IfFalse}
\label{eq:e-iffalse} \\
\end{align}\]

<p>The following is a <em>congruence rule</em>, defining where the computation rule is applied next:</p>

\[\frac{t_1 \longrightarrow t_1'}
     {\ifelse \longrightarrow \if t_1' \then t_2 \else t_3} 
\tag{E-If}
\label{eq:e-if}\]

<p>We want to evaluate the condition before the conditional clauses in order to save on evaluation; weâ€™re not sure which one should be evaluated, so we need to know the condition first.</p>

<h4 id="derivations">Derivations</h4>
<p>We can describe the evaluation logically from the above rules using derivation trees. Suppose we want to evaluate the following (with parentheses added for clarity): <code class="highlighter-rouge">if (if true then true else false) then false else true</code>.</p>

<p>In an attempt to make all this fit onto the screen, <code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code> have been abbreviated <code class="highlighter-rouge">T</code> and <code class="highlighter-rouge">F</code> in the derivation below, and the <code class="highlighter-rouge">then</code> keyword has been replaced with a parenthesis notation for the condition.</p>

\[\frac{
    \frac{
        \if (T)\ T \else F
        \longrightarrow
        T
        \quad (\ref{eq:e-iftrue})
    }{
        \if (\if (T)\ T \else F) \ F \else T
        \longrightarrow
        \if (T) \ F \else T
        \quad (\ref{eq:e-if})
    }

    \qquad 

    \small{
        \if (T) \ F \else T
        \longrightarrow
        F
        \quad (\ref{eq:e-iftrue})
    }
}{
    \if (\if (T) \ T \else F) \ F \else T
    \longrightarrow
    T
}\]

<p>The final statement is a <strong>conclusion</strong>. We say that the derivation is a <strong>witness</strong> for its conclusion (or a <strong>proof</strong> for its conclusion). The derivation records all reasoning steps that lead us to the conclusion.</p>

<h4 id="inversion-lemma">Inversion lemma</h4>
<p>We can introduce the <strong>inversion lemma</strong>, which tells us how we got to a term.</p>

<p>Suppose we are given a derivation $\mathcal{D}$ witnessing the pair $(t, tâ€™)$ in the evaluation relation. Then either:</p>

<ol>
  <li>If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-iftrue})$, then we have $\if true \then t_2 \else t_3$ and $tâ€™=t_2$ for some $t_2$ and $t_3$</li>
  <li>If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-iffalse})$, then we have $\if false \then t_2 \else t_3$ and $tâ€™=t_2$ for some $t_2$ and $t_3$</li>
  <li>If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-if})$, then we have $t = \if t_1 \then t_2 \else t_3$ and $tâ€™ = t = \if t_1â€™ \then t_2 \else t_3$, for some $t_1, t_1â€™, t_2, t_3$. Moreover, the immediate subderivation of $\mathcal{D}$ witnesses $(t_1, t_1â€™) \in \longrightarrow$.</li>
</ol>

<p>This is super boring, but we do need to acknowledge the inversion lemma before we can do induction proofs on derivations. Thanks to the inversion lemma, given an arbitrary derivation $\mathcal{D}$ with conclusion $t \longrightarrow tâ€™$, we can proceed with a case-by-case analysis on the final rule used in the derivation tree.</p>

<p>Letâ€™s recall our <a href="#induction-example-2">definition of the size function</a>. In particular, weâ€™ll need the rule for if-statements:</p>

\[\text{size}(\ifelse) = \text{size}(t_1) + \text{size}(t_2) + \text{size}(t_3)\]

<p>We want to prove that if $t \longrightarrow tâ€™$, then $\text{size}(t) &gt; \text{size}(tâ€™)$.</p>

<ol>
  <li>If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-iftrue})$, then we have $t = \if true \then t_2 \else t_3$ and $tâ€™=t_2$, and the result is immediate from the definition of $\text{size}$</li>
  <li>If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-iffalse})$, then we have $t = \if false \then t_2 \else t_3$ and $tâ€™=t_2$, and the result is immediate from the definition of $\text{size}$</li>
  <li>If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-if})$, then we have $t = \ifelse$ and $tâ€™ = \if t_1â€™ \then t_2 \else t_3$. In this case, $t_1 \longrightarrow t_1â€™$ is witnessed by a derivation $\mathcal{D}_1$. By the induction hypothesis, $\text{size}(t_1) &gt; \text{size}(t_1â€™)$, and the result is then immediate from the definition of $\text{size}$</li>
</ol>

<h3 id="abstract-machines">Abstract machines</h3>
<p>An abstract machine consists of:</p>

<ul>
  <li>A set of <strong>states</strong></li>
  <li>A <strong>transition</strong> relation of states, written $\longrightarrow$</li>
</ul>

<p>$t \longrightarrow tâ€™$ means that $t$ evaluates to $tâ€™$ in one step. Note that $\longrightarrow$ is a relation, and that $t \longrightarrow tâ€™$ is shorthand for $(t, tâ€™) \in \longrightarrow$. Often, this relation is a partial function (not necessarily covering the domain A; there is at most one possible next state). But without loss of generality, there may be many possible next states, determinism isnâ€™t a criterion here.</p>

<h3 id="normal-forms">Normal forms</h3>
<p>A normal form is a term that cannot be evaluated any further. More formally, a term $t$ is a normal form if there is no $tâ€™$ such that $t \longrightarrow tâ€™$.  A normal form is a state where the abstract machine is halted; we can regard it as the result of a computation.</p>

<h4 id="values-that-are-normal-form">Values that are normal form</h4>
<p>Previously, we intended for our values (true and false) to be exactly that, the result of a computation. Did we get that right?</p>

<p>Letâ€™s prove that a term $t$ is a value $\iff$ it is in normal form.</p>

<ul>
  <li>The $\implies$ direction is immediate from the definition of the evaluation relation $\longrightarrow$.</li>
  <li>
    <p>The $\impliedby$ direction is more conveniently proven as its contrapositive: if $t$ is not a value, then it is not a normal form, which we can prove by induction on the term $t$.</p>

    <p>Since $t$ is not a value, it must be of the form $\ifelse$. If $t_1$ is directly <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>, then $\ref{eq:e-iftrue}$ or $\ref{eq:e-iffalse}$ apply, and we are done.</p>

    <p>Otherwise, if $t = \ifelse$ where $t_1$ isnâ€™t a value, by the induction hypothesis, there is a $t_1â€™$ such that $t_1 \longrightarrow t_1â€™$. Then rule $\ref{eq:e-if}$ yields $\if t_1â€™ \then t_2 \else t_3$, which proves that $t$ is not in normal form.</p>
  </li>
</ul>

<h4 id="values-that-are-not-normal-form">Values that are not normal form</h4>
<p>Letâ€™s introduce new syntactic forms, with new evaluation rules.</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>t ::=        // terms
    0            // constant 0
    succ t       // successor
    pred t       // predecessor 
    iszero t     // zero test

v ::=  nv     // values

nv ::=        // numeric values
    0             // zero value
    succ nv       // successor value
</pre></td></tr></tbody></table></code></pre></figure>

<p>The evaluation rules are given as follows:</p>

\[\begin{align}
&amp; \frac{t_1 \longrightarrow t_1'}{\text{succ } t_1 \longrightarrow \text{succ } t_1'} 
\tag{E-Succ} \label{eq:e-succ}
\\ \\
&amp; \text{pred } 0 \longrightarrow 0
\tag{E-PredZero} \label{eq:e-predzero} 
\\ \\
&amp; \text{pred succ } nv_1 \longrightarrow nv_1
\tag{E-PredSucc} \label{eq:e-predsucc}
\\ \\
&amp; \frac{t_1 \longrightarrow t_1'}{\text{pred } t_1 \longrightarrow \text{pred } t_1'}
\tag{E-Pred} \label{eq:e-pred}
\\ \\
&amp; \text{iszero } 0 \longrightarrow true
\tag{E-IszeroZero} \label{eq:e-iszerozero}
\\ \\
&amp; \text{iszero succ } nv_1 \longrightarrow false
\tag{E-IszeroSucc} \label{eq:e-iszerosucc}
\\ \\
&amp; \frac{t_1 \longrightarrow t_1'}{\text{iszero } t_1 \longrightarrow \text{iszero } t_1'}
\tag{E-Iszero} \label{eq:e-iszero} \\
\end{align}\]

<p>All values are still normal forms. But are all normal forms values? Not in this case. For instance, <code class="highlighter-rouge">succ true</code>, <code class="highlighter-rouge">iszero true</code>, etc, are normal forms. These are <strong>stuck terms</strong>: they are in normal form, but are not values. In general, these correspond to some kind of type error, and one of the main purposes of a type system is to rule these kinds of situations out.</p>

<h3 id="multi-step-evaluation">Multi-step evaluation</h3>
<p>Letâ€™s introduce the <em>multi-step evaluation</em> relation, $\longrightarrow^*$. It is the reflexive, transitive closure of single-step evaluation, i.e. the smallest relation closed under these rules:</p>

\[\begin{align}
\frac{t\longrightarrow t'}{t \longrightarrow^* t'} \\ \\
t \longrightarrow^* t \tag{Reflexivity} \\ \\
\frac{t \longrightarrow^* t' \qquad t' \longrightarrow^* t''}{t \longrightarrow^* t''} \tag{Transitivity}
\end{align}\]

<p>In other words, it corresponds to any number of single consecutive evaluations.</p>

<h3 id="termination-of-evaluation">Termination of evaluation</h3>
<p>Weâ€™ll prove that evaluation terminates, i.e. that for every term $t$ there is some normal form $tâ€™$ such that $t\longrightarrow^* tâ€™$.</p>

<p>First, letâ€™s <a href="#induction-example-2">recall our proof</a> that $t\longrightarrow tâ€™ \implies \text{size}(t) &gt; \text{size}(tâ€™)$. Now, for our proof by contradiction, assume that we have an infinite-length sequence $t_0, t_1, t_2, \dots$ such that:</p>

\[t_0 \longrightarrow t_1 \longrightarrow t_2 \longrightarrow \dots
\quad \implies \quad 
\text{size}(t_0) &gt; \text{size}(t_1) &gt; \text{size}(t_2) &gt; \dots\]

<p>But this sequence cannot exist: since $\text{size}(t_0)$ is a finite, natural number, we cannot construct this infinite descending chain from it. This is a contradiction.</p>

<p>Most termination proofs have the same basic form. We want to prove that the relation $R\subseteq X \times X$ is terminating â€” that is, there are no infinite sequences $x_0, x_1, x_2, \dots$ such that $(x_i, x_{i+1}) \in R$ for each $i$. We proceed as follows:</p>

<ol>
  <li>Choose a well-suited set $W$ with partial order $&lt;$ such that there are no infinite descending chains $w_0 &gt; w_1 &gt; w_2 &gt; \dots$ in $W$. Also choose a function $f: X \rightarrow W$.</li>
  <li>Show $f(x) &gt; f(y) \quad \forall (x, y) \in R$</li>
  <li>Conclude that are no infinite sequences $(x_0, x_1, x_2, \dots)$ such that $(x_i, x_{i+1}) \in R$ for each $i$. If there were, we could construct an infinite descending chain in $W$.</li>
</ol>

<p>As a side-note, <strong>partial order</strong> is defined as the following properties:</p>

<ol>
  <li><strong>Anti-symmetry</strong>: $\neg(x &lt; y \land y &lt; x)$</li>
  <li><strong>Transitivity</strong>: $x&lt;y \land y&lt;z \implies x &lt; z$</li>
</ol>

<p>We can add a third property to achieve <strong>total order</strong>, namely $x \ne y \implies x &lt;y \lor y&lt;x$.</p>

<h2 id="lambda-calculus">Lambda calculus</h2>
<p>Lambda calculus is Turing complete, and is higher-order (functions are data). In lambda calculus, all computation happens by means of function abstraction and application.</p>

<p>Lambda calculus is isomorphic to Turing machines.</p>

<p>Suppose we wanted to write a function <code class="highlighter-rouge">plus3</code> in our previous language:</p>

<figure class="highlight"><pre><code class="language-linenos" data-lang="linenos">plus3 x = succ succ succ x</code></pre></figure>

<p>The way we write this in lambda calculus is:</p>

\[\text{plus3 } = \lambda x. \text{ succ}(\text{succ}(\text{succ}(x)))\]

<p>$\lambda x. t$ is written <code class="highlighter-rouge">x =&gt; t</code> in Scala, or <code class="highlighter-rouge">fun x -&gt; t</code> in OCaml. Application of our function, say <code class="highlighter-rouge">plus3(succ 0)</code>, can be written as:</p>

\[(\lambda x. \text{succ succ succ } x)(\text{succ } 0)\]

<p>Abstraction over functions is possible using higher-order functions, which we call $\lambda$-abstractions. An example of such an abstraction is the function $g$ below, which takes an argument $f$ and uses it in the function position.</p>

\[g = \lambda f. f(f(\text{succ } 0))\]

<p>If we apply $g$ to an argument like $\text{plus3}$, we can just use the substitution rule to see how that defines a new function.</p>

<p>Another example: the <code class="highlighter-rouge">twice</code> function below takes two arguments, as a curried function would. First, it takes the function to apply twice, then the argument on which to apply it, and then returns $f(f(y))$.</p>

\[\text{twice} = \lambda f. \lambda y. f(f(y))\]

<h3 id="pure-lambda-calculus">Pure lambda calculus</h3>
<p>Once we have $\lambda$-abstractions, we can actually throw out all other language primitives like booleans and other values; all of these can be expressed as functions, as weâ€™ll see below. In pure lambda-calculus, <em>everything</em> is a function.</p>

<p>Variables will always denote a function, functions always take other functions as parameters, and the result of an evaluation is always a function.</p>

<p>The syntax of lambda-calculus is very simple:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre>t ::=      // terms, also called Î»-terms
    x         // variable
    Î»x. t     // abstraction, also called Î»-abstractions
    t t       // application
</pre></td></tr></tbody></table></code></pre></figure>

<p>A few rules and syntactic conventions:</p>

<ul>
  <li>Application associates to the left, so $t\ u\ v$ means $(t\ u)\ v$, not $t\ (u\ v)$.</li>
  <li>Bodies of lambda abstractions extend as far to the right as possible, so $\lambda x. \lambda y.\ x\ y$ means $\lambda x.\ (\lambda y. x\ y)$, not $\lambda x.\ (\lambda y.\ x)\ y$</li>
</ul>

<h4 id="scope">Scope</h4>
<p>The lambda expression $\lambda x.\ t$ <strong>binds</strong> the variable $x$, with a <strong>scope</strong> limited to $t$. Occurrences of $x$ inside of $t$ are said to be <em>bound</em>, while occurrences outside are said to be <em>free</em>.</p>

<p>Let $\text{fv}(t)$ be the set of free variables in a term $t$. Itâ€™s defined as follows:</p>

\[\begin{align}
\text{fv}(x) &amp; = \set{x} \\
\text{fv}(\lambda x.\ t_1) &amp; = \text{fv}(t_1) \setminus \set{x} \\ 
\text{fv}(t_1 \ t_2) &amp; = \text{fv}(t_1)\cup\text{fv}(t_2) \\
\end{align}\]

<h4 id="operational-semantics">Operational semantics</h4>
<p>As we saw with our previous language, the rules could be distinguished into <em>computation</em> and <em>congruence</em> rules. For lambda calculus, the only computation rule is:</p>

\[(\lambda x. t_{12})\ v_2 \longrightarrow \left[ x \mapsto v_2 \right] t_{12}
\tag{E-AppAbs}\label{eq:e-appabs}\]

<p>The notation $\left[ x \mapsto v_2 \right] t_{12}$ means â€œthe term that results from substituting free occurrences of $x$ in $t_{12}$ with $v_2$â€.</p>

<p>The congruence rules are:</p>

\[\begin{align}
&amp; \frac{t_1 \longrightarrow t_1'}{t_1\ t_2 \longrightarrow t_1'\ t_2} \tag{E-App1}\label{eq:e-app1} \\ \\
&amp; \frac{t_2 \longrightarrow t_2'}{t_1\ t_2 \longrightarrow t_1\ t_2'} \tag{E-App2}\label{eq:e-app2} \\
\end{align}\]

<p>A lambda-expression applied to a value, $(\lambda x.\ t)\ v$, is called a <strong>reducible expression</strong>, or <strong>redex</strong>.</p>

<h4 id="evaluation-strategies">Evaluation strategies</h4>
<p>There are alternative evaluation strategies. In the above, we have chosen call by value (which is the standard in most mainstream languages), but we could also choose:</p>

<ul>
  <li><strong>Full beta-reduction</strong>: any redex may be reduced at any time. This offers no restrictions, but in practice, we go with a set of restrictions like the ones below (because coding a fixed way is easier than coding probabilistic behavior).</li>
  <li><strong>Normal order</strong>: the leftmost, outermost redex is always reduced first. This strategy allows to reduce inside unapplied lambda terms</li>
  <li><strong>Call-by-name</strong>: allows no reductions inside lambda abstractions. Arguments are not reduced before being substituted in the body of lambda terms when applied. Haskell uses an optimized version of this, call-by-need (aka lazy evaluation).</li>
</ul>

<h3 id="classical-lambda-calculus">Classical lambda calculus</h3>
<p>Classical lambda calculus allows for full beta reduction.</p>

<h4 id="confluence-in-full-beta-reduction">Confluence in full beta reduction</h4>
<p>The congruence rules allow us to apply in different ways; we can choose between $\ref{eq:e-app1}$ and $\ref{eq:e-app2}$ every time we reduce an application, and this offers many possible reduction paths.</p>

<p>While the path is non-deterministic, is the result also non-deterministic? This question took a very long time to answer, but after 25 years or so, it was proven that the result is always the same. This is known the <strong>Church-Rosser confluence theorem</strong>:</p>

<p>Let $t, t_1, t_2$ be terms such that $t \longrightarrow^* t_1$ and $t \longrightarrow^* t_2$. Then there exists a term $t_3$ such that $t_1 \longrightarrow^* t_3$ and $t_2 \longrightarrow^* t_3$</p>

<h4 id="alpha-conversion">Alpha conversion</h4>
<p>Substitution is actually trickier than it looks! For instance, in the  expression $\lambda x.\ (\lambda y.\ x)\ y$, the first occurrence of $y$ is bound (it refers to a parameter), while the second is free (it does not refer to a parameter). This is comparable to scope in most programming languages, where we should understand that these are two different variables in different scopes, $y_1$ and $y_2$.</p>

<p>The above example had a variable that is both bound and free, which is something that weâ€™ll try to avoid. This is called a hygiene condition.</p>

<p>We can transform a unhygienic expression to a hygienic one by renaming bound variables before performing the substitution. This is known as <strong>alpha conversion</strong>. Alpha conversion is given by the following conversion rule:</p>

\[\frac{y \notin \text{fv}(t)}{(\lambda x.\ t) =_\alpha (\lambda y.\ \left[ x\mapsto y\right]\ t)}
\tag{$\alpha$}
\label{eq:alpha-conv}\]

<p>And these equivalence rules (in mathematics, equivalence is defined as symmetry and transitivity):</p>

\[\begin{align}
&amp; \frac{t_1 =_\alpha t_2}{t_2 =_\alpha t_1} 
\tag{$\alpha \text{-Symm}$}
\label{eq:alpha-sym}
\\ \\

&amp; \frac{t_1 =_\alpha t_2 \quad t_2 =_\alpha t_3}{t_1 =_\alpha t_3}
\tag{$\alpha \text{-Trans}$}
\label{eq:alpha-trans}
\\
\end{align}\]

<p>The congruence rules are as usual.</p>

<h3 id="programming-in-lambda-calculus">Programming in lambda-calculus</h3>

<h4 id="multiple-arguments">Multiple arguments</h4>
<p>The way to handle multiple arguments is by currying: $\lambda x.\ \lambda y.\ t$</p>

<h4 id="booleans">Booleans</h4>
<p>The fundamental, universal operator on booleans is if-then-else, which is what weâ€™ll replicate to model booleans. Weâ€™ll denote our booleans as $\text{tru}$ and $\text{fls}$ to be able to distinguish these pure lambda-calculus abstractions from the true and false values of our previous toy language.</p>

<p>We want <code class="highlighter-rouge">true</code> to be equivalent to <code class="highlighter-rouge">if (true)</code>, and <code class="highlighter-rouge">false</code> to <code class="highlighter-rouge">if (false)</code>. The terms $\text{tru}$ and $\text{fls}$ <em>represent</em> boolean values, in that we can use them to test the truth of a boolean value:</p>

\[\begin{align}
\text{tru } &amp; = \lambda t.\ \lambda f.\ t \\
\text{fls } &amp; = \lambda t.\ \lambda f.\ f \\
\end{align}\]

<p>We can consider these as booleans. Equivalently <code class="highlighter-rouge">tru</code> can be considered as a function performing <code class="highlighter-rouge">(t1, t2) =&gt; if (true) t1 else t2</code>. To understand this, letâ€™s try to apply $\text{tru}$ to two arguments:</p>

\[\begin{align}
&amp;   &amp;&amp; \text{tru } v\ w \\
&amp; = &amp;&amp; (\lambda t.\ (\lambda f.\  t))\ v\ w \\
&amp; \longrightarrow &amp;&amp; (\lambda f.\ v)\ w \\
&amp; \longrightarrow &amp;&amp; v \\
\end{align}\]

<p>This works equivalently for <code class="highlighter-rouge">fls</code>.</p>

<p>We can also do inversion, conjunction and disjunction with lambda calculus, which can be read as particular if-else statements:</p>

\[\begin{align}
\text{not } &amp; = \lambda b.\ b\ \text{fls}\ \text{true} \\
\text{and } &amp; = \lambda b.\ \lambda c.\ b\ c\ \text{fls} \\
\text{or }  &amp; = \lambda b.\ \lambda c.\ b\ \text{tru}\ c \\
\end{align}\]

<ul>
  <li><code class="highlighter-rouge">not</code> is a function that is equivalent to <code class="highlighter-rouge">not(b) = if (b) false else true</code>.</li>
  <li><code class="highlighter-rouge">and</code> is equivalent to <code class="highlighter-rouge">and(b, c) = if (b) c else false</code></li>
  <li><code class="highlighter-rouge">or</code> is equivalent to <code class="highlighter-rouge">or(b, c) = if (b) true else c</code></li>
</ul>

<h4 id="pairs">Pairs</h4>
<p>The fundamental operations are construction <code class="highlighter-rouge">pair(a, b)</code>, and selection <code class="highlighter-rouge">pair._1</code> and <code class="highlighter-rouge">pair._2</code>.</p>

\[\begin{align}
\text{pair } &amp; = \lambda f.\ \lambda s.\ \lambda b.\ b\ f\ s\\
\text{fst }  &amp; = \lambda p.\ p\ \text{tru} \\
\text{snd }  &amp; = \lambda p.\ p\ \text{fls} \\
\end{align}\]

<ul>
  <li><code class="highlighter-rouge">pair</code> is equivalent to <code class="highlighter-rouge">pair(f, s) = (b =&gt; b f s)</code></li>
  <li>When <code class="highlighter-rouge">tru</code> is applied to <code class="highlighter-rouge">pair</code>, it selects the first element, by definition of the boolean, and that is therefore the definition of <code class="highlighter-rouge">fst</code></li>
  <li>Equivalently for <code class="highlighter-rouge">fls</code> applied to <code class="highlighter-rouge">pair</code>, it selects the second element</li>
</ul>

<h4 id="numbers">Numbers</h4>
<p>Weâ€™ve actually been representing numbers as lambda-calculus numbers all along! Our <code class="highlighter-rouge">succ</code> function represents whatâ€™s more formally called <strong>Church numerals</strong>.</p>

\[\begin{align}
c_0 &amp; = \lambda s.\ \lambda z.\ z \\
c_1 &amp; = \lambda s.\ \lambda z.\ s\ z \\
c_2 &amp; = \lambda s.\ \lambda z.\ s\ s\ z \\
c_3 &amp; = \lambda s.\ \lambda z.\ s\ s\ s\ z \\
\end{align}\]

<p>Note that $c_0$â€™s implementation is the same as that of $\text{fls}$ (just with renamed variables).</p>

<p>Every number $n$ is represented by a term $c_n$ taking two arguments, which are $s$ and $z$ (for â€œsuccessorâ€ and â€œzeroâ€), and applies $s$ to $z$, $n$ times. Fundamentally, a number is equivalent to the following:</p>

\[c_n = \lambda f.\ \lambda x.\ \underbrace{f\ \dots\ f}_{n \text{ times}}\ x\]

<p>With this in mind, let us implement some functions on numbers.</p>

\[\begin{align}
\text{scc } &amp; = \lambda n.\ \lambda s.\ \lambda z.\ s\ (n\ s\ z) \\
\text{add } &amp; = \lambda s.\ \lambda z.\ m\ s\ (n\ s\ z) \\
\text{mul } &amp; = \lambda m.\ \lambda n.\ m\ (\text{add } n)\ c_0 \\
\text{sub } &amp; = \lambda m.\ \lambda n.\ n\ \text{pred}\ m \\
\text{iszero } &amp; = \lambda m.\ m\ (\lambda x.\ \text{fls})\ \text{tru}
\end{align}\]

<ul>
  <li><strong>Successor</strong> $\text{scc}$: we apply the successor function to $n$ (which has been correctly instantiated with $s$ and $z$)</li>
  <li><strong>Addition</strong> $\text{add}$: we pass the instantiated $n$ as the zero of $m$</li>
  <li><strong>Subtraction</strong> $\text{sub}$: we apply $\text{pred}$ $n$ times to $m$</li>
  <li><strong>Multiplication</strong> $\text{mul}$: instead of the successor function, we pass the addition by $n$ function.</li>
  <li><strong>Zero test</strong> $\text{iszero}$: zero has the same implementation as false, so we can lean on that to build an iszero function. An alternative understanding is that weâ€™re building a number, in which we use true for the zero value $z$. If we have to apply the successor function $s$ once or more, we want to get false, so for the successor function we use a function ignoring its input and returning false if applied.</li>
</ul>

<p>What about predecessor? This is a little harder, and itâ€™ll take a few steps to get there. The main idea is that we find the predecessor by rebuilding the whole succession up until our number. At every step, we must generate the number and its predecessor: zero is $(c_0, c_0)$, and all other numbers are $(c_{n-1}, c_n)$. Once weâ€™ve reconstructed this pair, we can get the predecessor by taking the first element of the pair.</p>

\[\begin{align}
\text{zz} &amp; = \text{pair } c_0 \  c_0 \\
\text{ss} &amp; = \lambda p.\ \text{pair } (\text{snd } p)\ (\text{scc } (\text{snd } p)) \\
\text{prd} &amp; = \lambda m.\ \text{fst } (m\ \text{ss zz}) \\
\end{align}\]

<details><summary><p>Sidenote</p>
</summary><div class="details-content">
<p>The story goes that Church was stumped by predecessors for a long time. This solution finally came to him while he was at the barber, and he jumped out half shaven to write it down.</p>
</div></details>

<h4 id="lists">Lists</h4>
<p>Now what about lists?</p>

\[\begin{align}
\text{nil} &amp; = \lambda f.\ \lambda g.\ g \\
\text{cons} &amp; = \lambda x.\ \lambda xs.\ (\lambda f.\ \lambda g.\ f\ x\ xs) \\
\text{head} &amp; = \lambda xs.\ (\lambda y.\ \lambda ys.\  y) \\
\text{isEmpty} &amp; = \lambda xs.\ xs\ (\lambda y.\ \lambda ys.\ \text{fls}) \\
\end{align}\]

<h3 id="recursion-in-lambda-calculus">Recursion in lambda-calculus</h3>
<p>Letâ€™s start by taking a step back. We talked about normal forms and terms for which we terminate; does lambda calculus always terminate? Itâ€™s Turing complete, so it must be able to loop infinitely (otherwise, weâ€™d have solved the halting problem!).</p>

<p>The trick to recursion is self-application:</p>

\[\lambda x.\ x\ x\]

<p>From a type-level perspective, we would cringe at this. This should not be possible in the typed world, but in the untyped world we can do it. We can construct a simple infinite loop in lambda calculus as follows:</p>

\[\begin{align}
\Omega
    &amp; = &amp; (\lambda x.\ x\ x)\ (\lambda x.\ x\ x) \\
    &amp; \longrightarrow &amp; \ (\lambda x.\ x\ x)\ (\lambda x.\ x\ x)
\end{align}\]

<p>The expression evaluates to itself in one step; it never reaches a normal form, it loops infinitely, diverges. This is not a stuck term though; evaluation is always possible.</p>

<p>In fact, there are no stuck terms in pure lambda calculus. Every term is either a value or reduces further.</p>

<p>So it turns out that $\text{omega}$ isnâ€™t so terribly useful. Letâ€™s try to construct something more practical:</p>

\[Y_f = (\lambda x.\ f\ (x\ x))\ (\lambda x.\ f\ (x\ x))\]

<p>Now, the divergence is a little more interesting:</p>

\[\begin{align}
Y_f &amp; = &amp; (\lambda x.\ f\ (x\ x))\ (\lambda x.\ f\ (x\ x)) \\
&amp; \longrightarrow &amp; f\ ((\lambda x.\ f\ (x\ x))\ (\lambda x.\ f\ (x\ x))) \\
&amp; = &amp; f\ (Y_f) \\
&amp; \longrightarrow &amp; \dots \\
&amp; = &amp; f\ (f\ (Y_f)) \\
\end{align}\]

<p>This $Y_f$ function is known as a <strong>Y combinator</strong>. It still loops infinitely (though note that while it works in classical lambda calculus, it blows up in call-by-name), so letâ€™s try to build something more useful.</p>

<p>To delay the infinite recursion, we could build something like a poison pill:</p>

\[\text{poisonpill} = \lambda y.\ \text{omega}\]

<p>It can be passed around (after all, itâ€™s just a value), but evaluating it will cause our program to loop infinitely. This is the core idea weâ€™ll use for defining the <strong>fixed-point combinator</strong> $\text{fix}$ (also known as the call-by-value Y combinator), which allows us to do recursion. Itâ€™s defined as follows:</p>

\[\text{fix} = \lambda f.\ (\lambda x.\ f\ (\lambda y.\ x\ x\ y))\ (\lambda x.\ f\ (\lambda y.\ x\ x\ y))\]

<p>This looks a little intricate, and we wonâ€™t need to fully understand the definition. Whatâ€™s important is mostly how it is used to define a recursive function. For instance, if we wanted to define a modulo function in our toy language, weâ€™d do it as follows:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">mod</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=</span> 
    <span class="nf">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span>
    <span class="k">else</span> <span class="nf">mod</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In lambda calculus, weâ€™d define this as:</p>

\[\text{mod} = \text{fix } (\lambda f.\ \lambda x.\ \lambda y.\ 
    (\text{gt } y\ x)\ x\ (f (\text{sub } a\ b)\ b)
)\]

<p>Weâ€™ve assumed that a greater-than $\text{gt}$ function was available here.</p>

<p>More generally, we can define a recursive function as:</p>

\[\text{fix } \bigl(\lambda f.\ (\textit{recursion on } f)\bigr)\]

<h3 id="equivalence-of-lambda-terms">Equivalence of lambda terms</h3>
<p>Weâ€™ve seen how to define Church numerals and successor. How can we prove that $\text{succ } c_n$ is equal to $c_{n+1}$?</p>

<p>The naive approach unfortunately doesnâ€™t work; they do not evaluate to the same value.</p>

\[\begin{align*}
\text{scc } c_2 
    &amp; = (\lambda n.\ \lambda s.\ \lambda z.\  s\ (n\ s\ z))\ (\lambda s.\ \lambda z.\ s\ (s\ z)) \\
    &amp; \longrightarrow \lambda s.\ \lambda z.\ s\ ((\lambda s.\ \lambda z.\ s\ (s\ z))\ s\ z) \\
    &amp; \neq \lambda s.\ \lambda z.\ s\ (s\ (s\ z)) \\
    &amp; = c_3 \\
\end{align*}\]

<p>This still seems very close. If we could simplify a little further, we do see how they would be the same.</p>

<p>The intuition behind the Church numeral representation was that a number $n$ is represented as a term that â€œdoes something $n$ times to something elseâ€. $\text{scc}$ takes a term that â€œdoes something $n$ times to something elseâ€, and returns a term that â€œdoes something $n+1$ times to something elseâ€.</p>

<p>What we really care about is that $\text{scc } c_2$ <em>behaves</em> the same as $c_3$ when applied to two arguments. We want <em>behavioral equivalence</em>. But what does that mean? Roughly, two terms $s$ and $t$ are behaviorally equivalent if there is no â€œtestâ€ that distinguishes $s$ and $t$.</p>

<p>Letâ€™s define this notion of â€œtestâ€ this a little more precisely, and specify how weâ€™re going to observe the results of a test. We can use the notion of <strong>normalizability</strong> to define a simple notion of a test:</p>

<blockquote>
  <p>Two terms $s$ and $t$ are said to be <strong>observationally equivalent</strong> if they are either both normalizable (i.e. they reach a normal form after a finite number of evaluation steps), or both diverge.</p>
</blockquote>

<p>In other words, we observe a termâ€™s behavior by running it and seeing if it halts. Note that this is not decidable (by the halting problem).</p>

<p>For instance, $\text{omega}$ and $\text{tru}$ are not observationally equivalent (one diverges, one halts), while $\text{tru}$ and $\text{fls}$ are (they both halt).</p>

<p>Observational equivalence isnâ€™t strong enough of a test for what we need; we need behavioral equivalence.</p>

<blockquote>
  <p>Two terms $s$ and $t$ are said to be <strong>behaviorally equivalent</strong> if, for every finite sequence of values $v_1, v_2, \dots, v_n$ the applications $s\ v_1\ v_2\ \dots\ v_n$ and $t\ v_1\ v_2\ \dots\ v_n$ are observationally equivalent.</p>
</blockquote>

<p>This allows us to assert that true and false are indeed different:</p>

\[\begin{align}
\text{tru}\ x\ \Omega &amp; \longrightarrow x \\
\text{fls}\ x\ \Omega &amp; \longrightarrow \Omega \\
\end{align}\]

<p>The former returns a normal form, while the latter diverges.</p>

<h2 id="types">Types</h2>
<p>As previously, to define a language, we start with a <em>set of terms</em> and <em>values</em>, as well as an <em>evaluation relation</em>. But now, weâ€™ll also define a set of <strong>types</strong> (denoted with a first capital letter) classifying values according to their â€œshapeâ€. We can define a <em>typing relation</em> $t:\ T$. We must check that the typing relation is <em>sound</em> in the sense that:</p>

\[\frac{t: T \qquad t\longrightarrow^* v}{v: T} 
\qquad\text{and}\qquad
\frac{t: T}{\exists t' \text{ such that } t\longrightarrow t'}\]

<p>These rules represent some kind of safety and liveness, but are more commonly referred to as <a href="#properties-of-the-typing-relation">progress and preservation</a>, which weâ€™ll talk about later. The first one states that types are preserved throughout evaluation, while the second says that if we can type-check, then evaluation of $t$ will not get stuck.</p>

<p>In our previous toy language, we can introduce two types, booleans and numbers:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>T ::=     // types
    Bool     // type of booleans
    Nat      // type of numbers
</pre></td></tr></tbody></table></code></pre></figure>

<p>Our typing rules are then given by:</p>

\[\begin{align}
\text{true } : \text{ Bool} 
\tag{T-True} \label{eq:t-true} \\ \\

\text{false } : \text{ Bool} 
\tag{T-False} \label{eq:t-false} \\ \\

0: \text{ Nat} 
\tag{T-Zero} \label{eq:t-zero} \\ \\

\frac{t_1: \text{Bool} \quad t_2 : T \quad t_3: T}{\ifelse}
\tag{T-If} \label{eq:t-if} \\ \\

\frac{t_1: \text{Nat}}{\text{succ } t_1: \text{Nat}}
\tag{T-Succ} \label{eq:t-succ} \\ \\

\frac{t_1: \text{Nat}}{\text{pred } t_1: \text{Nat}}
\tag{T-Pred} \label{eq:t-pred} \\ \\

\frac{t_1: \text{Nat}}{\text{iszero } t_1: \text{Nat}}
\tag{T-IsZero} \label{eq:t-iszero} \\ \\
\end{align}\]

<p>With these typing rules in place, we can construct typing derivations to justify every pair $t: T$ (which we can also denote as a $(t, T)$ pair) in the typing relation, as we have done previously with evaluation. Proofs of properties about the typing relation often proceed by induction on these typing derivations.</p>

<p>Like other static program analyses, type systems are generally imprecise. They do not always predict exactly what kind of value will be returned, but simply a conservative approximation. For instance, <code class="highlighter-rouge">if true then 0 else false</code> cannot be typed with the above rules, even though it will certainly evaluate to a number. We could of course add a typing rule for <code class="highlighter-rouge">if true</code> statements, but there is still a question of how useful this is, and how much complexity it adds to the type system, and especially for proofs. Indeed, the inversion lemma below becomes much more tedious when we have more rules.</p>

<h3 id="properties-of-the-typing-relation">Properties of the Typing Relation</h3>
<p>The safety (or soundness) of this type system can be expressed by the following two properties:</p>

<ul>
  <li>
    <p><strong>Progress</strong>: A well-typed term is not stuck.</p>

    <p>If $t\ :\ T$ then either $t$ is a value, or else $t\longrightarrow tâ€™$ for some $tâ€™$.</p>
  </li>
  <li>
    <p><strong>Preservation</strong>: Types are preserved by one-step evaluation.</p>

    <p>If $t\ :\ T$ and $t\longrightarrow tâ€™$, then $tâ€™\ :\ T$.</p>
  </li>
</ul>

<p>We will prove these later, but first we must state a few lemmas.</p>

<h4 id="inversion-lemma-1">Inversion lemma</h4>
<p>Again, for types we need to state the same (boring) inversion lemma:</p>

<ol>
  <li>If $\text{true}: R$, then $R = \text{Bool}$.</li>
  <li>If $\text{false}: R$, then $R = \text{Bool}$.</li>
  <li>If $\ifelse: R$, then $t_1: \text{ Bool}$, $t_2: R$ and $t_3: R$</li>
  <li>If $0: R$ then $R = \text{Nat}$</li>
  <li>If $\text{succ } t_1: R$ then $R = \text{Nat}$ and $t_1: \text{Nat}$</li>
  <li>If $\text{pred } t_1: R$ then $R = \text{Nat}$ and $t_1: \text{Nat}$</li>
  <li>If $\text{iszero } t_1: R$ then $R = \text{Bool}$ and $t_1: \text{Nat}$</li>
</ol>

<p>From the inversion lemma, we can directly derive a typechecking algorithm:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">typeof</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">True</span> <span class="o">|</span> <span class="nc">False</span> <span class="k">=&gt;</span> <span class="nc">Bool</span>
    <span class="k">case</span> <span class="nc">If</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">,</span> <span class="n">t3</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="nv">type1</span> <span class="k">=</span> <span class="nf">typeof</span><span class="o">(</span><span class="n">t1</span><span class="o">)</span>
        <span class="k">val</span> <span class="nv">type2</span> <span class="k">=</span> <span class="nf">typeof</span><span class="o">(</span><span class="n">t2</span><span class="o">)</span>
        <span class="k">val</span> <span class="nv">type3</span> <span class="k">=</span> <span class="nf">typeof</span><span class="o">(</span><span class="n">t3</span><span class="o">)</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">type1</span> <span class="o">==</span> <span class="nc">Bool</span> <span class="o">&amp;&amp;</span> <span class="n">type2</span> <span class="o">==</span> <span class="n">type3</span><span class="o">)</span> <span class="n">type2</span>
        <span class="k">else</span> <span class="k">throw</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"not typable"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Zero</span> <span class="k">=&gt;</span> <span class="nc">Nat</span>
    <span class="k">case</span> <span class="nc">Succ</span><span class="o">(</span><span class="n">t1</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="nf">if</span> <span class="o">(</span><span class="nf">typeof</span><span class="o">(</span><span class="n">t1</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Nat</span><span class="o">)</span> <span class="nc">Nat</span>
        <span class="k">else</span> <span class="k">throw</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"not typable"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Pred</span><span class="o">(</span><span class="n">t1</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="nf">if</span> <span class="o">(</span><span class="nf">typeof</span><span class="o">(</span><span class="n">t1</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Nat</span><span class="o">)</span> <span class="nc">Nat</span>
        <span class="k">else</span> <span class="k">throw</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"not typable"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">IsZero</span><span class="o">(</span><span class="n">t1</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="nf">if</span> <span class="o">(</span><span class="nf">typeof</span><span class="o">(</span><span class="n">t1</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Nat</span><span class="o">)</span> <span class="nc">Bool</span>
        <span class="k">else</span> <span class="k">throw</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"not typable"</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="canonical-form">Canonical form</h4>
<p>A simple lemma that will be useful for lemma is that of canonical forms. Given a type, it tells us what kind of values we can expect:</p>

<ol>
  <li>If $v$ is a value of type Bool, then $v$ is either $\text{true}$ or $\text{false}$</li>
  <li>If $v$ is a value of type Nat, then $v$ is a numeric value</li>
</ol>

<p>The proof is somewhat immediate from the syntax of values.</p>

<h4 id="progress-theorem">Progress Theorem</h4>
<p><strong>Theorem</strong>: suppose that $t$ is a well-typed term of type $T$. Then either $t$ is a value, or else there exists some $tâ€™$ such that $t\longrightarrow tâ€™$.</p>

<p><strong>Proof</strong>: by induction on a derivation of $t: T$.</p>

<ul>
  <li>The $\ref{eq:t-true}$, $\ref{eq:t-false}$ and $\ref{eq:t-zero}$ are immediate, since $t$ is a value in these cases.</li>
  <li>
    <p>For $\ref{eq:t-if}$, we have $t=\ifelse$, with $t_1: \text{Bool}$, $t_2: T$ and $t_3: T$. By the induction hypothesis, there is some $t_1â€™$ such that $t_1 \longrightarrow t_1â€™$.</p>

    <p>If $t_1$ is a value, then rule 1 of the <a href="#canonical-form">canonical form lemma</a> tells us that $t_1$ must be either $\text{true}$ or $\text{false}$, in which case $\ref{eq:e-iftrue}$ or $\ref{eq:e-iffalse}$ applies to $t$.</p>

    <p>Otherwise, if $t_1 \longrightarrow t_1â€™$, then by $\ref{eq:e-if}$, $t\longrightarrow \if t_1â€™ \then t_2 \text{ else } t_3$</p>
  </li>
  <li>
    <p>For $\ref{eq:t-succ}$, we have $t = \text{succ } t_1$.</p>

    <p>$t_1$ is a value, by rule 5 of the <a href="#inversion-lemma">inversion lemma</a> and by rule 2 of the <a href="#canonical-form">canonical form</a>, $t_1 = nv$ for some numeric value $nv$. Therefore, $\text{succ }(t_1)$ is a value. If $t_1 \longrightarrow t_1â€™$, then $t\longrightarrow \text{succ }t_1$.</p>
  </li>
  <li>The cases for $\ref{eq:t-zero}$, $\ref{eq:t-pred}$ and $\ref{eq:t-iszero}$ are similar.</li>
</ul>

<h4 id="preservation-theorem">Preservation Theorem</h4>
<p><strong>Theorem</strong>: Types are preserved by one-step evaluation. If $t: T$ and $t\longrightarrow tâ€™$, then $tâ€™: T$.</p>

<p><strong>Proof</strong>: by induction on the given typing derivation</p>

<ul>
  <li>For $\ref{eq:t-true}$ and $\ref{eq:t-false}$, the precondition doesnâ€™t hold (no reduction is possible), so itâ€™s trivially true. Indeed, $t$ is already a value, either $t=\text{ true}$ or $t=\text{ false}$.</li>
  <li>For $\ref{eq:t-if}$, there are three evaluation rules by which $t\longrightarrow tâ€™$ can be derived, depending on $t_1$
    <ul>
      <li>If $t_1 = \text{true}$, then by $\ref{eq:e-iftrue}$ we have $tâ€™=t_2$, and from rule 3 of the <a href="#inversion-lemma-1">inversion lemma</a> and the assumption that $t: T$, we have $t_2: T$, that is $tâ€™: T$</li>
      <li>If $t_1 = \text{false}$, then by $\ref{eq:e-iffalse}$ we have $tâ€™=t_3$, and from rule 3 of the <a href="#inversion-lemma-1">inversion lemma</a> and the assumption that $t: T$, we have $t_3: T$, that is $tâ€™: T$</li>
      <li>If $t_1 \longrightarrow t_1â€™$, then by the induction hypothesis, $t_1â€™: \text{Bool}$. Combining this with the assumption that $t_2: T$ and $t_3: T$, we can apply $\ref{eq:t-if}$ to conclude $\if t_1â€™ \then t_2 \else t_3: T$, that is $tâ€™: T$</li>
    </ul>
  </li>
</ul>

<h3 id="messing-with-it">Messing with it</h3>
<h4 id="removing-a-rule">Removing a rule</h4>
<p>What if we remove $\ref{eq:e-predzero}$? Then <code class="highlighter-rouge">pred 0</code> type checks, but it is stuck and is not a value; the <a href="#progress-theorem">progress theorem</a> fails.</p>

<h4 id="changing-type-checking-rule">Changing type-checking rule</h4>
<p>What if we change the $\ref{eq:t-if}$ to the following?</p>

\[\frac{
    t_1 : \text{Bool} \quad
    t_2 : \text{Nat} \quad 
    t_3 : \text{Nat}
}{
    (\ifelse) : \text{Nat}
}
\tag{T-If 2}
\label{eq:t-if2}\]

<p>This doesnâ€™t break our type system. Itâ€™s still sound, but it rejects if-else expressions that return other things than numbers (e.g. booleans). But that is an expressiveness problem, not a soundness problem; our type system disallows things that would otherwise be fine by the evaluation rules.</p>

<h4 id="adding-bit">Adding bit</h4>
<p>We could add a boolean to natural function <code class="highlighter-rouge">bit(t)</code>. Weâ€™d have to add it to the grammar, add some evaluation and typing rules, and prove progress and preservation.</p>

\[\begin{align}
\text{bit true} \longrightarrow 0 \\ \\
\text{bit false} \longrightarrow 1 \\ \\

\frac{t_1 \longrightarrow t_1'}{\text{bit }t_1 \longrightarrow \text{bit }t_1'}
\\ \\
\frac{t : \text{Bool}}{\text{bit } t : \text{Nat}}
\end{align}\]

<p>Weâ€™ll do something similar this below, so the full proof is omitted.</p>

<h2 id="simply-typed-lambda-calculus">Simply typed lambda calculus</h2>
<p>Simply Typed Lambda Calculus (STLC) is also denoted $\lambda_\rightarrow$. The â€œpureâ€ form of STLC is not very interesting on the type-level (unlike for the term-level of pure lambda calculus), so weâ€™ll allow base values that are not functions, like booleans and integers. To talk about STLC, we always begin with some set of â€œbase typesâ€:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>T ::=     // types
    Bool    // type of booleans
    T -&gt; T  // type of functions
</pre></td></tr></tbody></table></code></pre></figure>

<p>In the following examples, weâ€™ll work with a mix of our previously defined toy language, and lambda calculus. This will give us a little syntactic sugar.</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>t ::=                // terms
    x                   // variable
    Î»x. t               // abstraction
    t t                 // application
    true                // constant true
    false               // constant false
    if t then t else t  // conditional

v ::=   // values
    Î»x. t  // abstraction value
    true   // true value
    false  // false value
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="type-annotations">Type annotations</h3>
<p>We will annotate lambda-abstractions with the expected type of the argument, as follows:</p>

\[\lambda x: T_1 .\ t_1\]

<p>We could also omit it, and let type inference do the job (as in OCaml), but for now, weâ€™ll do the above. This will make it simpler, as we wonâ€™t have to discuss inference just yet.</p>

<h3 id="typing-rules">Typing rules</h3>
<p>In STLC, weâ€™ve introduced abstraction. To add a typing rule for that, we need to encode the concept of an environment $\Gamma$, which is a set of variable assignments. We also introduce the â€œturnstileâ€ symbol $\vdash$, meaning that the environment can verify the right hand-side typing, or that $\Gamma$ must imply the right-hand side.</p>

\[\begin{align}

\frac{
    \bigl( \Gamma \cup (x_1 : T_1) \bigr) \vdash  t_2 : T_2
}{ \Gamma\vdash(\lambda x: T_1.\ t_2): T_1 \rightarrow T_2 }
\tag{T-Abs} \label{eq:t-abs} \\ \\

\frac{x: T \in \Gamma}{\Gamma\vdash x: T}
\tag{T-Var} \label{eq:t-var} \\ \\

\frac{
    \Gamma\vdash t_1 : T_{11}\rightarrow T_{12}
    \quad
    \Gamma\vdash t_2 : T_{11}
}{\Gamma\vdash t_1\ t_2 : T_{12}}
\tag{T-App} \label{eq:t-app} 

\end{align}\]

<p>This additional concept must be taken into account in our definition of progress and preservation:</p>

<ul>
  <li><strong>Progress</strong>: If $\Gamma\vdash t : T$, then either $t$ is a value or else $t\longrightarrow tâ€™$ for some $tâ€™$</li>
  <li><strong>Preservation</strong>: If $\Gamma\vdash t : T$ and $t\longrightarrow tâ€™$, then $\Gamma\vdash tâ€™ : T$</li>
</ul>

<p>To prove these, we must take the same steps as above. Weâ€™ll introduce the inversion lemma for typing relations, and restate the canonical forms lemma in order to prove the progress theorem.</p>

<h3 id="inversion-lemma-2">Inversion lemma</h3>
<p>Letâ€™s start with the inversion lemma.</p>

<ol>
  <li>If $\Gamma\vdash\text{true} : R$ then $R = \text{Bool}$</li>
  <li>If $\Gamma\vdash\text{false} : R$ then $R = \text{Bool}$</li>
  <li>If $\Gamma\vdash\ifelse : R$ then $\Gamma\vdash t_1 : \text{Bool}$ and $\Gamma\vdash t_2, t_3: R$.</li>
  <li>If $\Gamma\vdash x: R$ then $x: R \in\Gamma$</li>
  <li>If $\Gamma\vdash\lambda x: T_1 .\ t_2 : R$ then $R = T_1 \rightarrow T_2$ for some $R_2$ with $\Gamma\cup(x: T_1)\vdash t_2: R_2$</li>
  <li>If $\Gamma\vdash t_1\ t_2 : R$ then there is some type $T_{11}$ such that $\Gamma\vdash t_1 : T_{11} \rightarrow R$ and $\Gamma\vdash t_2 : T_{11}$.</li>
</ol>

<h3 id="canonical-form-1">Canonical form</h3>
<p>The canonical forms are given as follows:</p>

<ol>
  <li>If $v$ is a value of type Bool, then it is either $\text{true}$ or $\text{false}$</li>
  <li>If $v$ is a value of type $T_1 \rightarrow T_2$ then $v$ has the form $\lambda x: T_1 .\ t_2$</li>
</ol>

<h3 id="progress">Progress</h3>
<p>Finally, we get to prove the progress by induction on typing derivations.</p>

<p><strong>Theorem</strong>: Suppose that $t$ is a closed, well typed term (that is, $\Gamma\vdash t: T$ for some type $T$). Then either $t$ is a value, or there is some $tâ€™$ such that $t\longrightarrow tâ€™$.</p>

<ul>
  <li>For boolean constants, the proof is immediate as $t$ is a value</li>
  <li>For variables,  the proof is immediate as $t$ is closed, and the precondition therefore doesnâ€™t hold</li>
  <li>For abstraction, the proof is immediate as $t$ is a value</li>
  <li>
    <p>Application is the only case we must treat.</p>

    <p>Consider $t = t_1\ t_2$, with $\Gamma\vdash t_1: T_{11} \rightarrow T_{12}$ and $\Gamma\vdash t_2: T_{11}$.</p>

    <p>By the induction hypothesis, $t_1$ is either a value, or it can make a step of evaluation. The same goes for $t_2$.</p>

    <p>If $t_1$ can reduce, then rule $\ref{eq:e-app1}$ applies to $t$. Otherwise, if it is a value, and $t_2$ can take a step, then $\ref{eq:e-app2}$ applies. Otherwise, if they are both values (and we cannot apply $\beta$-reduction), then the canonical forms lemma above tells us that $t_1$ has the form $\lambda x: T_11.\ t_{12}$, and so rule $\ref{eq:e-appabs}$ applies to $t$.</p>
  </li>
</ul>

<h3 id="preservation">Preservation</h3>
<p><strong>Theorem</strong>: If $\Gamma\vdash t: T$ and $t \longrightarrow tâ€™$ then $\Gamma\vdash tâ€™: T$.</p>

<p><strong>Proof</strong>: by induction on typing derivations. We proceed on a case-by-case basis, as we have done so many times before. But one case is hard: application.</p>

<p>For $t = t_1\ t_2$, such that $\Gamma\vdash t_1 : T_{11} \rightarrow T_{12}$ and $\Gamma\vdash t_2 : T_{11}$, and where $T=T_{12}$, we want to show $\Gamma\vdash tâ€™ : T_{12}$.</p>

<p>To do this, we must use the <a href="#inversion-lemma">inversion lemma for evaluation</a> (note that we havenâ€™t written it down for STLC, but the idea is the same). There are three subcases for it, starting with the following:</p>

<p>The left-hand side is $t_1 = \lambda x: T_{11}.\ t_{12}$, and the right-hand side of application $t_2$ is a value $v_2$. In this case, we know that the result of the evaluation is given by $tâ€™ = \left[ x\mapsto v_2 \right] t_{12}$.</p>

<p>And here, we already run into trouble, because we do not know about how types act under substitution. We will therefore need to introduce some lemmas.</p>

<h4 id="weakening-lemma">Weakening lemma</h4>
<p>Weakening tells us that we can <em>add</em> assumptions to the context without losing any true typing statements:</p>

<p>If $\Gamma\vdash t: T$, and the environment $\Gamma$ has no information about $x$â€”that is, $x\notin \text{dom}(\Gamma)$â€”then the initial assumption still holds if we add information about $x$ to the environment:</p>

\[\bigl(\Gamma \cup (x: S)\bigr)\vdash t: T\]

<p>Moreover, the latter $\vdash$ derivation has the same depth as the former.</p>

<h4 id="permutation-lemma">Permutation lemma</h4>
<p>Permutation tells us that the order of assumptions in $\Gamma$ does not matter.</p>

<p>If $\Gamma \vdash t: T$ and $\Delta$ is a permutation of $\Gamma$, then $\Delta\vdash t: T$.</p>

<p>Moreover, the latter $\vdash$ derivation has the same depth as the former.</p>

<h4 id="substitution-lemma">Substitution lemma</h4>
<p>Substitution tells us that types are preserved under substitution.</p>

<p>That is, if $\Gamma\cup(x: S) \vdash t: T$ and $\Gamma\vdash s: S$, then $\Gamma\vdash \left[x\mapsto s\right] t: T$.</p>

<p>The proof goes by induction on the derivation of $\Gamma\cup(x: S) \vdash t: T$, that is, by cases on the final typing rule used in the derivation.</p>

<ul>
  <li>
    <p>Case $\ref{eq:t-app}$: in this case, $t = t_1\ t_2$.</p>

    <p>Thanks to typechecking, we know that the environment validates $\bigl(\Gamma\cup (x: S)\bigr)\vdash t_1: T_2 \rightarrow T_1$ and $\bigl(\Gamma\cup (x: S)\bigr)\vdash t_2: T_2$. In this case, the resulting type of the application is $T=T_1$.</p>

    <p>By the induction hypothesis, $\Gamma\vdash[x\mapsto s]t_1 : T_2 \rightarrow T_1$, and $\Gamma\vdash[x\mapsto s]t_2 : T_2$.</p>

    <p>By $\ref{eq:t-app}$, the environment then also verifies the application of these two substitutions as $T$: $\Gamma\vdash[x\mapsto s]t_1\ [x\mapsto s]t_2: T$. We can factorize the substitution to obtain the conclusion, i.e. $\Gamma\vdash \left[x\mapsto s\right](t_1\ t_2): T$</p>
  </li>
  <li>Case $\ref{eq:t-var}$: if $t=z$ ($t$ is a simple variable $z$) where $z: T \in \bigl(\Gamma\cup (x: S)\bigr)$. There are two subcases to consider here, depending on whether $z$ is $x$ or another variable:
    <ul>
      <li>If $z=x$, then $\left[x\mapsto s\right] z = s$. The result is then $\Gamma\vdash s: S$, which is among the assumptions of the lemma</li>
      <li>If $z\ne x$, then $\left[x\mapsto s\right] z = z$, and the desired result is immediate</li>
    </ul>
  </li>
  <li>
    <p>Case $\ref{eq:t-abs}$: if $t=\lambda y: T_2.\ t_1$, with $T=T_2\rightarrow T_1$, and $\bigl(\Gamma\cup (x: S)\cup (y: T_2)\bigr)\vdash t_1 : T_1$.</p>

    <p>Based on our <a href="#alpha-conversion">hygiene convention</a>, we may assume $x\ne y$ and $y \notin \text{fv}(s)$.</p>

    <p>Using <a href="#permutation-lemma">permutation</a> on the first given subderivation in the lemma ($\Gamma\cup(x: S) \vdash t: T$), we obtain $\bigl(\Gamma\cup (y: T_2)\cup (x: S)\bigr)\vdash t_1 : T_1$ (we have simply changed the order of $x$ and $y$).</p>

    <p>Using <a href="#weakening-lemma">weakening</a> on the other given derivation in the lemma ($\Gamma\vdash s: S$), we obtain $\bigl(\Gamma\cup (y: T_2)\bigr)\vdash s: S$.</p>

    <p>By the induction hypothesis, $\bigl(\Gamma\cup (y: T_2)\bigr)\vdash\left[x\mapsto s\right] t_1: T_1$.</p>

    <p>By $\ref{eq:t-abs}$, we have $\Gamma\vdash(\lambda y: T_2.\ [x\mapsto s]t_1): T_1$</p>

    <p>By the definition of substitution, this is $\Gamma\vdash([x\mapsto s]\lambda y: T_2.\ t_1): T_2 \rightarrow T_1$.</p>
  </li>
</ul>

<h4 id="proof">Proof</h4>
<p>Weâ€™ve now proven the following lemmas:</p>

<ul>
  <li>Weakening</li>
  <li>Permutation</li>
  <li>Type preservation under substitution</li>
  <li>Type preservation under reduction (i.e. preservation)</li>
</ul>

<p>We wonâ€™t actually do the proof, weâ€™ve just set up the pieces we need for it.</p>

<h3 id="erasure">Erasure</h3>
<p>Type annotations do not play any role in evaluation. In STLC, we donâ€™t do any run-time checks, we only run compile-time type checks. Therefore, types can be removed before evaluation. This often happens in practice, where types do not appear in the compiled form of a program; theyâ€™re typically encoded in an untyped fashion. The semantics of this conversion can be formalized by an erasure function:</p>

\[\begin{align}
\text{erase}(x) &amp; = x \\
\text{erase}(\lambda x: T_1. t_2) &amp; = \lambda x. \text{erase}(t_2) \\
\text{erase}(t_1\ t_2) &amp; = \text{erase}(t_1)\ \text{erase}(t_2)
\end{align}\]

<h3 id="curry-howard-correspondence">Curry-Howard Correspondence</h3>
<p>The Curry-Howard correspondence tells us that there is a correspondence between constructive logic and typed lambda-calculus with product and sum types.</p>

<p>An implication $P\supset Q$ (which could also be written $P\implies Q$) can be proven by transforming evidence for $P$ into evidence for $Q$. A conjunction $P\land Q$ is a <a href="#pairs-1">pair</a> of evidence for $P$ and evidence for $Q$. For more examples of these correspondences, see the <a href="https://en.wikipedia.org/wiki/Brouwerâ€“Heytingâ€“Kolmogorov_interpretation">Brouwerâ€“Heytingâ€“Kolmogorov (BHK) interpretation</a> or <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard correspondence</a> on Wikipedia.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Logic</th>
      <th style="text-align: left">Programming languages</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Propositions</td>
      <td style="text-align: left">Types</td>
    </tr>
    <tr>
      <td style="text-align: left">$P \supset Q$ or $P \implies Q$</td>
      <td style="text-align: left">Function type $P\rightarrow Q$</td>
    </tr>
    <tr>
      <td style="text-align: left">$P \land Q$</td>
      <td style="text-align: left"><a href="#pairs-1">Pair type</a> $P\times Q$</td>
    </tr>
    <tr>
      <td style="text-align: left">$P \lor Q$</td>
      <td style="text-align: left"><a href="#sum-type">Sum type</a> $P+Q$</td>
    </tr>
    <tr>
      <td style="text-align: left">$\exists x\in S: \phi(x)$</td>
      <td style="text-align: left">Dependent type $\sum{x: S, \phi(x)}$</td>
    </tr>
    <tr>
      <td style="text-align: left">$\forall x\in S: \phi(x)$</td>
      <td style="text-align: left">$\forall (x:S): \phi(x)$</td>
    </tr>
    <tr>
      <td style="text-align: left">Proof of $P$</td>
      <td style="text-align: left">Term $t$ of type $P$</td>
    </tr>
    <tr>
      <td style="text-align: left">$P$ is provable</td>
      <td style="text-align: left">Type $P$ is inhabited</td>
    </tr>
    <tr>
      <td style="text-align: left">Proof simplification</td>
      <td style="text-align: left">Evaluation</td>
    </tr>
  </tbody>
</table>

<p>In Scala, all types are inhabited except for the bottom type <code class="highlighter-rouge">Nothing</code>. Singleton types are only inhabited by a single term.</p>

<p>As an example of the equivalence, weâ€™ll see that application is equivalent to <a href="https://en.wikipedia.org/wiki/Modus_ponens">modus ponens</a>:</p>

\[\frac{\Gamma\vdash t_1 : P \supset Q \quad \Gamma\vdash t_2 : P}{\Gamma\vdash t_1\ t_2 : Q}\]

<p>This also tells us that if we can prove something, we can evaluate it.</p>

<p>How can we prove the following? Remember that $\rightarrow$ is right-associative.</p>

\[(A \land B) \rightarrow C \rightarrow ((C\land A)\land B)\]

<p>The proof is actually a somewhat straightforward conversion to lambda calculus:</p>

\[\lambda p: A\times B.\ \lambda c: C.\ \text{pair} (\text{pair} (c\ \text{fst}(p))\ \text{snd}(p))\]

<h3 id="extensions-to-stlc">Extensions to STLC</h3>

<h4 id="base-types">Base types</h4>
<p>Up until now, weâ€™ve defined our base types (such as $\text{Nat}$ and $\text{Bool}$) manually: weâ€™ve added them to the syntax of types, with associated constants ($\text{zero}, \text{true}, \text{false}$) and operators ($\text{succ}, \text{pred}$), as well as associated typing and evaluation rules.</p>

<p>This is a lot of minutiae though, especially for theoretical discussions. For those, we can often ignore the term-level inhabitants of the base types, and just treat them as uninterpreted constants: we donâ€™t really need the distinction between constants and values. For theory, we can just assume that some generic base types (e.g. $B$ and $C$) exist, without defining them further.</p>

<h4 id="unit-type">Unit type</h4>
<p>In C-like languages, this type is usually called <code class="highlighter-rouge">void</code>. To introduce it, we do not add any computation rules. We must only add it to the grammar, values and types, and then add a single typing rule that trivially verifies units.</p>

\[\Gamma\vdash\text{unit}:\text{Unit}
\label{eq:t-unit} \tag{T-Unit}\]

<p>Units are not too interesting, but <em>are</em> quite useful in practice, in part because they allow for other extensions.</p>

<h4 id="sequencing">Sequencing</h4>
<p>We can define sequencing as two statements following each other:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>t ::=
    ...
    t1; t2
</pre></td></tr></tbody></table></code></pre></figure>

<p>This implies adding some evaluation and typing rules, defined below:</p>

\[\begin{align}
\frac{t_1 \longrightarrow t_1'}{t_1;\ t_2 \longrightarrow t_1';\ t_2}
\label{eq:e-seq}\tag{E-Seq} \\ \\

(\text{unit};\ t_2) \longrightarrow t_2
\label{eq:e-seqnext}\tag{E-SeqNext} \\ \\

\frac{\Gamma\vdash t_1 : \text{Unit} \quad \Gamma\vdash t_2: T_2}{\Gamma\vdash t_1;\ t_2 : T_2}
\label{eq:t-seq}\tag{T-Seq} \\
\end{align}\]

<p>But thereâ€™s another way that we could define sequencing: simply as syntactic sugar, a derived form for something else. In this way, we define an external language, that is transformed to an internal language by the compiler in the desugaring step.</p>

\[t_1;\ t_2 \defeq (\lambda x: \text{Unit}.\ t_2)\ t_1
\qquad \text{where } x\notin\text{ FV}(t_2)\]

<p>This is useful to know, because it makes proving soundness much easier. We do not need to re-state the inversion lemma, re-prove preservation and progress. We can simple rely on the proof for the underlying internal language.</p>

<h4 id="ascription">Ascription</h4>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>t ::=
    ...
    t as T
</pre></td></tr></tbody></table></code></pre></figure>

<p>Ascription allows us to have a compiler type-check a term as really being of the correct type:</p>

\[\frac{\Gamma\vdash t_1 : T}{\Gamma\vdash t_1 \text{ as } T: T}
\label{eq:t-ascribe}\tag{T-Ascribe}\]

<p>This seems like it preserves soundness, but instead of doing the whole proof over again, weâ€™ll just propose a simple desugaring, in which an ascription is equivalent to the term $t$ applied the identity function, typed to return $T$:</p>

\[t \text{ as } T \defeq (\lambda x: T.\ x)\ t\]

<p>Alternatively, we could do the whole proof over again, and institute a simple evaluation rule that ignores the ascription.</p>

\[v_1 \text{ as } T \longrightarrow v_1
\label{eq:e-ascribe}\tag{E-Ascribe} \\\]

<h4 id="pairs-1">Pairs</h4>
<p>We can introduce pairs into our grammar.</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>t ::= 
    ...
    {t, t}    // pair
    t.1       // first projection
    t.2       // second projection

v ::=
    ...
    {v, v}    // pair value

T ::=
    ...
    T1 x T2   // product types
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that product types are right-associative: $A \times B \times C = A \times (B \times C)$. We can also introduce evaluation rules for pairs:</p>

\[\begin{align}
\set{v_1, v_2}.1 \longrightarrow v_1
\tag{E-PairBeta1}\label{eq:e-pairbeta1} \\ \\

\set{v_1, v_2}.2 \longrightarrow v_2
\tag{E-PairBeta2}\label{eq:e-pairbeta2} \\ \\

\frac{t_1 \longrightarrow t_1'}{t_1.1\longrightarrow t_1'.1}
\tag{E-Proj1}\label{eq:e-proj1} \\ \\

\frac{t_1 \longrightarrow t_1'}{t_1.2\longrightarrow t_1'.2}
\tag{E-Proj2}\label{eq:e-proj2} \\ \\

\frac{t_1 \longrightarrow t_1'}{\set{t_1, t_2} \longrightarrow \set{t_1', t_2}}
\tag{E-Pair1}\label{eq:e-pair1} \\ \\

\frac{t_2 \longrightarrow t_2'}{\set{t_1, t_2} \longrightarrow \set{t_1, t_2'}}
\tag{E-Pair2}\label{eq:e-pair2} \\ \\
\end{align}\]

<p>The typing rules are then:</p>

\[\begin{align}
\frac{
    \Gamma\vdash t_1: T_1 \quad \Gamma\vdash t_2: T_2
}{
    \Gamma\vdash \set{t_1, t_2} : T_1 \times T_2
} \label{eq:t-pair} \tag{T-Pair} \\ \\

\frac{\Gamma\vdash t_1 : T_{11}\times T_{12}}{\Gamma\vdash t_1.1:T_{11}}
\label{eq:t-proj1}\tag{T-Proj1} \\ \\

\frac{\Gamma\vdash t_1 : T_{11}\times T_{12}}{\Gamma\vdash t_1.2:T_{12}}
\label{eq:t-proj2}\tag{T-Proj2} \\ \\
\end{align}\]

<p>Pairs have to be added â€œthe hard wayâ€: we do not really have a way to define them in a derived form, as we have no existing language features to piggyback onto.</p>

<h4 id="tuples">Tuples</h4>
<p>Tuples are like pairs, except that we do not restrict it to 2 elements; we allow an arbitrary number from 1 to n. We can use pairs to encode tuples: <code class="highlighter-rouge">(a, b, c)</code> can be encoded as <code class="highlighter-rouge">(a, (b, c))</code>. Though for performance and convenience, most languages implement them natively.</p>

<h4 id="records">Records</h4>
<p>We can easily generalize tuples to records by annotating each field with a label. A record is a bundle of values with labels; itâ€™s a map of labels to values and types. Order of records doesnâ€™t matter, the only index is the label.</p>

<p>If we allow numeric labels, then we can encode a tuple as a record, where the index implicitly encodes the numeric label of the record representation.</p>

<p>No mainstream language has language-level support for records (two case classes in Scala may have the same arguments but a different constructor, so itâ€™s not quite the same; records are more like anonymous objects). This is because theyâ€™re often quite inefficient in practice, but weâ€™ll still use them as a theoretical abstraction.</p>

<h3 id="sums-and-variants">Sums and variants</h3>

<h4 id="sum-type">Sum type</h4>
<p>A sum type $T = T_1 + T_2$ is a <em>disjoint</em> union of $T_1$ and $T_2$. Pragmatically, we can have sum types in Scala with case classes extending an abstract object:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Some</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">None</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In this example, <code class="highlighter-rouge">Option = Some + None</code>. We say that $T_1$ is on the left, and $T_2$ on the right. Disjointness is ensured by the tags $\text{inl}$ and $\text{inr}$. We can <em>think</em> of these as functions that inject into the left or right of the sum type $T$:</p>

\[\text{inl}: T_1 \rightarrow T_1 + T_2 \\
\text{inr}: T_2 \rightarrow T_1 + T_2\]

<p>Still, these arenâ€™t really functions, they donâ€™t actually have function type. Instead, we use them them to tag the left and right side of a sum type, respectively.</p>

<p>Another way to think of these stems from  <a href="#curry-howard-correspondence">Curry-Howard correspondence</a>. Recall that in the <a href="https://en.wikipedia.org/wiki/Brouwer%E2%80%93Heyting%E2%80%93Kolmogorov_interpretation">BHK interpretation</a>, a proof of $P \lor Q$ is a pair <code class="highlighter-rouge">&lt;a, b&gt;</code> where <code class="highlighter-rouge">a</code> is 0 (also denoted $\text{inl}$) and <code class="highlighter-rouge">b</code> a proof of $P$, <em>or</em> <code class="highlighter-rouge">a</code> is 1 (also denoted $\text{inr}$) and <code class="highlighter-rouge">b</code> is a proof of $Q$.</p>

<p>To use elements of a sum type, we can introduce a <code class="highlighter-rouge">case</code> construct that allows us to pattern-match on a sum type, allowing us to distinguishing the left type from the right one.</p>

<p>We need to introduce these three special forms in our syntax:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>t ::= ...                           // terms
    inl t                              // tagging (left)
    inr t                              // tagging (right)
    case t of inl x =&gt; t | inr x =&gt; t  // case

v ::= ... // values
    inl v   // tagged value (left)
    inr v   // tagged value (right)

T ::= ...  // types
    T + T     // sum type
</pre></td></tr></tbody></table></code></pre></figure>

<p>This also leads us to introduce some new evaluation rules:</p>

\[\begin{align}
    \begin{rcases}
        \text{case } (&amp; \text{inl } v_0) \text{ of} \\
                      &amp; \text{inl } x_1 \Rightarrow t_1 \ \mid \\
                      &amp; \text{inr } x_2 \Rightarrow t_2 \\
    \end{rcases} \longrightarrow [x_1 \mapsto v_0] t_1
    \label{eq:e-caseinl}\tag{E-CaseInl} \\ \\

    \begin{rcases}
        \text{case } (&amp; \text{inr } v_0) \text{ of} \\
                      &amp; \text{inl } x_1 \Rightarrow t_1 \ \mid \\
                      &amp; \text{inl } x_2 \Rightarrow t_2 \\
    \end{rcases} \longrightarrow [x_2 \mapsto v_0] t_2
    \label{eq:e-caseinr}\tag{E-CaseInr} \\ \\

    \frac{t_0 \longrightarrow t_0'}{
        \begin{rcases}
            \text{case } &amp; t_0 \text{ of} \\
                         &amp; \text{inl } x_1 \Rightarrow t_1 \ \mid \\
                         &amp; \text{inr } x_2 \Rightarrow t_2
        \end{rcases} \longrightarrow \begin{cases}
            \text{case } &amp; t_0' \text{ of} \\
                         &amp; \text{inl } x_1 \Rightarrow t_1 \ \mid \\
                         &amp; \text{inr } x_2 \Rightarrow t_2
        \end{cases}
    } \label{eq:e-case}\tag{E-Case} \\ \\

\frac{t_1 \longrightarrow t_1'}{\text{inl }t_1 \longrightarrow \text{inl }t_1'}
\label{eq:e-inl}\tag{E-Inl} \\ \\

\frac{t_1 \longrightarrow t_1'}{\text{inr }t_1 \longrightarrow \text{inr }t_1'}
\label{eq:e-inr}\tag{E-Inr} \\ \\
\end{align}\]

<p>And weâ€™ll also introduce three typing rules:</p>

\[\begin{align}
\frac{\Gamma\vdash t_1 : T_1}{\Gamma\vdash\text{inl } t_1 : T_1 + T_2}
\label{eq:t-inl}\tag{T-Inl} \\ \\

\frac{\Gamma\vdash t_1 : T_2}{\Gamma\vdash\text{inr } t_1 : T_1 + T_2}
\label{eq:t-inr}\tag{T-Inr} \\ \\

\frac{
    \Gamma\vdash t_0 : T_1 + T_2 \quad
    \Gamma\cup(x_1: T_1) \vdash t_1 : T \quad
    \Gamma\cup(x_2: T_2) \vdash t_2 : T
}{
    \Gamma\vdash\text{case } t_0 \text{ of inl } x_1 \Rightarrow t_1 \mid \text{inr } x_2 \Rightarrow t_2 : T
}
\label{eq:t-case}\tag{T-Case} \\
\end{align}\]

<h4 id="sums-and-uniqueness-of-type">Sums and uniqueness of type</h4>
<p>The rules $\ref{eq:t-inr}$ and $\ref{eq:t-inl}$ may seem confusing at first. We only have one type to deduce from, so what do we assign to $T_2$ and $T_1$, respectively? These rules mean that we have lost uniqueness of types: if $t$ has type $T$, then $\text{inl } t$ has type $T+U$ <strong>for every</strong> $U$.</p>

<p>There are a couple of solutions to this:</p>

<ol>
  <li>We can infer $U$ as needed during typechecking</li>
  <li>Give constructors different names and only allow each name to appear in one sum type. This requires generalization to <a href="#variants">variants</a>, which weâ€™ll see next. OCaml adopts this solution.</li>
  <li>Annotate each inl and inr with the intended sum type.</li>
</ol>

<p>For now, we donâ€™t want to look at type inference and variance, so weâ€™ll choose the third approach for simplicity. Weâ€™ll introduce these annotation as ascriptions on the injection operators in our grammar:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>t ::=
    ...
    inl t as T
    inr t as T

v ::=
    ...
    inl v as T
    inr v as T
</pre></td></tr></tbody></table></code></pre></figure>

<p>The evaluation rules would be exactly the same as previously, but with ascriptions in the syntax. The injection operators just now also specify <em>which</em> sum type weâ€™re injecting into, for the sake of uniqueness of type.</p>

<h4 id="variants">Variants</h4>
<p>Just as we generalized binary products to labeled records, we can generalize binary sums to labeled variants. We can label the members of the sum type, so that we write $\langle l_1: T_1, l_2: T_2 \rangle$ instead of $T_1 + T_2$ ($l_1$ and $l_2$ are the labels).</p>

<p>As a motivating example, weâ€™ll show a useful idiom that is possible with variants, the optional value. Weâ€™ll use this to create a table. The example below is just like in OCaml.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="nc">OptionalNat</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">none</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">,</span>  <span class="n">some</span><span class="k">:</span> <span class="kt">Nat&gt;</span><span class="o">;</span>
<span class="nc">Table</span> <span class="k">=</span> <span class="nc">Nat</span> <span class="o">-&gt;</span> <span class="nc">OptionalNat</span><span class="o">;</span>
<span class="n">emptyTable</span> <span class="k">=</span> <span class="n">Î»t</span><span class="k">:</span> <span class="kt">Nat.</span> <span class="kt">&lt;none</span><span class="o">=</span><span class="n">unit</span><span class="o">&gt;</span> <span class="n">as</span> <span class="nc">OptionalNat</span><span class="o">;</span>

<span class="n">extendTable</span> <span class="k">=</span> 
    <span class="n">Î»t</span><span class="k">:</span> <span class="kt">Table.</span> <span class="kt">Î»key:</span> <span class="kt">Nat.</span> <span class="kt">Î»val:</span> <span class="kt">Nat.</span>
        <span class="kt">Î»search:</span> <span class="kt">Nat.</span>
            <span class="kt">if</span> <span class="o">(</span><span class="kt">equal</span> <span class="kt">search</span> <span class="kt">key</span><span class="o">)</span> <span class="kt">then</span> <span class="kt">&lt;some</span><span class="o">=</span><span class="k">val</span><span class="o">&gt;</span> <span class="n">as</span> <span class="nc">OptionalNat</span>
            <span class="nf">else</span> <span class="o">(</span><span class="n">t</span> <span class="n">search</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The implementation works a bit like a linked list, with linear look-up. We can use the result from the table by distinguishing the outcome with a <code class="highlighter-rouge">case</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="n">x</span> <span class="k">=</span> <span class="k">case</span> <span class="nf">t</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span> <span class="n">of</span>
    <span class="o">&lt;</span><span class="n">none</span><span class="k">=</span><span class="n">u</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="mi">999</span>
  <span class="o">|</span> <span class="o">&lt;</span><span class="n">some</span><span class="k">=</span><span class="n">v</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="n">v</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="recursion">Recursion</h3>
<p>In STLC, all programs terminate. Weâ€™ll <a href="#strong-normalization">go into a little more detail later</a>, but the main idea is that evaluation of a well-typed program is guaranteed to halt; we say that the well-typed terms are <em>normalizable</em>.</p>

<p>Indeed, the infinite recursions from untyped lambda calculus (terms like $\text{omega}$ and $\text{fix}$) are not typable, and thus cannot appear in STLC. Since we canâ€™t express $\text{fix}$ in STLC, instead of defining it as a term in the language, we can add it as a primitive instead to get recursion.</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>t ::=
    ...
    fix t
</pre></td></tr></tbody></table></code></pre></figure>

<p>Weâ€™ll need to add evaluation rules recreating its behavior, and a typing rule that restricts its use to the intended use-case.</p>

\[\begin{align}
\text{fix } (\lambda x: T_1.\ t_2) \longrightarrow \left[
    x\mapsto (\text{fix }(\lambda x: T_1.\ t_2))
\right] t_2
\label{eq:e-fixbeta}\tag{E-FixBeta} \\ \\

\frac{t_1 \longrightarrow t_1'}{\text{fix }t_1 \longrightarrow \text{fix }t_1'}
\label{eq:e-fix}\tag{E-Fix} \\ \\

\frac{\Gamma\vdash t_1 : T_1 \rightarrow T_1}{\Gamma\vdash\text{fix }t_1:T_1}
\label{eq:t-fix}\tag{T-Fix}
\end{align}\]

<p>In order for a function to be recursive, the function needs to map a type to the same type, hence the restriction of $T_1 \rightarrow T_1$. The type $T_1$ will itself be a function type if weâ€™re doing a recursion. Still, note that the type system doesnâ€™t enforce this. There will actually be situations in which it will be handy to use something else than a function type inside a fix operator.</p>

<p>Seeing that this fixed-point notation can be a little involved, we can introduce some nice syntactic sugar to work with it:</p>

\[\text{letrec } x: T_1 = t_1 \text{ in } t_2
\quad \defeq \quad
\text{let } x = \text{fix } (\lambda x: T_1.\ t_1) \text{ in } t_2\]

<p>This $t_1$ can now refer to the $x$; thatâ€™s the convenience offered by the construct. Although we donâ€™t strictly need to introduce typing rules (itâ€™s syntactic sugar, weâ€™re relying on existing constructs), a typing rule for this could be:</p>

\[\frac{\Gamma\cup(x:T_1)\vdash t_1:T_1 \quad \Gamma\cup(x: T_1)\vdash t_2:T_2}{\Gamma\vdash\text{letrec } x: T_1 = t_1 \text{ in } t_2:T_2}\]

<p>In Scala, a common error message is that a recursive function needs an explicit return type, for the same reasons as the typing rule above.</p>

<h3 id="references">References</h3>
<h4 id="mutability">Mutability</h4>
<p>In most programming languages, variables are (or can be) mutable. That is, variables can provide a name referring to a previously calculated value, as well as a way of overwriting this value with another (under the same name). How can we model this in STLC?</p>

<p>Some languages (e.g. OCaml) actually formally separate variables from mutation. In OCaml, variables are only for naming, the binding between a variable and a value is immutable. However, there is the concept of <em>mutable values</em>, also called <em>reference cells</em> or <em>references</em>. This is the style weâ€™ll study, as it is easier to work with formally. A mutable value is represented in the type-level as a <code class="highlighter-rouge">Ref T</code> (or perhaps even a <code class="highlighter-rouge">Ref(Option T)</code>, since the null pointer cannot produce a value).</p>

<p>The basic operations are allocation with the <code class="highlighter-rouge">ref</code> operator, dereferencing with <code class="highlighter-rouge">!</code> (in C, we use the <code class="highlighter-rouge">*</code> prefix), and assignment with <code class="highlighter-rouge">:=</code>, which updates the content of the reference cell. Assignment returns a <code class="highlighter-rouge">unit</code> value.</p>

<h4 id="aliasing">Aliasing</h4>
<p>Two variables can reference the same cell: we say that they are <em>aliases</em> for the same cell. Aliasing is when we have different references (under different names) to the same cell. Modifying the value of the reference cell through one alias modifies the value for all other aliases.</p>

<p>The possibility of aliasing is all around us, in object references, explicit pointers (in C), arrays, communication channels, I/O devices; thereâ€™s practically no way around it. Yet, alias analysis is quite complex, costly, and often makes is hard for compilers to do optimizations they would like to do.</p>

<p>With mutability, the order of operations now matters; <code class="highlighter-rouge">r := 1; r := 2</code> isnâ€™t the same as <code class="highlighter-rouge">r := 2; r := 1</code>. If we recall the <a href="#confluence-in-full-beta-reduction">Church-Rosser theorem</a>, weâ€™ve lost the principle that all reduction paths lead to the same result. Therefore, some language designers disallow it (Haskell). But there are benefits to allowing it, too: efficiency, dependency-driven data flow (e.g. in GUI), shared resources for concurrency (locks), etc. Therefore, most languages provide it.</p>

<p>Still, languages without mutability have come up with a bunch of abstractions that allow us to have some of the benefits of mutability, like monads and lenses.</p>

<h4 id="typing-rules-1">Typing rules</h4>
<p>Weâ€™ll introduce references as a type <code class="highlighter-rouge">Ref T</code> to represent a variable of type <code class="highlighter-rouge">T</code>. We can construct a reference as <code class="highlighter-rouge">r = ref 5</code>, and access the contents of the reference using <code class="highlighter-rouge">!r</code> (this would return <code class="highlighter-rouge">5</code> instead of <code class="highlighter-rouge">ref 5</code>).</p>

<p>Letâ€™s define references in our language:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>t ::=          // terms
    unit          // unit constant
    x             // variable
    Î»x: T. t      // abstraction
    t t           // application
    ref t         // reference creation
    !t            // dereference
    t := t        // assignment
</pre></td></tr></tbody></table></code></pre></figure>

\[\begin{align}
\frac{\Gamma\vdash t_1 : T_1}{\Gamma\vdash \text{ref } t_1 : \text{Ref } T_1}
\label{eq:t-ref}\tag{T-Ref} \\ \\

\frac{\Gamma\vdash t_1: \text{Ref } T_1}{\Gamma\vdash !t_1 : T_1}
\label{eq:t-deref}\tag{T-Deref} \\ \\

\frac{\Gamma\vdash t_1 : \text{Ref } T_1 \quad \Gamma\vdash t_2: T_1}{\Gamma\vdash t_1 := t_2 : \text{Unit}}
\label{eq:t-assign}\tag{T-Assign} \\ \\
\end{align}\]

<h4 id="evaluation-1">Evaluation</h4>
<p>What is the <em>value</em> of <code class="highlighter-rouge">ref 0</code>? The crucial observation is that evaluation <code class="highlighter-rouge">ref 0</code> must <em>do</em> something. Otherwise, the two following would behave the same:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> 
<span class="n">s</span> <span class="o">=</span> <span class="n">r</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Evaluating <code class="highlighter-rouge">ref 0</code> should allocate some storage, and return a reference (or pointer) to that storage. A reference names a location in the <strong>store</strong> (also known as the <em>heap</em>, or just <em>memory</em>). Concretely, the store could be an array of 8-bit bytes, indexed by 32-bit integers. More abstractly, itâ€™s an array of values, or even more abstractly, a partial function from locations to values.</p>

<p>We can introduce this idea of locations in our syntax. This syntax is exactly the same as the previous one, but adds the notion of locations:</p>

<figure class="highlight"><pre><code class="language-antlr" data-lang="antlr"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>v ::=         // values
    unit         // unit constant
    Î»x: T. t     // abstraction value
    l            // store location

t ::=         // terms
    unit         // unit constant
    x            // variable
    Î»x: T. t     // abstraction
    t t          // application
    ref t        // reference creation
    !t           // dereference
    t := t       // assignment
    l            // store location 
</pre></td></tr></tbody></table></code></pre></figure>

<p>This doesnâ€™t mean that weâ€™ll allow programmers to write explicit locations in their programs. We just use this as a modeling trick; weâ€™re enriching the internal language to include some run-time structures.</p>

<p>With this added notion of stores and locations, the result of an evaluation now depends on the store in which it is evaluated, which we need to reflect in our evaluation rules. Evaluation must now include terms $t$ <strong>and</strong> store $\mu$:</p>

\[t \mid \mu \longrightarrow t' \mid \mu'\]

<p>Letâ€™s take a look for the evaluation rules for STLC with references, operator by operator.</p>

\[\begin{align}
\frac{t_1 \mid \mu \longrightarrow t_1'\mid\mu'}{t_1 := t_2 \mid \mu \longrightarrow t_1' := t_2 \mid \mu'}
\label{eq:e-assign1}\tag{E-Assign1} \\ \\

\frac{t_2 \mid \mu \longrightarrow t_2'\mid\mu'}{t_1 := t_2 \mid \mu \longrightarrow t_1 := t_2' \mid \mu'}
\label{eq:e-assign2}\tag{E-Assign2} \\ \\

l := v_2 \mid \mu \longrightarrow \text{unit}\mid[l\mapsto v_2]\mu
\label{eq:e-assign}\tag{E-Assign} \\ \\
\end{align}\]

<p>The assignments $\ref{eq:e-assign1}$ and $\ref{eq:e-assign2}$ evaluate terms until they become values. When they have been reduced, we can do that actual assignment: as per $\ref{eq:e-assign}$, we update the store and return return <code class="highlighter-rouge">unit</code>.</p>

\[\begin{align}
\frac{t_1 \mid \mu \longrightarrow t_1' \mid \mu'}{\text{ref } t_1 \mid \mu \longrightarrow \text{ref } t_1' \mid \mu'}
\label{eq:e-ref}\tag{E-Ref} \\ \\

\frac{l \notin \text{dom}(\mu)}{\text{ref } v_1 \mid \mu \longrightarrow l \mid (\mu \cup (l\mapsto v_1))}
\label{eq:e-refv}\tag{E-RefV}
\end{align}\]

<p>A reference $\text{ref }t_1$ first evaluates $t_1$ until it is a value ($\ref{eq:e-ref}$). To evaluate the reference operator, we find a fresh location $l$ in the store, to which it binds $v_1$, and it returns the location $l$.</p>

\[\begin{align}
\frac{t_1 \mid \mu \longrightarrow t_1' \mid \mu'}{!t_1 \mid \mu \longrightarrow !t_1' \mid \mu'}
\label{eq:e-deref}\tag{E-Deref} \\ \\

\frac{\mu(l) = v}{!l\mid\mu \longrightarrow v\mid\mu}
\label{eq:e-derefloc}\tag{E-DerefLoc}
\end{align}\]

<p>We find the same congruence rule as usual in $\ref{eq:e-deref}$, where a term $!t_1$ first evaluates $t_1$ until it is a value. Once it is a value, we can return the value in the current store using $\ref{eq:e-derefloc}$.</p>

<p>The evaluation rules for abstraction and application are augmented with stores, but otherwise unchanged.</p>

<h4 id="store-typing">Store typing</h4>
<p>What is the type of a location? The answer to this depends on what is in the store. Unless we specify it, a store could contain anything at a given location, which is problematic for typechecking. The solution is to type the locations themselves. This leads us to a typed store:</p>

\[\begin{align}
\mu = (&amp; l_1 \mapsto \text{Nat}, \\
       &amp; l_2 \mapsto \lambda x: \text{Unit}. x)
\end{align}\]

<p>As a first attempt at a typing rule, we can just say that the type of a location is given by the type of the value in the store at that location:</p>

\[\frac{\Gamma\vdash\mu(l) : T_1}{\Gamma\vdash l : \text{Ref } T_1}\]

<p>This is problematic though; in the following, the typing derivation for $!l_2$ would be infinite because we have a cyclic reference:</p>

\[\begin{align}
\mu =\ (&amp; l_1 \mapsto \lambda x: \text{Nat}.\ !l_2\ x, \\
        &amp; l_2 \mapsto \lambda x: \text{Nat}.\ !l_1\ x)
\end{align}\]

<p>The core of the problem here is that we would need to recompute the type of a location every time. But shouldnâ€™t be necessary. Seeing that references are strongly typed as <code class="highlighter-rouge">Ref T</code>, we know exactly what type of value we can place in a given store location. Indeed, the typing rules we chose for references guarantee that a given location in the store always is used to hold values of the same type.</p>

<p>So to fix this problem, we need to introduce a <strong>store typing</strong>. This is a partial function from location to types, which weâ€™ll denote by $\Sigma$.</p>

<p>Suppose weâ€™re given a store typing $\Sigma$ describing the store $\mu$. We can use $\Sigma$ to look up the types of locations, without doing a lookup in $\mu$:</p>

\[\frac{\Sigma(l) = T_1}{\Gamma\mid\Sigma\vdash l : \text{Ref } T_1}
\label{eq:t-loc}\tag{T-Loc}\]

<p>This tells us how to check the store typing, but how do we create it? We can start with an empty typing $\Sigma = \emptyset$, and add a typing relation with the type of $v_1$  when a new location is created during evaluation of $\ref{eq:e-refv}$.</p>

<p>The rest of the typing rules remain the same, but are augmented with the store typing. So in conclusion, we have updated our evaluation rules with a <em>store</em> $\mu$, and our typing rules with a <em>store typing</em> $\Sigma$.</p>

<h4 id="safety">Safety</h4>
<p>Letâ€™s take a look at progress and preservation in this new type system. Preservation turns out to be more interesting, so letâ€™s look at that first.</p>

<p>Weâ€™ve added a store and a store typing, so we need to add those to the statement of preservation to include these. Naively, weâ€™d write:</p>

\[\Gamma\mid\Sigma\vdash t: T \text{ and }
t\mid\mu\longrightarrow t'\mid\mu'
\quad \implies \quad 
\Gamma\mid\Sigma\vdash t': T\]

<p>But this would be wrong! In this statement, $\Sigma$ and $\mu$ would not be constrained to be correlated at all, which they need to be. This constraint can be defined as follows:</p>

<p>A store $\mu$ is well typed with respect to a typing context $\Gamma$ and a store typing $\Sigma$ (which we denote by $\Gamma\mid\Sigma\vdash\mu$) if the following is satisfied:</p>

\[\text{dom}(\mu) = \text{dom}(\Sigma)
\quad \text{and} \quad 
\Gamma\mid\Sigma\vdash\mu(l) : \Sigma(l),\ \forall l\in\text{dom}(\mu)\]

<p>This gets us closer, and we can write the following preservation statement:</p>

\[\Gamma\mid\Sigma \vdash t : T \text{ and }
t\mid\mu \longrightarrow t'\mid\mu \text{ and }
\Gamma\mid\Sigma \vdash \mu
\quad \implies \quad
\Gamma\mid\Sigma\vdash t' : T\]

<p>But this is still wrong! When we create a new cell with $\ref{eq:e-refv}$, we would break the correspondence between store typing and store.</p>

<p>The correct version of the progress theorem is the following:</p>

\[\Gamma\mid\Sigma \vdash t : T \text{ and }
t\mid\mu \longrightarrow t'\mid\mu \text{ and }
\Gamma\mid\Sigma \vdash \mu
\quad \implies \quad
\text{for some } \Sigma' \supseteq \Sigma, \;\;
\Gamma\mid\Sigma'\vdash t' : T\]

<p>This progress theorem just asserts that there is <em>some</em> store typing $\Sigmaâ€™ \supseteq \Sigma$ (agreeing with $\Sigma$ on the values of all old locations, but that may have also add new locations), such that $tâ€™$ is well typed in $\Sigmaâ€™$.</p>

<p>The progress theorem must also be extended with stores and store typings:</p>

<p>Suppose that $t$ is a closed, well-typed term; that is, $\emptyset\mid\Sigma\vdash t: T$ for some type $T$ and some store typing $\Sigma$. Then either $t$ is a value or else, for any store $\mu$ such that $\emptyset\mid\Sigma\vdash\mu$<sup id="fnref:well-typed-store-notation" role="doc-noteref"><a href="#fn:well-typed-store-notation" class="footnote">2</a></sup>, there is some term $tâ€™$ and store $\muâ€™$ with $t\mid\mu \longrightarrow tâ€™\mid\muâ€™$.</p>

<h2 id="type-reconstruction-and-polymorphism">Type reconstruction and polymorphism</h2>
<p>In type checking, we wanted to, given $\Gamma$, $t$ and $T$, check whether $\Gamma\vdash t: T$. So far, for type checking to take place, we required explicit type annotations.</p>

<p>In this section, weâ€™ll look into <strong>type reconstruction</strong>, which allows us to infer types when type annotations arenâ€™t present: given $\Gamma$ and $t$, we want to find a type $T$ such that $\Gamma\vdash t:T$.</p>

<p>Immediately, we can see potential problems with this idea:</p>

<ul>
  <li>Abstractions without the parameter type annotation seem complicated to reconstruct (a parameter could almost have any type)</li>
  <li>A term can have  many types</li>
</ul>

<p>To solve these problems, weâ€™ll introduce polymorphism into our type system.</p>

<h3 id="constraint-based-typing-algorithm">Constraint-based Typing Algorithm</h3>
<p>The idea is to split the work in two: first, we want to generate and record constraints, and then, unify them (that is, attempt to satisfy the constraints).</p>

<p>In the following, weâ€™ll denote constraints as a set of equations $\set{T_i \hat{=} U_i}_{i=1, \dots, m}$, constraining type variables $T_i$ to actual types $U_i$.</p>

<h4 id="constraint-generation">Constraint generation</h4>
<p>The constraint generation algorithm can be described as the following function $TP: \text{Judgment} \rightarrow \text{Equations}$</p>

<figure class="highlight"><pre><code class="language-pseudo" data-lang="pseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>TP: Judgment -&gt; Equations
TP(Î“ âŠ¦ t : T) = case t of
    x     :    {Î“(x) ^= T}

    Î»x. t1:    let a, b fresh in
               {(a -&gt; b) ^= T} âˆª
               TP(Î“, (x: a) âŠ¦ t1 : b)

    t1 t2 :    let a fresh in
               TP(Î“ âŠ¦ t1 : a -&gt; T) âˆª
               TP(Î“ âŠ¦ t2 : a)
</pre></td></tr></tbody></table></code></pre></figure>

<p>This creates a set of constraints between type variables and the expected types.</p>

<p>The above essentially gives us constraint generation rules in algorithmic form. An alternative notation is as to give the set of constraint typing relations, which are denoted as:</p>

\[\Gamma \vdash t: T \mid_\chi C\]

<p>This can be read as â€œa term $t$ has type $T$ in the environment $\Gamma$ whenever constraints $C$ with type variables $\chi$ are satisfiedâ€. The $\chi$ subscript keeps track of the fresh variables created in the various subderivations, and ensures that they are distinct.</p>

<p>The implementation we gave above could also be described by the following constraint generation rules:</p>

\[\begin{align}
\frac{
    x : T \in \Gamma
}{
    \Gamma \vdash x: T \mid_\emptyset \set{ }
} \label{eq:ct-var}\tag{CT-Var}
\\ \\
\frac{
    \Gamma\cup(x: T_1) \vdash t_2 : T_2 \mid_\chi C
}{
    \Gamma\vdash \lambda x: T_1.\ t_2 : T_1 \rightarrow T_2 \mid_\chi C
} \label{eq:ct-abs}\tag{CT-Abs}
\\ \\
\frac{
    \Gamma \vdash t_1 : T_1 \mid_{\chi_1} C_1
    \quad
    \Gamma \vdash t_2 : T_2 \mid_{\chi_2} C_2
}{
    \Gamma \vdash t_1 \ t_2 : X 
    \mid_{\chi_1\cup\chi_2\cup\set{X}} 
    C_1 \cup C_2 \cup \set{T_1 \ \hat{=} \  T_2 \rightarrow X}
} \label{eq:ct-app}\tag{CT-App}
\end{align}\]

<p>We havenâ€™t explicitly written it in $\ref{eq:ct-app}$, but we expect $\chi_1$ and $\chi_2$ to be distinct (i.e. $\chi_1 \cap \chi_2 = \emptyset$), and we expect $X$ to be fresh (i.e. not clash with anything else).</p>

<h4 id="soundness-and-completeness">Soundness and completeness</h4>
<p>In general a type reconstruction algorithm $\mathcal{A}$ assigns to an environment $\Gamma$ and a term $t$ a set of types $\mathcal{A}(\Gamma, t)$.</p>

<p>The algorithm is <strong>sound</strong> if for every type $T\in \mathcal{A}(\Gamma, t)$ we can prove the judgment $\Gamma\vdash t: T$.</p>

<p>The algorithm is <strong>complete</strong> if for every provable judgment $\Gamma\vdash t: T$ we have $T\in\mathcal{A}(\Gamma, t)$.</p>

<p>Soundness and completeness are the two directions of the following implication:</p>

\[\text{the algorithm can prove it} \iff \text{it holds}\]

<p>Soundness and completeness are about the $\Leftarrow$ and $\Rightarrow$ directions of the above, respectively. The TP function we defined previously for STLC is sound and complete, and the relationship is thus $\iff$. We can write this mathematically as follows:</p>

\[\Gamma\vdash t: T \iff \exists \bar{b} \text{ s.t. } [a\mapsto T] EQNS\]

<p>Where:</p>

<ul>
  <li>$a$ is a new type variable</li>
  <li>$EQNS = TP(\Gamma\vdash t: a)$ is the set of type constraints</li>
  <li>$\bar{b} = \text{tv}(EQNS)\setminus\text{tv}(\Gamma)$, where $\text{tv}$ denotes the set of free type variables.</li>
  <li>$[a \mapsto T] EQNS$ is notation for replacing $a$ with $T$ in $EQNS$</li>
</ul>

<h4 id="substitutions">Substitutions</h4>
<p>Now that weâ€™ve generated a constraint set in the form $C = \set{T_i\ \hat{=}\ U_i}_{i=1, \dots, m}$, weâ€™d like a way to substitute these constraints into real types. We must generate a set of substitutions:</p>

\[s = \set{a_j \mapsto T_j'}_{j=1, \dots, n}\]

<p>These substitutions cannot be cyclical. The type variables may not appear recursively on their right-hand side (directly or indirectly). We can write this requirement as:</p>

\[a_j \notin \text{tv}(T_k') \quad \text{for } j=1,\dots, n, \ k = j, \dots n\]

<p>This substitution is an idempotent mapping from type variables to types, mapping all but a finite number of type variables to themselves. We can think of a substitution as a set of equations:</p>

\[\set{a\ \hat{=}\ T}, \quad a \notin \text{tv}(T)\]

<p>Alternatively, we can think of it as a function transforming types (based on the set of equations). Substitution is applied in a straightforward way:</p>

\[\begin{align}
s(X)  &amp; = \begin{cases}
    T &amp; \text{if } (X \mapsto T) \in s \\
    X &amp; \text{otherwise}
\end{cases} \\
s(\text{Nat})         &amp; = \text{Nat} \\
s(\text{Bool})        &amp; = \text{Bool} \\
s(T \rightarrow U)    &amp; = sT \rightarrow sU \\
\end{align}\]

<p>Substitution has two properties:</p>

<ul>
  <li><strong>Idempotence</strong>: $s(s(T)) = s(T)$</li>
  <li><strong>Composition</strong>: $(f \circ g)\ x = f(g\ x)$, the composition of substitutions, is also a substitution</li>
</ul>

<p>The composition of two substitutions $f$ and $g$ is:</p>

\[f \circ g = \begin{bmatrix}
X \mapsto f(T) &amp; \text{for each } (X \mapsto T) \in g \\
X \mapsto T    &amp; \text{for each } (X \mapsto T) \in f \text{ with } X \notin dom(g) \\
\end{bmatrix}\]

<p>Essentially, if $g$ modifies $X$, we apply the $f$ substitution on top of $g(X)$. If it leaves it unchanged, the result is just $f(X)$.</p>

<h4 id="unification">Unification</h4>
<p>We present a unification algorithm based on Robinsonâ€™s 1965 unification algorithm:</p>

<figure class="highlight"><pre><code class="language-pseudo" data-lang="pseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>mgu                      : (Type ^= Type) -&gt; Subst -&gt; Subst
mgu(T ^= U) s            = mgu'(sT ^= sU) s

mgu'(a ^= a) s           = s
mgu'(a ^= T) s           = s âˆª {a â†’ T} if a âˆ‰ tv(T)
mgu'(T ^= T) s           = s âˆª {a â†’ T} if a âˆ‰ tv(T)
mgu'(T -&gt; T' ^= U -&gt; U') = (mgu(T' ^= U') â—¦ mgu(T ^= U)) s
mgu'(K[T1, ..., Tn] ^= K[U1, ..., Un]) s
                         = (mgu(Tn ^= Un) â—¦ ... â—¦ mgu(T1 ^= U1)) s
mgu'(T ^= U) s           = error
</pre></td></tr></tbody></table></code></pre></figure>

<p>This function is called $\text{mgu}$, which stands for most general unifier.</p>

<p>A substitution $u$ is a <strong>unifier</strong> of a set of equations $\set{T_i\ \hat{=}\ U_i}$ if $uT_i = uU_i,\, \forall i$. This means that it can find an assignment to the type variables in the constraints so that all equations are trivially true.</p>

<p>The substitution is a <strong>most general unifier</strong> if for every other unifier $uâ€™$ of the same equations, there exists a substitution $s$ such that $uâ€™ = s\circ u$. In other words, it must be less specific (or more general) than all other unifiers.</p>

<p>If we give the following piece of code to a most general unifier, $f$ will be typed as $\forall a. a \rightarrow a$, and not $\text{Int}\rightarrow\text{Int}$ (more on universal types in <a href="#polymorphism">the next chapter</a>). Both would be correct, but the former would be most general.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre>let f = (Î»x. x) in f(3)
</pre></td></tr></tbody></table></code></pre></figure>

<p>We wonâ€™t prove this, but just state it as a theorem: if we get a set of constraints $\text{EQNS}$ which has a unifier, then $\text{mgu EQNS} \set{}$ computes the most general unifier of the constraints. If the constraints do not have a unifier, it fails.</p>

<p>In other words, the TP function is sound and complete.</p>

<h4 id="single-pass-unification">Single-pass unification</h4>
<p>Previously, we defined constraint generation. Once we had <em>all</em> the constraints, we passed them on to the unifier, which attempted to find a most general substitution satisfying the constraints.</p>

<p>In practice, however, itâ€™s more common to merge the two, and to unify earlier. This allows us to eliminate some constraints early (which is good for performance), but also to get better error reporting.</p>

<figure class="highlight"><pre><code class="language-pseudo" data-lang="pseudo"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>TP: Judgment -&gt; Subst -&gt; Subst
TP(Î“ âŠ¦ t : T) = case t of
    x     :    mgu({Î“(x) ^= T})

    Î»x. t1:    let a, b fresh in
               mgu({(a -&gt; b) ^= T}) â—¦
               TP(Î“, (x: a) âŠ¦ t1 : b)

    t1 t2 :    let a fresh in
               TP(Î“ âŠ¦ t1 : a -&gt; T) â—¦
               TP(Î“ âŠ¦ t2 : a)
</pre></td></tr></tbody></table></code></pre></figure>

<p>This works because <code class="highlighter-rouge">mgu</code> is the <em>most general</em> unifier, meaning that it only generates principal types (<a href="#principal-types">more on these later</a>) at each step. The means that the algorithm never needs to re-analyze a subterm, as it only makes the minimum commitments to achieve typability at each step.</p>

<h4 id="strong-normalization">Strong normalization</h4>
<p>With this typing inference in place, we can be tempted to try to run this on the diverging $\Omega$ that <a href="#recursion-in-lambda-calculus">we defined much earlier</a>, or perhaps on the <a href="#recursion-in-lambda-calculus">Y combinator</a>. But as we said before, self-application is not typable. In fact, we can state a stronger assertion:</p>

<p><strong>Strong Normalization Theorem</strong>: if $\vdash t: T$, then there is a value $V$ such that $t \longrightarrow^* V$.</p>

<p>In other words, if we can type it, it reduces to a value. In the case of the infinite recursion, we cannot type it, and it does not evaluate to a value (instead, it diverges). So looping infinitely isnâ€™t possible in STLC, which leads us to the corollary of this theorem: <strong>STLC is not Turing complete</strong>.</p>

<h3 id="polymorphism">Polymorphism</h3>
<p>There are multiple forms of polymorphism:</p>

<ul>
  <li><strong>Universal polymorphism</strong> (aka <em>generic types</em>): the ability to instantiate type variables</li>
  <li><strong>Inclusion polymorphism</strong> (aka <em>subtying</em>): the ability to treat a value of a subtype as a value of one of its supertypes</li>
  <li><strong>Ad-hoc</strong> (aka <em>overloading</em>): the ability to define several versions of the same function name with different types.</li>
</ul>

<p>Weâ€™ll concentrate on universal polymorphism, of which there are to variants: explicit and implicit.</p>

<h4 id="explicit-polymorphism">Explicit polymorphism</h4>
<p>In STLC, a term can have many types, but a variable or parameter only has one type. With polymorphism, we open this up: we allow functions to be applied to arguments of many types. The resulting system is known as <strong>System F</strong>.</p>

<p>To do this, we can introduce a type abstraction with $\Lambda$: this does the same thing as a regular $\lambda$, except that it takes a type. For instance, we could build a polymorphic identity function:</p>

\[\text{id} = \Lambda X.\ \lambda x: X.\ x\]

<p>Application is like before, except that we write the type in square brackets $[T]$ (like in Scala, where we use <code class="highlighter-rouge">[T]</code>, or <code class="highlighter-rouge">&lt;T&gt;</code> in Java). For instance, to get the identity function for natural numbers, we write:</p>

\[\text{id } [\text{Nat}]\]

<p>This returns $\lambda x: \text{Nat}.\ x$, which is an instance of the polymorphic function.</p>

<p>The type of the $\Lambda$ abstraction is written as $\forall X.\ X \rightarrow X$. This polymorphic type notation $\forall a.T$ can be used as any other type. The typing rules are:</p>

\[\begin{align}
\frac{\Gamma\vdash t: \forall a.T}{\Gamma\vdash t[U] : [a \mapsto U] T}
\label{eq:polymorphic-app}\tag{$\forall$E} \\ \\

\frac{\Gamma\vdash t: T}{\Gamma\vdash\Lambda a.t : \forall a.T}
\label{eq:polymorphic-abs}\tag{$\forall$I} \\ \\
\end{align}\]

<p>For instance, the signature of <code class="highlighter-rouge">map</code> could be written as follows in Scala:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span><span class="o">][</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In System F weâ€™d write:</p>

\[\Lambda X.\ \Lambda Y.\ \lambda f: X\rightarrow Y.\ \lambda xs: \text{List }[X].\ \dots\]

<h4 id="implicit-polymorphism">Implicit polymorphism</h4>
<p>An alternative type system is <strong>Hindley-Milner</strong>, which does not require annotations for parameter types, and instead opts for implicit polymorphism. The idea is that inference treats unannotated named values (i.e. <code class="highlighter-rouge">let ... in ...</code> statements) as polymorphic types. This explains why this feature is also known as <em>let-polymorphism</em>.</p>

<p>To have this feature, we must introduce the notion of <strong>type schemes</strong>. These are not fully general types, but are an internal construct used to type let expressions. A type scheme has the following syntax:</p>

\[S ::= T \mid \forall a. S\]

<p>Not that a plain type is a type scheme, but that we can also add an arbitrary number of universal type arguments $\forall a.$ before it.</p>

<p>The typing rules for the Hindley-Milner are given below. Here, we always use $S$ as a metavariable for type schemes, and $T$ and $U$ for plain (non-polymorphic) types.</p>

\[\begin{align}
\Gamma \cup (x: S) \cup \Gamma' \vdash x: S, \quad x\notin\text{dom}(\Gamma')
\label{eq:hm-var}\tag{Var} \\ \\

\frac{\Gamma\vdash t: \forall a. T}{\Gamma\vdash t: [a \mapsto U]T}
\label{eq:hm-forall-e}\tag{$\forall E$} \\ \\

\frac{\Gamma\vdash t: T \quad a\notin \text{tv}(\Gamma)}{\Gamma\vdash \forall a.T}
\label{eq:hm-forall-i}\tag{$\forall I$} \\ \\

\frac{\Gamma\vdash t: S \quad \Gamma\cup(x: S)\vdash t' : T}
{\Gamma \vdash \text{let } x = t \text{ in } t': T}
\label{eq:hm-let}\tag{Let} \\ \\

\frac{\Gamma\cup(x: T)\vdash t: T}{\Gamma\vdash\lambda x. t: T \rightarrow U}
\label{eq:hm-arrow-i}\tag{$\rightarrow I$} \\ \\

\frac{\Gamma\vdash t_1: T \rightarrow U \quad \Gamma\vdash t_2: T}{\Gamma\vdash t_1\ t_2: U}
\label{eq:hm-arrow-e}\tag{$\rightarrow E$} \\
\end{align}\]

<p>$\ref{eq:hm-var}$ means that we can verify $x: S$ if $(x: S)$ is in the environment and it isnâ€™t overwritten later (in $\Gammaâ€™$). This allows us to have some concept of scoping of variables.</p>

<p>$\ref{eq:hm-forall-e}$ allows to verify specific instances of a polymorphic type, and $\ref{eq:hm-forall-i}$ allows to generalize to a polymorphic type (with a hygiene condition telling us that the type variable we choose isnâ€™t already in the environment).</p>

<p>$\ref{eq:hm-let}$ is fairly straightforward. $\ref{eq:hm-arrow-i}$ and $\ref{eq:hm-arrow-e}$ are simply as in STLC.</p>

<h4 id="alternative-hindley-milner">Alternative Hindley Milner</h4>
<p>A let-in statement can be regarded as shorthand for a substitution:</p>

\[\text{let } x = t \text{ in } t' 
\quad \equiv \quad 
[x\mapsto t] t'\]

<p>We can use this to get a revised Hindley-Milner system which we call HMâ€™, where $\ref{eq:hm-let}$ is replaced by the following:</p>

\[\frac{\Gamma\vdash t: T \quad \Gamma\vdash [x\mapsto t] t' : U}
{\Gamma \vdash \text{let } x = t \text{ in } t': U}
\label{eq:hm-let-prime}\tag{Let'}\]

<p>In essence, it only changes the typing rule for <code class="highlighter-rouge">let</code> so that they perform a step of evaluation before calculating the types. This is equivalent to the previous HM system; weâ€™ll state that as a theorem, without proof.</p>

<p><strong>Theorem</strong>: $\Gamma\vdash_{\text{HM}} t: S \iff \Gamma\vdash_{\text{HM}â€™} t: S$</p>

<p>The corollary to this theorem is that, if we let $t^*$ be the result of expanding all <code class="highlighter-rouge">let</code>s in $t$ using the substitution above, then:</p>

\[\Gamma\vdash_{\text{HM}} t: T \Longrightarrow \Gamma\vdash_{F_1} t^* : T\]

<p>The converse is true if every let-bound name is used at least once:</p>

\[\Gamma\vdash_{\text{HM}} t: T \Longleftarrow \Gamma\vdash_{F_1} t^* : T\]

<h3 id="principal-types">Principal types</h3>
<p>We <a href="#unification">previously remarked</a> that there is a most general unifier, which instantiates the type variables in the most general way, the <em>principal</em> way. Principal types are a small formalization of this idea.</p>

<p>A type $T$ is a <strong>generic instance</strong> of a type scheme $S = \forall \alpha_1.\  \dots \forall \alpha_n.\ Tâ€™$ if there is a substitution $s$ on $\alpha_1, \dots, \alpha_n$ such that $T = sTâ€™$. In this case, we write $S \le T$.</p>

<p>A type scheme $Sâ€™$ is a <strong>generic instance</strong> of a type scheme $S$ iff for all types $T$:</p>

\[S' \le T \implies S \le T\]

<p>In this case, we write $S \le Sâ€™$.</p>

<p>A type scheme $S$ is <strong>principal</strong> (or <em>most general</em>) for $\Gamma$ and $t$ iff:</p>

<ul>
  <li>$\Gamma\vdash t: S$</li>
  <li>$\Gamma\vdash t: Sâ€™ \implies S \le Sâ€™$</li>
</ul>

<p>A type system TS has the <strong>principal typing property</strong> iff, whenever $\Gamma\vdash_{\text{TS}} t: S$, there exists a principal type scheme for $\Gamma$ and $t$.</p>

<p>In other words, a type system with principal types is one where the type engine doesnâ€™t make any choices; it always finds the most general solution. The type checker may fail if it cannot advance without making a choice (e.g. for $\lambda x. x+x$, where the typechecker would have to choose between $\text{Int} \rightarrow \text{Int}$, $\text{Float} \rightarrow \text{Float}$, etc).</p>

<p>The following can be stated as a theorem:</p>

<ol>
  <li>HMâ€™ without <code class="highlighter-rouge">let</code> has the principal typing property</li>
  <li>HMâ€™ with <code class="highlighter-rouge">let</code> has the principal typing property</li>
  <li>HM has the principal typing property</li>
</ol>

<h2 id="subtyping">Subtyping</h2>

<h3 id="motivation">Motivation</h3>
<p>Under $\ref{eq:t-app}$, the following is not well typed:</p>

\[(\lambda r.\ \set{x: \text{Nat}}.\ r.\!x)\ \set{x=0, y=1}\]

<p>Weâ€™re passing a record to a function that selects its <code class="highlighter-rouge">x</code> member. This is not well typed, but would still evaluate just fine; after all, weâ€™re passing the function a <em>better</em> argument than it needs.</p>

<p>In general, weâ€™d like to be able to define hierarchies of classes, with descendants having richer interfaces. These should still be usable instead of their ancestors. We solve this using subtyping.</p>

<p>We achieve this by introducing a subtyping relation $S &lt;: T$, and a <strong>subsumption rule</strong>:</p>

\[\frac{\Gamma\vdash t: S \quad S &lt;: T}{\Gamma\vdash t: T}
\label{eq:t-sub}\tag{T-Sub}\]

<p>This rule tells us that if $S &lt;: T$, then any value of type $S$ can also be regarded as having type $T$. With this rule in place, we just need to define the rules for when we can assert $S &lt;: T$.</p>

<h3 id="rules">Rules</h3>

<h4 id="general-rules">General rules</h4>
<p>Subtyping is reflective and transitive:</p>

\[\begin{align}
S &lt;: S
\label{eq:s-refl}\tag{S-Refl} \\ \\

\frac{S &lt;: U \quad U &lt;: T}{S &lt;: T}
\label{eq:s-trans}\tag{S-Trans} \\ \\
\end{align}\]

<h4 id="records-1">Records</h4>
<p>To solve our previous example, we can introduce subtyping between record types:</p>

\[\set{x: \text{Nat}, y: \text{Nat}} &lt;: \set{x: \text{Nat}}\]

<p>Using $\ref{eq:t-sub}$, we can see that our example is now well-typed. Of course, the subtyping rule we introduced here is too specific; we need something more general. We can do this by introducing three rules for subtyping of record types:</p>

\[\begin{align}
\set{l_i: {T_i}^{i\in 1\dots n+k}} &lt;: \set{l_i: {T_i}^{i\in 1\dots n}}
\label{eq:s-rcdwidth}\tag{S-RcdWidth} \\ \\

\frac{
    \set{k_j : {S_j}^{j\in 1 \dots n}} \text{ is a permutation of } \set{l_i : {T_i}^{i\in 1 \dots n}}
}{
    \set{k_j : {S_j}^{j\in 1 \dots n}} &lt;: \set{l_i : {T_i}^{i\in 1 \dots n}}
}
\label{eq:s-rcdperm}\tag{S-RcdPerm} \\ \\


\frac{
    \forall i \ S_i &lt;: T_i
}{
    \set{l_i : {S_i}^{i\in 1\dots n}} &lt;: \set{l_i: {T_i}^{i\in 1\dots n}}
}
\label{eq:s-rcddepth}\tag{S-RcdDepth} \\ \\
\end{align}\]

<p>$\ref{eq:s-rcdwidth}$ tells us that a record is a supertype of a record with additional fields to the right. Intuitively, the reason that the record <em>more</em> fields is a <em>subtype</em> of the record with fewer fields is because it places a stronger constraint on values, and thus describes fewer values (think of the Venn diagram of possible values).</p>

<p>Of course, adding fields to the right only is not strong enough of a rule, as order in a record shouldnâ€™t matter. We fix this with $\ref{eq:s-rcdperm}$, which allows us to reorder the record so that all additional fields are on the right: $\ref{eq:s-rcdperm}$, $\ref{eq:s-rcdwidth}$ and $\ref{eq:s-trans}$ allows us to drop arbitrary fields within records.</p>

<p>Finally, $\ref{eq:s-rcddepth}$ allows for the types of individual fields to be subtypes of the supertype recordâ€™s fields.</p>

<p>Note that real languages often choose not to adopt these <a href="#aside-structural-vs-declared-subtyping">structural record subtyping</a> rules. For instance, Java has no depth subtyping (a subclass may not change the argument or result types of a method of its superclass), no permutation for classes (single inheritance means that each member can be assigned a single index; new members can be added as new indices â€œon the rightâ€), but has permutation for interfaces (multiple inheritance of interfaces is allowed).</p>

<h4 id="arrow-types">Arrow types</h4>
<p>Function types are contravariant in the argument and covariant in the return type. The rule is therefore:</p>

\[\frac{T_1 &lt;: S_1 \quad S_2 &lt;: T_2}{S_1 \rightarrow S_2 &lt;: T_1 \rightarrow T_2}
\label{eq:s-arrow}\tag{S-Arrow}\]

<h4 id="top-type">Top type</h4>
<p>For convenience, we have a top type that everything can be a subtype of. In Java, this corresponds to <code class="highlighter-rouge">Object</code>.</p>

\[S &lt;: \text{Top}
\label{eq:s-top}\tag{S-Top}\]

<h4 id="aside-structural-vs-declared-subtyping">Aside: structural vs. declared subtyping</h4>
<p>The <a href="#records-1">subtype relation we defined for records</a> is <em>structural</em>: we decide whether $S$ is a subtype of $T$ by examining the structure of $S$ and $T$. By contrast, most OO languages (e.g. Java) use <em>declared</em> subtyping: $S$ is only a subtype of $T$ if the programmer has stated that it should be (with <code class="highlighter-rouge">extends</code> or <code class="highlighter-rouge">implements</code>).</p>

<p>Weâ€™ll come back to this when we talk about <a href="#featherweight-java">Featherweight Java</a>.</p>

<h3 id="properties-of-subtyping">Properties of subtyping</h3>

<h4 id="safety-1">Safety</h4>
<p>The problem with subtyping is that it changes how we do proofs. They become a bit more involved, as the typing relation is no longer syntax directed; when weâ€™re proving things, we need to start making choices, as the rule $\ref{eq:t-sub}$ could appear anywhere. Still, the proofs are possible.</p>

<h4 id="inversion-lemma-for-subtyping">Inversion lemma for subtyping</h4>
<p>Before we can prove safety and preservation, weâ€™ll introduce the inversion lemma for subtyping.</p>

<p><strong>Inversion Lemma</strong>: If $U &lt;: T_1 \rightarrow T_2$, then $U$ has the form $U_1 \rightarrow U_2$ with $T_1 &lt;: U_1$ and $U_2 &lt;: T_2$.</p>

<p>The proof is by induction on subtyping derivations:</p>

<ul>
  <li>Case $\ref{eq:s-arrow}$, $U=U_1 \rightarrow U_2$: immediate, as $U$ already has the correct form, and as we can deduce $T_1 &lt;: U_1$ and $U_2 &lt;: T_2$ from $\ref{eq:s-arrow}$.</li>
  <li>Case $\ref{eq:s-refl}$, $U=T_1 \rightarrow T_2$: by applying $\ref{eq:s-refl}$ twice, we get $T_1 &lt;: T_1$ and $T_2 &lt;: T_2$, as required.</li>
  <li>
    <p>Case $\ref{eq:s-trans}$, $U &lt;: W$ and $W &lt;: T_1 \rightarrow T_2$</p>

    <p>By the IH on the second subderivation, we find that $W$ has the form $W_1 \rightarrow W_2$ with $T_1 &lt;: W_1$ and $W_2 &lt;: T_2$.</p>

    <p>Applying the IH again to the first subderivation, we find that $U$ has the form $U_1 \rightarrow U_2$ with $W_1 &lt;: U_1$ and $U_2 &lt;: W_2$</p>

    <p>By $\ref{eq:s-trans}$, we get $T_1 &lt;: U_1$, and by $\ref{eq:s-trans}$ again, $U_2 &lt;: T_2$ as required</p>
  </li>
</ul>

<h4 id="inversion-lemma-for-typing">Inversion lemma for typing</h4>
<p>Weâ€™ll introduce another lemma, but this time for typing (not subtyping):</p>

<p><strong>Iversion lemma</strong>: if $\Gamma\vdash\lambda x: S_1. s_2 : T_1 \rightarrow T_2$, then $T_1 &lt;: S_1$ and $\Gamma\cup(x: S_1)\vdash s_2: T_2$.</p>

<p>Again, the proof is by induction on typing derivations:</p>

<ul>
  <li>Case $\ref{eq:t-abs}$, where $T_1 = S_1$, $T_2 = S_2$ and $\Gamma\cup(x: S_1)\vdash s_2 : S_2$: the result is immediate (using $\ref{eq:s-refl}$ to get $T_1 &lt;: S_1$ from $T_1 = S_1$).</li>
  <li>
    <p>Case $\ref{eq:t-sub}$, $\Gamma\vdash\lambda x: X_1.\ s_2: U$ and $U &lt;: T_1 \rightarrow T_2$</p>

    <p>By the <a href="#inversion-lemma-for-subtyping">inversion lemma for subtyping</a>, we have $U = U_1 \rightarrow U_2$, with $T_1 &lt;: U_1$ and $U_2 &lt;: T_2$.</p>

    <p>By the IH, we then have $U_1 &lt;: S_1$ and $\Gamma\cup(x: S_1)\vdash s_2 : U_2$.</p>

    <p>We can apply $\ref{eq:s-trans}$ to $U_1 &lt;: S_1$ and $T_1 &lt;: U_1$ to get $T_1 &lt;: S_1$.</p>

    <p>We can apply $\ref{eq:t-sub}$ to the assumptions that $\Gamma\cup(x: S_1)\vdash s_2: U_2$ and $U_2 &lt;: T_2$ to conclude $\Gamma\cup(x: S_1)\vdash s_2: T_2$</p>
  </li>
</ul>

<h4 id="preservation-1">Preservation</h4>
<p>Remember that preservation states that if $\Gamma\vdash t: T$ and $t\longrightarrow tâ€™$ then $\Gamma\vdash tâ€™: T$.</p>

<p>The proof is by induction on typing derivations:</p>

<ul>
  <li>
    <p>Case $\ref{eq:t-sub}$: $t: S$ and $S &lt;: T$.</p>

    <p>By the IH, $\Gamma\vdash tâ€™: S$.</p>

    <p>By $\ref{eq:t-sub}$, $\Gamma\vdash t: T$.</p>
  </li>
  <li>
    <p>Case $\ref{eq:t-app}$: $t = t_1\ t_2$, $\Gamma\vdash t_1: T_{11} \rightarrow T_{12}$, $\Gamma\vdash t_2: T_{11}$ and $T = T_{12}$. By the inversion lemma for evaluation<sup id="fnref:inversion-lemma-evaluation-lambda" role="doc-noteref"><a href="#fn:inversion-lemma-evaluation-lambda" class="footnote">3</a></sup>, there are three rules by which $t\longrightarrow tâ€™$ can be derived:</p>
    <ul>
      <li>Subcase $\ref{eq:e-app1}$: $t_1 \longrightarrow t_1â€™$ and $tâ€™ = t_1â€™\ t_2$. The result follows from the IH and $\ref{eq:t-app}$</li>
      <li>Subcase $\ref{eq:e-app2}$: $t_1 = v_1$, $t_2 \longrightarrow t_2â€™$ and $tâ€™ = v_1\ t_2â€™$. The result follows from the IH and $\ref{eq:t-app}$</li>
      <li>
        <p>Subcase $\ref{eq:e-appabs}$: $t_1 = \lambda x: S_{11}.\ t_{12}$, $t_2 = v_2$ and $tâ€™ = [x\mapsto v_2]t_{12}$.</p>

        <p>By the <a href="#inversion-lemma-for-typing">inversion lemma for typing</a>, $T_{11} &lt;: S_{11}$ and $\Gamma\cup (x: S_{11})\vdash t_{12}: T_{12}$.</p>

        <p>By $\ref{eq:t-sub}$, $\Gamma\vdash t_2: S_{11}$</p>

        <p>By the <a href="#substitution-lemma">substitution lemma</a>, $\Gamma\vdash tâ€™: T_{12}$.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="subtyping-features">Subtyping features</h3>
<h4 id="casting">Casting</h4>
<p>In languages like Java and C++, ascription is a little more interesting than <a href="#ascription">what we previously defined it as</a>. In these languages, ascription serves as a casting operator.</p>

\[\begin{align}
\frac{\Gamma\vdash t_1 : S}{\Gamma\vdash t_1 \text{ as } T : T}
\label{eq:t-cast}\tag{T-Cast} \\ \\

\frac{\vdash_r v_1: T}{v_1 \text{ as } T \longrightarrow v_1}
\label{eq:e-cast}\tag{E-Cast} \\
\end{align}\]

<p>Contrary to $\ref{eq:t-ascribe}$, the $\ref{eq:t-cast}$ rule allows the ascription to be of a different type than the term. This allows the programmer to have an escape hatch, and get around the type checker. However, this <em>laissez-faire</em> solution means that a run-time check is necessary, as $\ref{eq:e-cast}$ shows.</p>

<h4 id="variants-1">Variants</h4>
<p>The subtyping rules for <a href="#variants">variants</a> are almost identical to those of records, with the main difference being the width rule allows variants to be <em>added</em>, not dropped:</p>

\[\begin{align}
\langle l_i : {T_i}^{i\in 1\dots n} \rangle
&lt;:
\langle l_i : {T_i}^{i\in 1\dots n+k} \rangle
\label{eq:s-variantwidth}\tag{S-VariantWidth} \\ \\

\frac{\forall i \ S_i &lt;: T_i}{
    \langle l_1 : {S_i}^{i\in 1 \dots n} \rangle
    &lt;:
    \langle l_1 : {T_i}^{i\in 1 \dots n} \rangle
} \label{eq:s-variantdepth}\tag{S-VariantDepth} \\ \\

\frac{
    \langle k_j : {S_j}^{j\in 1 \dots n} \rangle
    \text{ is a permutation of }
    \langle l_i : {T_i}^{i\in 1 \dots n} \rangle
}{
    \langle k_j : {S_j}^{j\in 1 \dots n} \rangle
    &lt;:
    \langle l_i : {T_i}^{i\in 1 \dots n} \rangle
}
\label{eq:s-variantperm}\tag{S-VariantPerm} \\ \\

\frac{
    \Gamma\vdash t_1 : T_1
}{
    \Gamma\vdash \langle l_1 = t_1 \rangle : \langle l_1 : T_1 \rangle 
} \label{eq:t-variant}\tag{T-Variant}
\end{align}\]

<p>The intuition for $\ref{eq:s-variantwidth}$ is that a tagged expression $\langle l = t \rangle$ belongs to a variant type $\langle l_i : {T_i}^{i\in 1\dots n} \rangle$ if the label $l$ is <em>one of the possible labels</em> $\set{l_i}$. This is easy to understand if we consider the <a href="#variants"><code class="highlighter-rouge">Option</code> example that we used previously</a>: <code class="highlighter-rouge">some</code> and <code class="highlighter-rouge">none</code> are subtypes of <code class="highlighter-rouge">Option</code>.</p>

<h4 id="covariance">Covariance</h4>
<p><code class="highlighter-rouge">List</code> is an example of a covariant type constructor: we want <code class="highlighter-rouge">List[None]</code> to be a subtype of <code class="highlighter-rouge">List[Option]</code>.</p>

\[\frac{S_1 &lt;: T_1}{\text{List } S_1 &lt;: \text{List } T_1}
\label{eq:s-list}\tag{S-List}\]

<h4 id="invariance">Invariance</h4>
<p>References are not covariant nor invariant. An example of an invariant constructor is a <a href="#references">reference</a>.</p>

<ul>
  <li>When a reference is <em>read</em>, the context expects $T_1$ so giving a $S_1 &lt;: T_1$ is fine</li>
  <li>When a reference is <em>written</em>, the context provides a $T_1$. If the the actual type of the reference is $\text{Ref } S_1$, someone may later use the $T_1$ as an $S_1$, so we need $T_1 &lt;: S_1$</li>
</ul>

<p>Similarly, arrays are invariant, for the same reason:</p>

\[\frac{S_1 &lt;: T_1 \quad T_1 &lt;: S_1}{\text{Array } S_1 &lt;: \text{Array } T_1}
\label{eq:s-array}\tag{S-Array}\]

<p>Instead, Java has covariant arrays:</p>

\[\frac{S_1 &lt;: T_1}{\text{Array } S_1 &lt;: \text{Array } T_1}
\label{eq:s-arrayjava}\tag{S-ArrayJava}\]

<p>This is because the Java language designers felt that they needed to be able to write a sort routine for mutable arrays, and implemented this as a quick fix. Instead, it turned out to be a mistake that even the Java designers regret.</p>

<p>The solution to this invariance problem is based on the following observation: a <code class="highlighter-rouge">Ref T</code> can be used either for reading or writing. To be able to have contravariant reading and covariant writing, we can split a <code class="highlighter-rouge">Ref T</code> in three:</p>

<ul>
  <li><code class="highlighter-rouge">Source T</code>: a reference with read capability</li>
  <li><code class="highlighter-rouge">Sink T</code>: a reference cell with write capability</li>
  <li><code class="highlighter-rouge">Ref T</code>: a reference cell with both capabilities</li>
</ul>

<p>The typing rules then limit dereference to sources, and assignment to sinks:</p>

\[\begin{align}
\frac{
    \Gamma \mid \Sigma \vdash t_1 : \text{Source } T_{11}
}{
    \Gamma \mid \Sigma \vdash !t_1 : T_{11}
} \label{eq:t-derefsource}\tag{T-DerefSource} \\ \\

\frac{
    \Gamma \mid \Sigma \vdash t_1 : \text{Sink } T_{11}
    \quad 
    \Gamma \mid \Sigma \vdash t_2 : T_{11}
}{
    \Gamma \mid \Sigma \vdash t_1 := t_2 : \text{Unit}
}
\label{eq:t-assignsink}\tag{T-AssignSink} \\
\end{align}\]

<p>The subtyping rules establish sources as covariant constructors, sinks as contravariant, and a reference as a subtype of both:</p>

\[\begin{align}
\frac{S_1 &lt;: T_1}{\text{Source } S_1 &lt;: \text{Source } T_1}
\label{eq:s-source}\tag{S-Source} \\ \\

\frac{T_1 &lt;: S_1}{\text{Sink } S_1 &lt;: \text{Sink } T_1}
\label{eq:s-sink}\tag{S-Sink} \\ \\

\text{Ref } T_1 &lt;: \text{Source } T_1
\label{eq:s-refsource}\tag{S-RefSource} \\ \\

\text{Ref } T_1 &lt;: \text{Sink } T_1
\label{eq:s-refsink}\tag{S-RefSink} \\
\end{align}\]

<h3 id="algorithmic-subtyping">Algorithmic subtyping</h3>
<p>So far, in STLC, our typing rules were <em>syntax directed</em>. This means that for every for every form of a term, a specific rule applied; which rule to choose was always straightforward.</p>

<p>The reason the choice is so straightforward is because we can divide the positions of a typing relation like $\ref{eq:t-app}$ into input positions ($\Gamma$ and $t$), and output positions ($T_{11}$, $T_{12}$).</p>

<p>However, by introducing subtyping, we introduced rules that break this: $\ref{eq:t-sub}$ and $\ref{eq:s-trans}$ apply to <em>any</em> kind of term, and can appear at any point of a derivation. Every time our type checking algorithm encounters a term, it must decide which rule to apply. $\ref{eq:s-trans}$ also introduces the problem of having to pick an intermediary type $U$ (which is neither an input nor an output position), for which there can be multiple choices. $\ref{eq:s-refl}$ also overlaps with the conclusions of other rules, although this is a less severe problem.</p>

<p>But this excess flexibility isnâ€™t strictly needed; we donâ€™t need 1000 ways to prove a given typing or subtyping statement, one is enough. The solution to these problems is to replace the ordinary, <em>declarative</em> typing and subtyping relations with <em>algorithmic</em> relations, whose sets of rules are syntax directed. This implies proving that the algorithmic relations are equivalent to the original ones, that subsumption, transitivity and reflexivity are consequences of our algorithmic rules.</p>

<h2 id="objects">Objects</h2>
<p>For simple objects and classes, we can easily use a translational analysis, converting ideas like dynamic dispatch, state, inheritance, into derived forms from lambda calculus such as (higher-order) functions, records, references, recursion, subtyping. However, for more complex features (like <code class="highlighter-rouge">this</code>), weâ€™ll need a more direct treatment.</p>

<p>In this section, weâ€™ll just identify the core features of object-oriented programming, and propose translations for the simpler features. The more complex features will lead us to defining Featherweight Java.</p>

<h3 id="classes">Classes</h3>
<p>Letâ€™s take a look at an example of a class:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">inc</span><span class="o">()</span> <span class="o">{</span> <span class="n">x</span><span class="o">++;</span> <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To represent this in lambda calculus, we could use a record in a let body:</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre>let x = ref 1 in {
    get = Î»_: Unit. !x
    inc = Î»_: Unit. x := succ(!x)
}
</pre></td></tr></tbody></table></code></pre></figure>

<p>More generally, the state may consist of more than a single reference cell, so we can let the state be represented by a variable <code class="highlighter-rouge">r</code> corresponding to a record with (potentially) multiple fields.</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre>let r = {x = ref 1} in {
    get = Î»_: Unit. !(r.x)
    inc = Î»_: Unit. r.x := succ(!(r.x))
}
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="object-generators">Object generators</h3>
<p>To create a new object, we can just define a function that creates and returns a <code class="highlighter-rouge">Counter</code>:</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre>newCounter = Î»_: Unit. 
    let r = {x = ref 1} in {
        get = Î»_: Unit. !(r.x)
        inc = Î»_: Unit. r.x := succ(!(r.x))
    }
</pre></td></tr></tbody></table></code></pre></figure>

<p>This returns a <code class="highlighter-rouge">newCounter</code> object of type $\text{Unit} \rightarrow \text{Counter}$, where the $\text{Counter}$ type is defined as:</p>

\[\text{Counter} = \set{
    \text{get}: \text{Unit} \rightarrow \text{Nat},\ 
    \text{inc}: \text{Unit}\rightarrow\text{Unit}
}\]

<h3 id="dynamic-dispatch">Dynamic dispatch</h3>
<p>When an operation is invoked on an object, the ensuing behavior depends on the object itself; indeed, two object of the same type may be implemented internally in completely different ways.</p>

<p>For instance, we can define two subclasses doing very different things:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">C</span> <span class="kd">extends</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">10</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here, <code class="highlighter-rouge">(new B()).m()</code> and <code class="highlighter-rouge">(new C()).m()</code> have different results.</p>

<p>Dynamic dispatch is a kind of <em>late binding</em> for function calls. Rather than construct the binding from call to function at compile-time, the idea in dynamic dispatch is to bind at runtime.</p>

<h3 id="encapsulation">Encapsulation</h3>
<p>In most OO languages, each object consists of some internal state. The state is directly accessible to the methods, but inaccessible from the outside.In Java, the encapsulation can be enabled with <code class="highlighter-rouge">protected</code>, which allows for a sort of information hiding.</p>

<p>The type of an object is just the set of operations that can be performed on it. It doesnâ€™t include the internal state.</p>

<h3 id="inheritance-and-subtyping">Inheritance and subtyping</h3>
<p>Subtyping is a way to talk about types. Inheritance is more focused on the idea of sharing behavior, on avoiding duplication of code.</p>

<p>The basic mechanism of inheritance is classes, which can be:</p>

<ul>
  <li><strong>instantiated</strong> to create new objects (â€œinstancesâ€), <em>or</em></li>
  <li><strong>refined</strong> to create new classes (â€œsubclassesâ€). Subclasses are subtypes of their parent classes.</li>
</ul>

<p>When we refine a class, itâ€™s usually to add methods to it. We saw previously that a record A with more fields than B is a subtype of B; letâ€™s try to extend that behavior to objects.</p>

<p>As an example, letâ€™s try to look at a <code class="highlighter-rouge">ResetCounter</code> inheriting from <code class="highlighter-rouge">Counter</code>, adding a <code class="highlighter-rouge">reset</code> method that sets <code class="highlighter-rouge">x</code> to 1. In Java, weâ€™d do this as follows:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">x</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">ResetCounter</span> <span class="kd">extends</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">reset</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>How can we implement <code class="highlighter-rouge">ResetCounter</code> in lambda calculus? Initially, we can just try to do this by coping the <code class="highlighter-rouge">Counter</code> body into a new object <code class="highlighter-rouge">ResetCounter</code>, and add a <code class="highlighter-rouge">reset</code> method:</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>newResetCounter =
    Î»_: Unit. let r = {x = ref 1} in {
        get   = Î»_: Unit. !(r.x),
        inc   = Î»_: Unit. r.x := succ(!(r.x)),
        reset = Î»_: Unit. r.x := 1
    }
</pre></td></tr></tbody></table></code></pre></figure>

<p>But this goes against the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principle</a> from software engineering.</p>

<p>Another thing that we could try is to take a <code class="highlighter-rouge">Counter</code> as an argument in the <code class="highlighter-rouge">ResetCounter</code> object generator:</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>resetCounterFromCounter = Î»c. Counter. 
    let r = {x = ref 1} in {
        get   = c.get,
        inc   = c.inc,
        reset = Î»_: Unit. r.x := 1
    }
</pre></td></tr></tbody></table></code></pre></figure>

<p>However, this is problematic because weâ€™re not sharing the state; weâ€™ve got two separate counts in <code class="highlighter-rouge">Counter</code> and <code class="highlighter-rouge">ResetCounter</code>, and they cannot access each otherâ€™s state.</p>

<p>To solve this, we must separate the method definition from the object generator. To do this, we can use the age-old computer science adage of â€œevery problem can be solved with an additional level of indirectionâ€.</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>counterClass = Î»r: CounterState. {
    get = Î»_: Unit. !(r.x),
    inc = Î»_: Unit. r.x := succ(!(r.x))
};

newCounter = Î»_: Unit. 
    let r = {x = ref 1} in counterClass r;
</pre></td></tr></tbody></table></code></pre></figure>

<p>To define the subclass, weâ€™ll first have to introduce the notion of <code class="highlighter-rouge">super</code>. We know this construct from Java, among others. Javaâ€™s <code class="highlighter-rouge">super</code> gives us a mechanism to avoid dynamic dispatch, since we <em>specifically</em> call the method in the superclass we inherit from.</p>

<p>For the subclass, the idea is to instantiate the <code class="highlighter-rouge">super</code>, and bind the methods of the object to the <code class="highlighter-rouge">super</code>â€™s methods. The classes both have access to the same value through the use of references.</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>resetCounterClass = Î»r: CounterState.
    let super = counterClass r in {
        get   = super.get,
        inc   = super.inc,
        reset = Î»_: Unit. r.x := 1
    };

newResetCounter = Î»_: Unit.
    let r = {x = ref 1} in resetCounterClass r;
</pre></td></tr></tbody></table></code></pre></figure>

<p>This also allows us to call <code class="highlighter-rouge">super</code> in added or redefined methods (so <code class="highlighter-rouge">reset</code> could call <code class="highlighter-rouge">super.inc</code> if it needed to, or we could redefine <code class="highlighter-rouge">inc</code> to add functionality around <code class="highlighter-rouge">super.inc</code>).</p>

<p>Our state record <code class="highlighter-rouge">r</code> can even contain more variable than the superclass needs, as records with more fields are subtypes of those with a subset of fields. This allows us to have more instance variables in the subclass.</p>

<p>Note that if we wanted to be more rigorous, weâ€™d have to define this more precisely. In STLC, weâ€™ve defined records through <em>structural subtyping</em>. But most object-oriented languages use <em>nominal subtyping</em>, where things arenâ€™t subtypes of each other just because they have the same methods, but because we declare them to be so. Weâ€™ll see <a href="#structural-vs-nominal-type-systems">more on this later</a>.</p>

<h3 id="this">This</h3>
<p>Above, we saw how to call methods from the parent class through <code class="highlighter-rouge">super</code>. To call methods between each other, we need to add <code class="highlighter-rouge">this</code>.</p>

<p>Letâ€™s consider the following class as an example:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="kd">class</span> <span class="nc">SetCounter</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">inc</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This example may be a little simplistic, but in practice, itâ€™s very useful to be able to use other methods within the same class.</p>

<p>In an initial attempt at implementing this in lambda calculus, we can add a fix operator to the class definition, so that we can call ourselves:</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>setCounterClass = Î»r: CounterState. 
    fix (Î»this: SetCounter. {
        get = Î»_: Unit. !(r.x),
        set = Î»i: Nat.  r.x := i,
        int = Î»_: Unit. this.set (succ (this.get unit))
    });
</pre></td></tr></tbody></table></code></pre></figure>

<p>As a small sanity check, we pass a $\text{SetCounter} \longrightarrow \text{SetCounter}$ type to <code class="highlighter-rouge">fix</code> operation, so the resulting type is indeed $\text{SetCounter}$.</p>

<p>We have â€œtied the knotâ€ by using the <code class="highlighter-rouge">fix</code> operator, which arranges for the very record we built to also be passed as <code class="highlighter-rouge">this</code>.</p>

<p>But this does not model the behavior of <code class="highlighter-rouge">this</code> in most object-oriented languages, which support a more general form of recursive call between methods, known as <em>open recursion</em>. This allows the methods of a superclass to call the methods of a subclass through <code class="highlighter-rouge">this</code>.</p>

<p>The problem here is that the fixed point operation is â€œclosedâ€: it only gives us the exact set we built in <code class="highlighter-rouge">this</code>, and isnâ€™t open to extension. To solve this, we can move the application of <code class="highlighter-rouge">fix</code> from the class definition to the object creation function (essentially switching the order of <code class="highlighter-rouge">fix</code> and <code class="highlighter-rouge">Î»r: CounterState</code>):</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>setCounterClass = Î»r: CounterState. 
    Î»this: SetCounter. {
        get = Î»_: Unit. !(r.x),
        set = Î»i: Nat.  r.x := i,
        int = Î»_: Unit. this.set (succ (this.get unit))
    };

newSetCounter = Î»_: Unit.
    let r = {x = ref 1} in fix (setCounterClass r);
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that this changes the type signature of the class, which goes from:</p>

\[\text{SetCounterClass}: \text{CounterState} \longrightarrow \text{SetCounter}\]

<p>To the following:</p>

\[\text{SetCounterClass}: 
    \text{CounterState} \longrightarrow 
    \text{SetCounter} \longrightarrow 
    \text{SetCounter}\]

<p>But passing it the state, and passing that to <code class="highlighter-rouge">fix</code> does indeed give us a $\text{SetCounter}$ type, so our constructor returns the expected type.</p>

<h3 id="using-this">Using <code class="highlighter-rouge">this</code></h3>
<p>Letâ€™s continue the example from above by defining a new class of counter object, keeping count of the number of times <code class="highlighter-rouge">set</code> has been called. Weâ€™ll call this an â€œinstrumented counterâ€ <code class="highlighter-rouge">InstrCounter</code>, extending the <code class="highlighter-rouge">SetCounter</code> we defined above:</p>

<figure class="highlight"><pre><code class="language-plain" data-lang="plain"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>InstrCounter = {
    get: Unit -&gt; Nat,
    set: Nat  -&gt; Unit,
    inc: Unit -&gt; Unit
    accesses: Unit -&gt; Nat
};

IntrCounterState = {
    x: Ref Nat,
    a: Ref Nat
};

instrCounterClass = Î»r: InstrCounterState. Î»this: InstrCounter.
    let super = setCounterClass r this in {
        get = super.get,
        set = Î»i: Nat. (
            r.a := succ(!(r.a));
            super.set i
        ),
        inc = super.inc,
        accesses = Î»_: Unit. !(r.a)
    };

newInstrCounter = Î»_: Unit. 
    let r = {x = ref 1, a = ref 0} in fix (instrCounterClass r);
</pre></td></tr></tbody></table></code></pre></figure>

<p>A few notes about this implementation:</p>

<ul>
  <li>The methods use <code class="highlighter-rouge">this</code> (passed as a parameter) and <code class="highlighter-rouge">super</code> (constructed using <code class="highlighter-rouge">this</code> and the state variable <code class="highlighter-rouge">r</code>)</li>
  <li>Because we allow for open recursion, the <code class="highlighter-rouge">inc</code> in <code class="highlighter-rouge">super</code> calls the <code class="highlighter-rouge">set</code> defined here, which calls the <code class="highlighter-rouge">super.set</code></li>
</ul>

<p>But this implementation is not very useful, as the object creator diverges! Intuitively, the problem is that the â€œunprotectedâ€ use of <code class="highlighter-rouge">this</code>. The argument that we pass to <code class="highlighter-rouge">fix</code> uses its own argument (<code class="highlighter-rouge">this</code>) too early; in general, to create fixed points abstractions that donâ€™t diverge, the assumption is that one should only use the argument in â€œprotectedâ€ locations, such as in the bodies of inner lambda abstractions.</p>

<p>A solution is to â€œdelayâ€ this by putting a dummy abstraction in front of it:</p>

<figure class="highlight"><pre><code class="language-stlc" data-lang="stlc"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>setCounterClass = Î»r: CounterState. 
    Î»this: Unit -&gt; SetCounter.
        Î»_: Unit. {
            get = Î»_: Unit. !(r.x),
            set = Î»i: Nat.  r.x := i,
            int = Î»_: Unit. this.set (succ (this.get unit))
        };
</pre></td></tr></tbody></table></code></pre></figure>

<p>This essentially replaces call-by-value with call-by-name. Now, <code class="highlighter-rouge">this</code> is of type $\text{Unit} \rightarrow \text{SetCounter}$.</p>

<p>This works, but very slowly. All the delaying we added has a side effect. Instead of computing the method table just once, we now re-compute it every time we invoke a method. Indeed, every time we need it, since weâ€™re in call-by-name, we re-compute it every time.</p>

<p>The solution here is to use lazy values, which we can represent in lambda calculus as a reference, along with a flag about whether weâ€™ve computed it or not. Section 18.12 describes this in more detail.</p>

<h2 id="featherweight-java">Featherweight Java</h2>

<p>Weâ€™ve now covered the essence of objects, but there are still certain things missing compared to Java. With objects, weâ€™ve captured the runtime aspect of classes, but we havenâ€™t really talked about the classes as types.</p>

<p>Weâ€™re also missing a discussion on:</p>

<ul>
  <li>Named types with declared subtyping (weâ€™ve only done structural subtyping)</li>
  <li>Recursive types, like the ones we need for list tails, for instance</li>
  <li>Run-time type analysis:  most type systems have escape hatches known as casts, which we havenâ€™t talked about</li>
  <li>Many other things</li>
</ul>

<p>Seeing that we have plenty to talk about, letâ€™s try to define a model for Java. A model always abstracts details away, so thereâ€™s no such thing as a perfect model. Itâ€™s always a question of which trade-offs we choose for our specific use-case.</p>

<p>Java is used for a lot of different purposes, so we are going to have lots of different models. For instance, some of the choices we need to make are:</p>

<ul>
  <li>Source-level vs. bytecode level</li>
  <li>Large (inclusive) vs small (simple) models</li>
  <li>Type system vs. run-time</li>
  <li>Models of specific features</li>
</ul>

<p>Featherweight Java was proposed as a tool for analyzing GJ (Java with generics), and has since been used to study proposed Java extensions. It aims to be very simple, modeling just the core OO features and their types, <em>and nothing else</em>. It models:</p>

<ul>
  <li>Classes and objects,</li>
  <li>Method and method invocation,</li>
  <li>Fields and field access,</li>
  <li>Inheritance (including open recursion through <code class="highlighter-rouge">this</code>)</li>
  <li>Casting</li>
</ul>

<p>It leaves out more complex topics such as reflection, concurrency, exceptions, loops, assignment (!) and overloading.</p>

<p>The model aims to be very explicit, and simple. To maintain this simplicity, it imposes some conventions:</p>

<ul>
  <li>Every class must declare a superclass</li>
  <li>All classes must have a constructor</li>
  <li>All fields must be represented 1-to-1 in the constructor
    <ul>
      <li>It takes the same number of parameters of fields of the class</li>
      <li>It assigns constructor parameters to local fields</li>
      <li>Calls <code class="highlighter-rouge">super</code> constructor to assign remaining fields</li>
      <li>Nothing else!</li>
    </ul>
  </li>
  <li>The constructor must call <code class="highlighter-rouge">super()</code></li>
  <li>Always explicitly name receiver object in method invocation or field access (using <code class="highlighter-rouge">this.x</code> or <code class="highlighter-rouge">that.x</code>)</li>
  <li>Methods are just a single <code class="highlighter-rouge">return</code> expression</li>
</ul>

<h3 id="structural-vs-nominal-type-systems">Structural vs. Nominal type systems</h3>

<p>Thereâ€™s a big dichotomy in the world of programming languages.</p>

<p>On one hand, we have <em>structural</em> type systems, where the names are convenient but inessential abbreviations of types. What really matters about a type in a structural type system is its structure. Itâ€™s somewhat cleaner and more elegant, easier to extend, but once we need to talk about recursive types, some of the elegance falls away. Examples include Haskell, Go and TypeScript.</p>

<p>On the other hand, whatâ€™s used in almost all mainstream programming languages is <em>nominal</em> type systems. Here, recursive types are much simpler, and using names everywhere makes type checking much simpler. Having named types is also useful at run-time for casting, type testing, reflection, etc. Examples include Java, C++, C# and Kotlin.</p>

<h3 id="representing-objects">Representing objects</h3>
<p>How can we represent an object? What defines it? Two objects are different if their constructors are different, or if their constructors have been passed different arguments. This observation leads us to the idea that we can identify an object fully by looking at the <code class="highlighter-rouge">new</code> expression. Here, having omitted assignments makes our life much easier.</p>

<h3 id="syntax">Syntax</h3>
<p>The syntax of Featherweight Java is:</p>

\[\begin{align}
t ::= &amp;                        &amp; \textbf{terms} \\
      &amp; x                      &amp; \text{variable} \\
      &amp; t.\!f                  &amp; \text{field access} \\
      &amp; t.\!m(\bar{t})           &amp; \text{method invocation} \\
      &amp; \text{new } C(\bar{t}) &amp; \text{object creation} \\
      &amp; (C)\ t                 &amp; \text{cast} \\
\\
v ::= &amp;                        &amp; \textbf{values} \\
      &amp; \text{new } C(\bar{v}) &amp; \text{object creation} \\
\\
K ::= &amp; &amp; \textbf{constructor declarations} \\
      &amp; C(\bar{C}\ \bar{f})\ \set{\text{super}(\bar{f});\ \text{this}.\!\bar{f}=\bar{f};} &amp; \\
\\
M ::= &amp; &amp; \textbf{method declarations} \\
      &amp; C\ m(\bar{C}\ \bar{x}) \set{\text{return } t;} \\
\\
CL ::= &amp; &amp; \textbf{class declarations} \\
       &amp; \text{class } C \text{ extends } C\ \set{\bar{C}\ \bar{f};\ K\ \bar{M}} \\
\end{align}\]

<p>Above and in the following, we use the following metavariables:</p>

<ul>
  <li>$A$, $B$, $C$, $D$, $E$ for class names</li>
  <li>$f$, $g$ for field names</li>
  <li>$x$ for parameter names</li>
  <li>$s$, $t$ for terms</li>
  <li>$u$, $v$ for values</li>
  <li>$K$ for constructor declarations</li>
  <li>$M$ for method declarations</li>
</ul>

<p>Weâ€™ll use the notation $\bar{C}$ to mean arbitrary repetition $C_1, \dots, C_n$ of $C$, and similarly for $\bar{f}, \bar{x}, \bar{t}$, etc. For method declaration, $\bar{M}$ means $M_1 \dots M_n$ (no commas).</p>

<p>The notation $\bar{C}\ \bar{f}$ means weâ€™ve â€œzippedâ€ the two together: $C_1\ f_1, \dots, C_n\Â f_n$.</p>

<p>Similarly, $\text{this}.\!\bar{f}=\bar{f}$ means $\text{this}. \! f_1 = f_1; \dots; \text{this}. \! f_n = f_n$</p>

<h3 id="subtyping-1">Subtyping</h3>
<p>Java is a nominal type system, so subtyping in FJ is <em>declared</em>. This means that in addition to two properties for reflexion and transitivity, the subtyping relationship is given by the declared superclass.</p>

\[\begin{align}
C &lt;: C
\\ \\
\frac{C &lt;: D \quad D &lt;: E}{C &lt;: E}
\\ \\
\frac{\text{CT}(C) = \text{class } C \text{ extends } D \set{\dots}}{C &lt;: D}
\end{align}\]

<p>We assume to have a <em>class table</em> $\text{CT}$, mapping class names to their definition.</p>

<h3 id="auxiliary-definitions">Auxiliary definitions</h3>
<p>We can glean a lot of useful properties from the definition in the class table, so itâ€™ll come in handy for evaluation and typing.</p>

<p>We said earlier that every class needed to define a superclass, but what about <code class="highlighter-rouge">Object</code>? The simplest way to deal with this is to let <code class="highlighter-rouge">Object</code> be an exception, a distinguished class name whose definition does not appear in the class table.</p>

<p>The fields of a class $C$, written $\text{fields}(C)$ is the sequence $\bar{C}\ \bar{f}$ mapping the class to each field. The fields of a class are those defined within it, and those it inherits from the superclasses:</p>

\[\begin{align}
\text{fields}(\text{Object}) = \emptyset 
\\ \\
\frac{
    \text{CT}(C) = \text{class } C \text{ extends } D \set{\bar{C}\ \bar{f}; K\ \bar{M}},
    \quad
    \text{fields}(D) = \bar{D}\ \bar{g}
}{
    \text{fields}(C) = \bar{D}\ \bar{g}, \bar{C}\ \bar{f}
}
\end{align}\]

<p>The type of a method $m$, written $\text{mtype}(m, C)$ is a pair $\bar{B}\rightarrow B$ mapping argument types $\bar{B}$ to a result type $B$ by searching up the chain of superclasses until we find the definition of the method $m$:</p>

\[\begin{align}
\frac{
    \text{CT}(C) = \text{class } C \text{ extends } D \ \set{\bar{C}\ \bar{f}; K\ \bar{M}},
    \quad
    B\ m (\bar{B}\ \bar{x})\ \set{\text{return } t;} \in \bar{M}
}{
    \text{mtype}(m, C) = \bar{B} \rightarrow B
}
\\ \\
\frac{
    \text{CT}(C) = \text{class } C \text{ extends } D \ \set{\bar{C}\ \bar{f}; K\ \bar{M}},
    \quad
    m \text{ is not defined in } \bar{M}
}{
    \text{mtype}(m, C) = \text{mtype}(m, D)
}
\end{align}\]

<p>Method body lookups work in basically the same way. It returns a pair $(\bar{x}, t)$ of parameters $\bar{x}$ and a term $t$ by searching up the chain of superclasses:</p>

\[\begin{align}
\frac{
    \text{CT}(C) = \text{class } C \text{ extends } D \ \set{\bar{C}\ \bar{f}; K\ \bar{M}},
    \quad
    B\ m (\bar{B}\ \bar{x})\ \set{\text{return } t;} \in \bar{M}
}{
    \text{mbody}(m, C) = (\bar{x}, t)
}
\\ \\
\frac{
    \text{CT}(C) = \text{class } C \text{ extends } D \ \set{\bar{C}\ \bar{f}; K\ \bar{M}},
    \quad
    m \text{ is not defined in } \bar{M}
}{
    \text{mbody}(m, C) = \text{mbody}(m, D)
}
\end{align}\]

<p>Featherweight Java also models overriding, so we can define a predicate function $\text{override}(m, D, \bar{C}\rightarrow C_0)$ that checks whether the method $m$ with argument types $\bar{C}$ and result type $C_0$ is overridden in a subclass of $D$:</p>

\[\frac{
    \text{mtype}(m, D) = \bar{D} \rightarrow D_0 
    \implies
    \bar{C} = \bar{D} \land C_0 = D_0
}{
    \text{override}(m, D, \bar{C}\rightarrow C_0)
}\]

<h3 id="evaluation-2">Evaluation</h3>
<p>FJ has three computation rules for field access, method invocation and casting.</p>

\[\begin{align}
\frac{
    \text{fields}(C) = \bar{C}\Â \bar{f}
}{
    (\text{new } C(\bar{v})).\!f_i 
    \longrightarrow
    v_i
}
\tag{E-ProjNew}\label{eq:fj-eprojnew} 
\\ \\
\frac{
    \text{mbody}(m, C) = (\bar{x}, t_0)
}{
    (\text{new } C(\bar{v})).m(\bar{u})
    \longrightarrow
    [\bar{x}\mapsto\bar{u}, \text{this}\mapsto\text{new } C(\bar{v})]t_0
}
\tag{E-InvkNew}\label{eq:fj-e-invknew}
\\ \\
\frac{
    C &lt;: D
}{
    (D)\ (\text{new } C(\bar{v}))
    \longrightarrow
    \text{new } C(\bar{v})
}
\tag{E-CastNew}\label{eq:fj-e-castnew}
\end{align}\]

<p>It also has a bunch of congruence rules:</p>

\[\begin{align}
\frac{
    t_0 \longrightarrow t_0'
}{
    t_0.\!f \longrightarrow t_0'.\!f
} \tag{E-Field}\label{eq:fj-e-field}
\\ \\
\frac{
    t_0 \longrightarrow t_0'
}{
    t_0.\!m(\bar{t}) \longrightarrow t_0'.\!m(\bar{t})
} \tag{E-Invk-Recv}\label{eq:fj-e-invk-recv}
\\ \\
\frac{
    t_i \longrightarrow t_i'
}{
    v_0.\!m(\bar{v}, t_i, \bar{t})
    \longrightarrow
    v_0.\!m(\bar{v}, t_i', \bar{t})
} \tag{E-Invk-Arg}\label{eq:fj-e-invk-arg}
\\ \\
\frac{
    t_i \longrightarrow t_i'
}{
    \text{new } C(\bar{v}, t_i, \bar{t})
    \longrightarrow
    \text{new } C(\bar{v}, t_i', \bar{t})
} \tag{E-New-Arg}\label{eq:fj-e-new-arg}
\\ \\
\frac{
    t_0 \longrightarrow t_0'
}{
    (C)\ t_0 \longrightarrow (C)\ t_0'
} \tag{E-Cast}\label{eq:fj-e-cast}
\end{align}\]

<p>As $\ref{eq:fj-e-invknew}$ and $\ref{eq:fj-e-invk-arg}$ show, it uses call-by-value evaluation order.</p>

<h3 id="typing">Typing</h3>
<p>\(\begin{align}
\frac{x: C \in \Gamma}{\Gamma\vdash x: C}
\tag{T-Var}\label{eq:fj-t-var}
\\ \\
\frac{
    \Gamma\vdash t_0 : C_0
    \quad \text{fields}(C_0) = \bar{C}\ \bar{f}
}{
    \Gamma\vdash t_0.\!f_i : C_i
} \tag{T-Field}\label{eq:fj-t-field}
\\ \\
\frac{
    \Gamma\vdash t_0 : C_0
    \quad \text{mtype}(m, C_0) = \bar{D} \rightarrow C
    \quad \Gamma\vdash \bar{t}: \bar{C}
    \quad \bar{C} &lt;: \bar{D}
}{
    \Gamma\vdash t_0.\!m(\bar{t}): C
} \tag{T-Invk}\label{eq:fj-t-invk}
\\ \\
\frac{
    \text{fields}(C) = \bar{D}\ \bar{f}
    \quad \Gamma\vdash \bar{t}: \bar{C}
    \quad \bar{C} &lt;: \bar{D}
}{
    \Gamma\vdash \text{new } C(\bar{t}): C
}\tag{T-New}\label{eq:fj-t-new}
\\ \\
\frac{
    \Gamma\vdash t_0 : D
    \quad D &lt;: C
}{
    \Gamma\vdash (C)\ t_0 : C
} \tag{T-UCast}\label{eq:fj-t-ucast}
\\ \\
\frac{
    \Gamma\vdash t_0 : D
    \quad C &lt;: D
    \quad C \ne D
}{
    \Gamma\vdash (C)\ t_0 : C
} \tag{T-DCast}\label{eq:fj-t-dcast}
\\ \\
\frac{
    (\bar{x}: \bar{C})\cup(\text{this}: C) \vdash t_0 : E_0
    \qquad E_0 &lt;: C_0 \\
    \text{CT}(C) = \text{class } C \text{ extends } D\ \set{\dots}
    \qquad \text{override}(m, D, \bar{C}\rightarrow C_0)
}{
    C_0\ m\ (\bar{C}\ \bar{x})\ \set{\text{return } t_0;}\text{ OK in } C
} \tag{M OK in C}\label{eq:fj-m-ok-in-c}
\\ \\
\frac{
    K = C(\bar{D}\ \bar{g}, \bar{C}\ \bar{f})\ \set{
        \text{super}(\bar{g});
        \text{this}.\!\bar{f} = \bar{f};
    } \\
    \text{fields}(D)=\bar{D}\ \bar{g}
    \qquad \bar{M} \text{ OK in } C
}{
    \text{class } C \text{ extends } D \ \set{
        \bar{C}\ \bar{f};
        K\ \bar{M}
    } \text{ OK}
} \tag{C OK}\label{eq:fj-c-ok}
\end{align}\)</p>

<p>$\ref{eq:fj-t-var}$ is as usual. $\ref{eq:fj-t-field}$ says that we can type-check the i<sup>th</sup> field by looking up the type of the i<sup>th</sup> field in the class.</p>

<p>We have two rules for casting: one for subtypes ($\ref{eq:fj-t-dcast}$), and one for supertypes ($\ref{eq:fj-t-ucast}$). We do not allow casting to an unrelated type, because FJ complies with Java, and Java doesnâ€™t allow it.</p>

<p>For methods and classes, we want to make sure that overrides are valid, that we pass the correct arguments to the superclass constructor.</p>

<p>Also note that the our typing rules often have subsumption built into them (e.g. see $\ref{eq:fj-t-invk}$), instead of having a separate subsumption rule. This allows us to have algorithmic subtyping, which we need for two reasons:</p>

<ol>
  <li>To perform static overloading resolution (picking between different overloaded methods at compile-time), we need to be able to speak about the type of an expression (and we need one single type, not several of them)</li>
  <li>Weâ€™d run into trouble typing conditional expressions. This is not something that we have included in FJ, but regular Java has it, and we may wish to include it as an extension to FJ</li>
</ol>

<p>Letâ€™s talk about this problem with conditionals (aka ternary expressions) in a little more detail. If we have a conditional $t_1 ?\ t_2 : t_3$, with $t_1: \text{Bool}$, $t_2: T_2$ and $t_3: T_3$, what is the return type of the expression? The simple solution is the least common supertype (this corresponds to the lowest common ancestor), but that becomes problematic with interfaces, which allow for multiple inheritance (for instance, if $T_2$ and $T_3$ both implement $I_2$ and $I_3$, we wouldnâ€™t know which one to pick).</p>

<p>The actual Java rule thatâ€™s used is that the return type is $\min (T_2, T_3)$. Scala solves this (in Dotty) with union types, where the result type is $T_2 \mid T_3$.</p>

<h3 id="evaluation-context">Evaluation context</h3>
<p>We canâ€™t actually prove progress, as well-typed programs can get stuck because of casting. Casting can fail, and weâ€™d get stuck. The solution is to weaken the statement of progress:</p>

<p><strong>FJ progress</strong> (<em>informally</em>): a well-typed FJ term is either value, reduces to one, or gets stuck at a cast failure.</p>

<p>To formalize this, we need a little more work. Weâ€™ll first need to introduce <strong>evaluation contexts</strong>. For FJ, the evaluation context is defined as:</p>

\[\begin{align}
E ::= &amp;                                    &amp; \textbf{evaluation contexts} \\
      &amp; []                                 &amp; \text{hole} \\
      &amp; E.\!f                              &amp; \text{field access} \\
      &amp; E.\!m(\bar{t})                     &amp; \text{method invocation (rcv)} \\
      &amp; v.m(\bar{v}, E, \bar{t})           &amp; \text{method invocation (arg)} \\
      &amp; \text{new } C(\bar{v}, E, \bar{t}) &amp; \text{object creation (arg)} \\
      &amp; (C)\ E                             &amp; \text{cast} \\
\end{align}\]

<p>All expressions in $E$ are recursive, except for $[]$; this means an expression is a nested composition of the above forms, with a hole somewhere inside it. We write $E[t]$ for the term obtained by replacing the hole in $E$ with $t$.</p>

<p>Evaluation contexts are essentially just shorthand notation to avoid the verbosity of congruence rules. Usually, congruence rules just â€œforwardâ€ the computation to some part of the expression, and thatâ€™s exactly what we capture with evaluation contexts: the position of $[]$ tells us which part of the expression to evaluate.</p>

<p>Having defined the execution context, we can then express all congruence rules as a single rule:</p>

\[\frac{t \longrightarrow t'}{E[t] \longrightarrow E[t']}\]

<h3 id="properties">Properties</h3>

<h4 id="progress-1">Progress</h4>
<p>We can now restate progress more formally.</p>

<p><strong>FJ progress</strong>: Suppose $t$ is a closed, well-typed normal form. Then either:</p>

<ol>
  <li>$t$ is a value</li>
  <li>$t \longrightarrow tâ€™$ for some $tâ€™$</li>
  <li>For some evaluation context $E$, we can express $t$ as $t = E[(C)\ (\text{new } D(\bar{v}))]$, with $\neg (D &lt;: C)$</li>
</ol>

<h4 id="preservation-2">Preservation</h4>
<p>The preservation theorem can be stated as:</p>

<p><strong>Preservation</strong>: If $\Gamma\vdash t: C$ and $t \longrightarrow tâ€™$ then $\Gamma\vdash tâ€™: Câ€™$ for some $Câ€™ &lt;: C$</p>

<p>But this doesnâ€™t actually for FJ. Because we allow casts to go up and down, we can upcast to Object before downcasting to another, unrelated type. Because FJ must model Java, we need to actually introduce a rule for this. In this new rule, we give a â€œstupid warningâ€ to indicate that the <em>implementation</em> should generate a warning if this rule is used:</p>

\[\frac{
    \Gamma\vdash t_0 : D
    \quad \neg(C &lt;: D)
    \quad \neg(D &lt;: C) \\
    \text{stupid warning}
}{
    \Gamma\vdash (C) t_0 : C
} \tag{T-SCast}\label{eq:fj-t-scast}\]

<h4 id="correspondence-with-java">Correspondence with Java</h4>
<p>FJ corresponds to Java; by this, we mean:</p>

<ol>
  <li>Every syntactically well-formed FJ program is also a syntactically well-formed Java program.</li>
  <li>A syntactically well-formed FJ program is typable in FJ (without using $\ref{eq:fj-t-scast}$) $\iff$ it is typable in Java</li>
  <li>A well-typed FJ program behaves the same in FJ as in Java (e.g. diverges in FJ $\iff$ it diverges in Java)</li>
</ol>

<p>Without a formalization of full Java, we cannot <em>prove</em> this, but itâ€™s still useful to say what weâ€™re trying to accomplish, as it provides us with a rigorous way of judging potential counterexamples.</p>

<h2 id="foundations-of-scala">Foundations of Scala</h2>

<h3 id="modeling-lists">Modeling lists</h3>
<p>If weâ€™d like to apply everything weâ€™ve learned so far to model Scala, weâ€™ll run into problems fairly quickly. Say weâ€™d like to model a <code class="highlighter-rouge">List</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">Const</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
    <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">hd</span>
    <span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="n">tl</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">Nil</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="o">???</span>
    <span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Immediately, we run into these problems:</p>

<ul>
  <li>Itâ€™s parameterized</li>
  <li>Itâ€™s recursive</li>
  <li>It can be invariant or covariant</li>
</ul>

<p>To solve the parametrization, we need a way to express type constructors. Traditionally, the solution is to express this as <em>higher-kinded types</em>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="o">*</span>            <span class="c1">// Kind of normal types (Boolean, Int, ...)</span>
<span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span>       <span class="c1">// Kind of unary type constructor: </span>
             <span class="c1">// something that takes a type, returns one</span>
<span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span>  <span class="c1">// and so on...</span>
<span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Weâ€™ve previously had abstraction and application for terms, but weâ€™d now like to extends this to types. Weâ€™ll introduce $\mu$, which works like $\lambda$ but for types.</p>

<p>This also leads us to solving the problem of modeling recursive types, as we can now create type-level functions, called <em>type operators</em>. For instance, we can define a constructor for recursive types $\mu t. T(t)$. For instance:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">mu</span> <span class="nc">ListInt</span><span class="o">.</span> <span class="o">{</span> <span class="n">head</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">ListInt</span> <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>However, we get into some tricky questions when it comes to equality and subtyping. For instance, in the following, how do <code class="highlighter-rouge">T</code> and <code class="highlighter-rouge">Int -&gt; T</code> relate?</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">mu</span> <span class="n">t</span><span class="o">.</span> <span class="nc">Int</span> <span class="o">-&gt;</span> <span class="nc">Int</span> <span class="o">-&gt;</span> <span class="n">t</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Finally, we need to model the covariance of lists. We can deal with variance by expressing definition site variance as use-site variance, using Java wildcards:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1">// We can go from definition site variance...</span>
<span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-T</span>, <span class="kt">+U</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="nc">List</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
<span class="nc">Function1</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">E</span><span class="o">]</span>

<span class="c1">// ... to use-site variance by rewriting with Java wildcards:</span>
<span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">]</span>

<span class="nc">List</span><span class="o">[</span><span class="k">_</span> <span class="k">&lt;:</span> <span class="kt">C</span><span class="o">]</span>
<span class="nc">Function1</span><span class="o">[</span><span class="k">_</span> <span class="k">&gt;:</span> <span class="kt">D</span>, <span class="k">_</span> <span class="k">&lt;:</span> <span class="kt">E</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here, we should understand <code class="highlighter-rouge">Function1[_ &gt;: D, _ &lt;: E]</code> as the type of functions from some (unknown) supertpye of <code class="highlighter-rouge">D</code> to some (unknown) subtype of <code class="highlighter-rouge">E</code>. How can we model this?  One possibility is existential types:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="c1">// Scala:</span>
<span class="nc">Function1</span><span class="o">[</span><span class="kt">X</span>, <span class="kt">Y</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">X</span> <span class="k">&gt;:</span> <span class="kt">D</span>
    <span class="k">type</span> <span class="kt">Y</span> <span class="k">&lt;:</span> <span class="kt">E</span>
<span class="o">}</span>

<span class="c1">// more traditional notation, with existential types:</span>
<span class="o">âˆƒ</span> <span class="n">X</span> <span class="k">&gt;:</span> <span class="n">D</span><span class="o">,</span> <span class="n">Y</span> <span class="k">&lt;:</span> <span class="n">E</span><span class="o">.</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">X</span>, <span class="kt">Y</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>But this gets messy rather quickly. Can we find a nicer way of expressing this? As we saw above, Scala has type members, so we can re-formulate <code class="highlighter-rouge">List</code> as follows:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">List</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span> 
    <span class="k">type</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">List</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">self.T</span> <span class="o">}</span> <span class="c1">// refinement handling co-variance</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">Cons</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">X</span> <span class="o">})</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">List</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">X</span>
    <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
    <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">hd</span>
    <span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="n">tl</span>
<span class="o">}</span>

<span class="c1">// analogous for Nil</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This offers an alternative way to express the above, without using existential types, but instead using:</p>

<ul>
  <li>Variables, functions</li>
  <li>Abstract types <code class="highlighter-rouge">type T &lt;: B</code></li>
  <li>Refinements <code class="highlighter-rouge">List { ... }</code></li>
  <li>Path-dependent types <code class="highlighter-rouge">self.T</code></li>
</ul>

<h3 id="abstract-types">Abstract types</h3>
<p>Abstract types are types without a concrete implementation. They may have an upper and/or lower bound, like <code class="highlighter-rouge">type L &gt;: T &lt;: U</code>, or no bounds like below:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="c1">// Trait containing an abstract type:</span>
<span class="k">trait</span> <span class="nc">KeyGen</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Key</span>
    <span class="k">def</span> <span class="nf">key</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.Key</span>
<span class="o">}</span>

<span class="c1">// Implementation refining the abstract type:</span>
<span class="k">object</span> <span class="nc">HashKeyGen</span> <span class="k">extends</span> <span class="nc">KeyGen</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Key</span> <span class="o">=</span> <span class="nc">Int</span>
    <span class="k">def</span> <span class="nf">key</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nv">s</span><span class="o">.</span><span class="py">hashCode</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can reference the <code class="highlighter-rouge">Key</code> type of a term <code class="highlighter-rouge">k</code> as <code class="highlighter-rouge">k.Key</code>. This is a <em>path-dependent</em> type. For instance:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">mapKeys</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">KeyGen</span><span class="o">,</span> <span class="n">ss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">k.Key</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nv">ss</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="nv">k</span><span class="o">.</span><span class="py">key</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The function <code class="highlighter-rouge">mapKeys</code> has a <em>dependent function type</em>. This is an interesting type, because the result type has an internal dependency: <code class="highlighter-rouge">(k: KeyGen, ss: List[String]) -&gt; List[k.Key]</code>.</p>

<p>In Scala 2, we canâ€™t express this directly; weâ€™d have to go through a trait with an apply method, meaning that we have to define a type for every dependent function:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">KeyFun</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">KeyGen</span><span class="o">,</span> <span class="n">ss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">k.Key</span><span class="o">]</span>
<span class="o">}</span>

<span class="n">mapKeys</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KeyFun</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">KeyGen</span><span class="o">,</span> <span class="n">ss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">k.Key</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nv">ss</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="nv">k</span><span class="o">.</span><span class="py">key</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>However, Scala 3 (dotty) <a href="http://dotty.epfl.ch/docs/reference/new-types/dependent-function-types.html">introduces these dependent function types</a> at the language level; itâ€™s done with a similar trick to what we just saw.</p>

<p>In dotty, the intention was to have everything map to a simple object type; this has been formalized in a calculus called DOT, (path-)Dependent Object Types.</p>

<h3 id="dot">DOT</h3>
<p>The DOT syntax is described in the <a href="http://lampwww.epfl.ch/~amin/dot/fool.pdf">DOT paper</a>.</p>

\[\begin{align}
S, T, U ::= &amp; &amp; \textbf{Type} \\
    &amp; \top &amp; \text{top type} \\
    &amp; \bot &amp; \text{bot type} \\
    &amp; \set{a: T} &amp; \text{field declaration} \\
    &amp; \set{A: S..T} &amp; \text{type declaration} \\
    &amp; x.A &amp; \text{type projection} \\
    &amp; S \land T &amp; \text{intersection type} \\
    &amp; \mu(x: T) &amp; \text{recursive type} \\
    &amp; \forall(x: S) T &amp; \text{dependent function} \\
\\

v ::= &amp; &amp; \textbf{Value} \\
    &amp; \nu(x: T)d &amp; \text{object} \\
    &amp; \lambda(x: T)t &amp; \text{lambda} \\
\\

s, t, u ::= &amp; &amp; \textbf{Term} \\
    &amp; x &amp; \text{variable} \\
    &amp; v &amp; \text{value} \\
    &amp; x.a &amp; \text{selection} \\
    &amp; x\ y &amp; \text{application} \\
    &amp; \text{let } x = t \text{ in } u &amp; \text{let} \\
\\

d ::= &amp; &amp; \textbf{Definition} \\
    &amp; \set{a = t} &amp; \text{field definition} \\
    &amp; \set{A = T} &amp; \text{type definition} \\
    &amp; d_1 \land d_2 &amp; \text{aggregate definition} \\
\end{align}\]

<p>We use the following metavariables:</p>

<ul>
  <li>$x$, $y$, $z$ for variables</li>
  <li>$a$, $b$, $c$ for term members</li>
  <li>$A$, $B$, $C$ for type members</li>
</ul>

<p>Types are in uppercase, terms in lowercase. Note that recursive types $\mu (x: T)$ are a little different from what weâ€™ve talked about, but weâ€™ll get to that later.</p>

<p>As a small technicality, DOT imposes the restriction of only allowing member selection and application on variables, and not on values or full terms. This is equivalent, because we could just assign the value to a variable before selection or application. This way of writing programs is also called <em>administrative normal form</em> (ANF).</p>

<p>To simplify things, we can introduce a programmer-friendly notation with ASCII versions of DOT constructs:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">U</span>          <span class="k">for</span>   <span class="nf">Î»</span><span class="o">(</span><span class="n">x</span> <span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="nf">U</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">U</span>          <span class="k">for</span>   <span class="o">âˆ€(</span><span class="n">x</span> <span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="n">U</span>
<span class="nf">new</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="n">d</span>           <span class="n">or</span>
<span class="k">new</span> <span class="o">{</span> <span class="n">x</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">d</span> <span class="o">}</span>    <span class="k">for</span>   <span class="nf">Î½</span><span class="o">(</span><span class="n">x</span> <span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="n">d</span>
<span class="nf">rec</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>            <span class="n">or</span>
<span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="o">}</span>           <span class="k">for</span>   <span class="nf">Î¼</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
<span class="n">T</span> <span class="o">&amp;</span> <span class="n">U</span>                <span class="k">for</span>   <span class="n">T</span> <span class="o">âˆ§</span> <span class="n">U</span>
<span class="nc">Any</span>                  <span class="k">for</span>   <span class="o">âŠ¤</span>
<span class="nc">Nothing</span>              <span class="k">for</span>   <span class="o">âŠ¥</span>
<span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="k">&gt;:</span> <span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">T</span> <span class="o">}</span> <span class="k">for</span>   <span class="o">{</span><span class="n">A</span><span class="k">:</span> <span class="kt">S..T</span><span class="o">}</span>
<span class="o">{</span> <span class="k">def</span> <span class="nf">a</span> <span class="k">=</span> <span class="n">t</span> <span class="o">}</span>        <span class="k">for</span>   <span class="o">{</span><span class="n">a</span> <span class="k">=</span> <span class="n">t</span><span class="o">}</span>
<span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T</span> <span class="o">}</span>       <span class="k">for</span>   <span class="o">{</span><span class="n">A</span> <span class="k">=</span> <span class="n">T</span><span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This calculus does not have generic types, because we can encode them as dependent function types.</p>

<h4 id="example-1-twice">Example 1: Twice</h4>
<p>Letâ€™s take a look at an example. The polymorphic type of the <code class="highlighter-rouge">twice</code> method (which we <a href="#lambda-calculus">defined previously</a>) is:</p>

\[\forall X.\ (X \rightarrow X) \rightarrow X \rightarrow X\]

<p>In other words, it takes a function from $X$ to $X$, an argument of type $X$, and returns a value of type $X$, where $X$ is some generic type. This is represented as:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="o">(</span><span class="n">cX</span><span class="k">:</span> <span class="o">{</span><span class="kt">A:</span> <span class="kt">Nothing..Any</span><span class="o">})</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nv">cX</span><span class="o">.</span><span class="py">A</span> <span class="o">-&gt;</span> <span class="nv">cX</span><span class="o">.</span><span class="py">A</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nv">cX</span><span class="o">.</span><span class="py">A</span> <span class="o">-&gt;</span> <span class="nv">cX</span><span class="o">.</span><span class="py">A</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">cX</code> parameter is a kind of cell containing a type variance X (hence the name <code class="highlighter-rouge">cX</code>).</p>

<h4 id="example-2-church-booleans">Example 2: Church booleans</h4>
<p>Letâ€™s see how Church Booleans could be implemented:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="c1">// Define an abstract "if type" IFT</span>
<span class="k">type</span> <span class="kt">IFT</span> <span class="o">=</span> <span class="o">{</span> <span class="k">if:</span> <span class="o">(</span><span class="kt">x:</span> <span class="o">{</span><span class="kt">A:</span> <span class="kt">Nothing..Any</span><span class="o">})</span> <span class="kt">-&gt;</span> <span class="kt">x.A</span> <span class="kt">-&gt;</span> <span class="kt">x.A</span> <span class="kt">-&gt;</span> <span class="kt">x.A</span> <span class="o">}</span>

<span class="n">let</span> <span class="n">boolimpl</span> <span class="k">=</span>
    <span class="n">let</span> <span class="n">boolImpl</span> <span class="k">=</span>
        <span class="nf">new</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="o">{</span> <span class="kt">Boolean:</span> <span class="kt">IFT..IFT</span> <span class="o">}</span> <span class="kt">&amp;</span>
            <span class="o">{</span> <span class="kt">true:</span> <span class="kt">IFT</span> <span class="o">}</span> <span class="kt">&amp;</span>
            <span class="o">{</span> <span class="kt">false:</span> <span class="kt">IFT</span> <span class="o">})</span>
        <span class="o">{</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="nc">IFT</span> <span class="o">}</span> <span class="o">&amp;</span>
        <span class="o">{</span> <span class="kc">true</span> <span class="k">=</span> <span class="o">{</span> <span class="k">if</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">{</span><span class="kt">A:</span> <span class="kt">Nothing..Any</span><span class="o">})</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">t</span> <span class="o">}</span> <span class="o">&amp;</span>
        <span class="o">{</span> <span class="kc">false</span> <span class="k">=</span> <span class="o">{</span> <span class="k">if</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">{</span><span class="kt">A:</span> <span class="kt">Nothing..Any</span><span class="o">})</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span> <span class="o">}</span>
<span class="n">in</span> <span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can hide the implementation details of this with a small wrapper to which we apply <code class="highlighter-rouge">boolImpl</code>.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="n">let</span> <span class="n">bool</span> <span class="k">=</span>
    <span class="n">let</span> <span class="n">boolWrapper</span> <span class="k">=</span>
        <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">rec</span><span class="o">(</span><span class="kt">b:</span> <span class="o">{</span><span class="kt">Boolean:</span> <span class="kt">Nothing..IFT</span><span class="o">}</span> <span class="kt">&amp;</span>
                   <span class="o">{</span><span class="kt">true:</span> <span class="kt">b.Boolean</span><span class="o">}</span> <span class="kt">&amp;</span>
                   <span class="o">{</span><span class="kt">false:</span> <span class="kt">b.Boolean</span><span class="o">}))</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="n">in</span> <span class="n">boolWrapper</span> <span class="n">boolImpl</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is all a little long-winded, so we can introduce some abbreviations:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="c1">// Abstract types:</span>
<span class="k">type</span> <span class="kt">A</span>                   <span class="kt">for</span> <span class="o">{</span><span class="kt">A:</span> <span class="kt">Nothing..Any</span><span class="o">}</span>
<span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T</span>               <span class="k">for</span> <span class="o">{</span><span class="n">A</span><span class="k">:</span> <span class="kt">T..T</span><span class="o">}</span>
<span class="k">type</span> <span class="kt">A</span> <span class="k">&gt;:</span> <span class="kt">S</span>              <span class="kt">for</span> <span class="o">{</span><span class="kt">A:</span> <span class="kt">S..Any</span><span class="o">}</span>
<span class="k">type</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">U</span>              <span class="kt">for</span> <span class="o">{</span><span class="kt">A:</span> <span class="kt">Nothing..U</span><span class="o">}</span>
<span class="k">type</span> <span class="kt">A</span> <span class="k">&gt;:</span> <span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">U</span>         <span class="kt">for</span> <span class="o">{</span><span class="kt">A:</span> <span class="kt">S..U</span><span class="o">}</span>

<span class="c1">// Intersections:</span>
<span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T</span><span class="o">;</span> <span class="n">a</span> <span class="k">=</span> <span class="n">t</span> <span class="o">}</span>    <span class="k">for</span> <span class="o">{</span><span class="n">A</span> <span class="k">=</span> <span class="n">T</span><span class="o">}</span> <span class="o">&amp;</span> <span class="o">{</span><span class="n">a</span> <span class="k">=</span> <span class="n">t</span><span class="o">}</span>
<span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">T</span><span class="o">;</span> <span class="n">a</span> <span class="k">=</span> <span class="n">T</span> <span class="o">}</span>   <span class="k">for</span> <span class="o">{</span><span class="n">A</span><span class="k">:</span> <span class="kt">Nothing..T</span><span class="o">}</span> <span class="o">&amp;</span> <span class="o">{</span><span class="n">a</span><span class="k">:</span> <span class="kt">T</span><span class="o">}</span>

<span class="c1">// Ascription:</span>
<span class="n">t</span><span class="k">:</span> <span class="kt">T</span>
<span class="c1">// Which expands to:</span>
<span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="n">t</span>
<span class="c1">// Which expands to:</span>
<span class="n">let</span> <span class="n">y</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="n">in</span>
    <span class="n">let</span> <span class="n">z</span> <span class="k">=</span> <span class="n">t</span> <span class="n">in</span> 
        <span class="n">y</span> <span class="n">z</span>

<span class="c1">// Object definition:</span>
<span class="k">new</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">d</span> <span class="o">}</span>           <span class="k">for</span> <span class="nf">new</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="n">d</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>With these in place, we can give an abbreviated definition:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="n">let</span> <span class="n">bool</span> <span class="k">=</span>
    <span class="k">new</span> <span class="o">{</span> <span class="n">b</span> <span class="k">=&gt;</span>
        <span class="k">type</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span><span class="k">if:</span> <span class="o">(</span><span class="kt">x:</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">})</span> <span class="kt">-&gt;</span> <span class="o">(</span><span class="kt">t:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="o">(</span><span class="kt">f:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="kt">-&gt;</span> <span class="kt">x.A</span><span class="o">}</span>
        <span class="kc">true</span> <span class="k">=</span> <span class="o">{</span><span class="k">if:</span> <span class="o">(</span><span class="kt">x:</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">})</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="o">}</span>
        <span class="kc">false</span> <span class="k">=</span> <span class="o">{</span><span class="k">if:</span> <span class="o">(</span><span class="kt">x:</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">})</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">}</span>
    <span class="o">}</span><span class="k">:</span> <span class="o">{</span> <span class="kt">b</span> <span class="o">=&gt;</span> <span class="k">type</span> <span class="kt">Boolean</span><span class="o">;</span> <span class="kc">true</span><span class="k">:</span> <span class="kt">b.Boolean</span><span class="o">;</span> <span class="kc">false</span><span class="k">:</span> <span class="kt">b.Boolean</span> <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="example-3-lists">Example 3: Lists</h4>
<p>Weâ€™ve now introduced all the concepts we need to actually define the covariant list in DOT. Weâ€™d like to model the following Scala code in DOT:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">package</span> <span class="nn">scala.collection.immutable</span>

<span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">A</span>
    <span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">List</span><span class="o">{</span>
    <span class="k">def</span> <span class="nf">nil</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
        <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">head</span> <span class="c1">// infinite loop</span>
        <span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="n">tail</span> <span class="c1">// infinite loop</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">cons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
        <span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">hd</span>
        <span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="n">tl</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can write this in DOT as:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="n">let</span> <span class="n">scala_collection_immutable_impl</span> <span class="k">=</span> <span class="k">new</span> <span class="o">{</span> <span class="n">sci</span> <span class="k">=&gt;</span>
    <span class="k">type</span> <span class="kt">List</span> <span class="o">=</span> <span class="o">{</span> <span class="n">thisList</span> <span class="k">=&gt;</span>
        <span class="k">type</span> <span class="kt">A</span>
        <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">bool.Boolean</span>
        <span class="n">head</span><span class="k">:</span> <span class="kt">thisList.A</span>
        <span class="n">tail</span><span class="k">:</span> <span class="kt">sci.List</span> <span class="kt">&amp;</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">thisList.A</span> <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">cons</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span><span class="o">})</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">hd</span><span class="k">:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="o">(</span><span class="n">tl</span><span class="k">:</span> <span class="kt">sci.List</span> <span class="kt">&amp;</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">x.A</span> <span class="o">})</span> <span class="k">=&gt;</span>
            <span class="n">let</span> <span class="n">l</span> <span class="k">=</span> <span class="k">new</span> <span class="o">{</span>
                <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">A</span>
                <span class="n">isEmpty</span> <span class="k">=</span> <span class="nv">bool</span><span class="o">.</span><span class="py">false</span>
                <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
                <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span> 
            <span class="o">}</span> <span class="n">in</span> <span class="n">l</span>

    <span class="n">nil</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span><span class="o">})</span> <span class="k">=&gt;</span>
        <span class="n">let</span> <span class="n">l</span> <span class="k">=</span> <span class="k">new</span> <span class="o">{</span> <span class="n">l</span> <span class="k">=&gt;</span>
            <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">x</span><span class="o">.</span><span class="py">A</span>
            <span class="n">isEmpty</span> <span class="k">=</span> <span class="nv">bool</span><span class="o">.</span><span class="py">true</span>
            <span class="n">head</span> <span class="k">=</span> <span class="nv">l</span><span class="o">.</span><span class="py">head</span>
            <span class="n">tail</span> <span class="k">=</span> <span class="nv">l</span><span class="o">.</span><span class="py">tail</span>
        <span class="o">}</span> <span class="n">in</span> <span class="n">l</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To hide the implementation, we can wrap <code class="highlighter-rouge">scala_collection_immutable_impl</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="n">let</span> <span class="n">scala_collection_immutable</span> <span class="k">=</span> <span class="nv">scala_collection</span><span class="o">.</span><span class="py">immutable_impl</span><span class="k">:</span> <span class="o">{</span> <span class="kt">sci</span> <span class="o">=&gt;</span>
    <span class="k">type</span> <span class="kt">List</span> <span class="k">&lt;:</span> <span class="o">{</span> <span class="kt">thisList</span> <span class="o">=&gt;</span>
        <span class="k">type</span> <span class="kt">A</span>
        <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">bool.Boolean</span>
        <span class="n">head</span><span class="k">:</span> <span class="kt">thisList.A</span>
        <span class="n">tail</span><span class="k">:</span> <span class="kt">sci.List</span> <span class="kt">&amp;</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">thisList.A</span> <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">nil</span><span class="k">:</span> <span class="kt">sci.List</span> <span class="kt">&amp;</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">}</span>

    <span class="n">cons</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span><span class="o">})</span> <span class="kt">-&gt;</span>
          <span class="o">(</span><span class="kt">hd:</span> <span class="kt">x.A</span><span class="o">)</span> <span class="kt">-&gt;</span>
          <span class="o">(</span><span class="kt">tl:</span> <span class="kt">sci.List</span> <span class="kt">&amp;</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">x.A</span> <span class="o">})</span> <span class="kt">-&gt;</span>
          <span class="kt">sci.List</span> <span class="kt">&amp;</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="kt">x.A</span> <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This concept of hiding the implementation gives us <em>nominality</em>. A nominal type such as <code class="highlighter-rouge">List</code> is simply an abstract type with a hidden implementation. This shows that nominal and structural types arenâ€™t completely separated; we can do nominal types within a structural setting if we have these constructs.</p>

<h3 id="evaluation-3">Evaluation</h3>
<p>Evaluation is interesting, because weâ€™d like for it to keep terms in ANF.</p>

<p>First, to define the congruence rules, letâ€™s define an evaluation context $E$:</p>

\[\begin{align}
E ::= &amp; \\
    &amp; [] \\
    &amp; \text{let } x = [] \text{ in } t \\
    &amp; \text{let } x = v  \text{ in } E \\ 
\end{align}\]

<p>The rules are then:</p>

\[\begin{align}
\frac{t \longrightarrow t'}{E[t] \longrightarrow E[t']}
\\ \\
\frac{v = \lambda(z: T)t}{
    \text{let } x = v \text{ in } E[x\ y]
    \longrightarrow
    \text{let } x = v \text{ in } E[[z\mapsto y] t]
}
\\ \\
\frac{v = \nu(z: T)...\set{a = t}}{
    \text{let } x = v \text{ in } E[x.a]
    \longrightarrow
    \text{let } x = v \text{ in } E[t]
}
\\ \\
\text{let } x = y \text{ in } t
\longrightarrow
[x \mapsto y] t
\\ \\
\text{let } x = (\text{let } y = s \text{ in } t) \text{ in } u
\longrightarrow
\text{let } y = s \text{ in } \text{let } x = t \text{ in } u
\end{align}\]

<h3 id="type-assignment-and-subtyping">Type assignment and subtyping</h3>
<p>These are in the slides and in the DOT paper.</p>

<h3 id="abstract-types-1">Abstract types</h3>
<p>Abstract types turn out to be both the most interesting and most difficult part of this, so letâ€™s take a quick look at it before we go on.</p>

<p>Abstract types can be used to encode type parameters (as in <code class="highlighter-rouge">List</code>), hide information (as in <code class="highlighter-rouge">KeyGen</code>), and also to resolve some puzzlers like this one:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Food</span>
<span class="k">trait</span> <span class="nc">Grass</span> <span class="k">extends</span> <span class="nc">Food</span>

<span class="k">trait</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Food</span> <span class="o">{</span>
    <span class="c1">// error: does not override Animal.eat because of contravariance</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Lion</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="c1">// error: does not override Animal.eat because of contravariance</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Cow</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Scala disallows this, but Eiffel, Dart and TypeScript and allow it. The trade-off that the latter languages choose is modeling power over soundness, though some languages have eventually come back around and tried to fix this (Dart has a strict mode, Eiffel proposed some data flow analysis, â€¦).</p>

<p>In Scala, this contravariance problem can be solved with abstract types:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Diet</span> <span class="k">&lt;:</span> <span class="kt">Food</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Diet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Diet</span> <span class="k">&lt;:</span> <span class="kt">Grass</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">this.Diet</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Milka</span> <span class="k">extends</span> <span class="nc">Cow</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Diet</span> <span class="o">=</span> <span class="nc">AlpineGrass</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">AlpineGrass</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="progress-and-preservation">Progress and preservation</h3>
<p>Progress is actually wrong. Hereâ€™s a counter example:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">t</span> <span class="k">=</span> <span class="n">let</span> <span class="n">x</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Bool</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="n">in</span> <span class="n">x</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>But we can extend our definition of progress. Instead of values, weâ€™ll just want to get answers, which we define as variables, values or let-bindings.</p>

<p>But this is difficult (and itâ€™s what took 8 years to prove), because we always need an inversion, and the subtyping relation is user-definable. This is not a problem for simple type bounds:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">type</span> <span class="kt">T</span> <span class="k">&gt;:</span> <span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">U</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>But it becomes complex for non-sensical bounds:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">type</span> <span class="kt">T</span> <span class="k">&gt;:</span> <span class="kt">Any</span> <span class="k">&lt;:</span> <span class="kt">Nothing</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>By transitivity, it would mean that <code class="highlighter-rouge">Any &lt;: Nothing</code>, so by transitivity all types are subtypes of each other. This is bad because it means that inversion fails, as we cannot tell anything from the types anymore.</p>

<p>We might say that this should be easy to disallow in the compiler, but it isnâ€™t. The compiler cannot always tell.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">// S and T are both good:</span>
<span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span><span class="o">;</span> <span class="k">type</span> <span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Bot</span> <span class="o">}</span>
<span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="k">&gt;:</span> <span class="kt">Top</span> <span class="k">&lt;:</span> <span class="kt">B</span><span class="o">;</span> <span class="k">type</span> <span class="kt">B</span> <span class="o">}</span>

<span class="c1">// But their intersection is bad</span>
<span class="k">type</span> <span class="kt">S</span> <span class="kt">&amp;</span> <span class="kt">T</span> <span class="o">=</span><span class="k">=</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">A</span> <span class="k">&gt;:</span> <span class="kt">Top</span> <span class="k">&lt;:</span> <span class="kt">Bot</span><span class="o">;</span> <span class="k">type</span> <span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">Top</span> <span class="k">&lt;:</span> <span class="kt">Bot</span> <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Bad bounds can arise from intersecting types with good bounds. This isnâ€™t too bad in and of itself, as we could just check all intersection types, written or inferred, for these bad bounds. But thereâ€™s a final problem: bad bounds can arise at run-time. By preservation, if $\Gamma\vdash t: T$ and $t\longrightarrow u$ then $\Gamma\vdash u: T$. Because of subsumption, $u$ may also have a type $S$ which is a true subtype of $T$, and that type $S$ could have bad bounds (from an intersection for instance).</p>

<p>To solve this, the idea is to reason about environments $\Gamma$ arising from an actual computation in the preservation rule. This environment corresponds to an evaluated <code class="highlighter-rouge">let</code> binding, binding variables to values. Values are guaranteed to have good bounds because all type members are aliases.</p>

<p>In other words, the <code class="highlighter-rouge">let</code> prefix acts like a store, a set of bindings $x = v$ of variables to values. Evaluation will then relate terms <em>and</em> stores:</p>

\[s \mid t \longrightarrow s' \mid t'\]

<p>For the theorems of proofs and preservation, we need to relate environment and store. Weâ€™ll introduce a definition:</p>

<blockquote>
  <p>An environment $\Gamma$ <em>corresponds</em> to a store $s$, written $\Gamma \sim s$ if for every binding $x=v$ there is an entry $\Gamma\vdash x: T$ where $\Gamma \vdash_{!} v: T$.</p>
</blockquote>

<p>Here $\vdash_{!}$ denotes an exact typing relation, whose typing derivation ends with <code class="highlighter-rouge">All-I</code> or <code class="highlighter-rouge">{}-I</code> (so no subsumption or structural rules).</p>

<p>By restating our theorems as follows, we can then prove them.</p>

<ul>
  <li><strong>Preservation</strong>: If $\Gamma\vdash t: T$ and $G\sim s$ and $s \mid t \longrightarrow sâ€™ \mid tâ€™$ then there exists an environment $\Gammaâ€™ \subset \Gamma$ such that $\Gammaâ€™ \vdash tâ€™ : T$ and $\Gammaâ€™ \sim sâ€™$.</li>
  <li><strong>Progress</strong>: if $\Gamma\vdash t: T$ and $\Gamma\sim s$ then either $t$ is a normal form, or $s\mid t \longrightarrow sâ€™ \mid tâ€™$ for some store $sâ€™$ and term $tâ€™$.</li>
</ul>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:in-relation-notation" role="doc-endnote">
      <p>$(t, C) \in \text{Consts}$ is equivalent to $\text{Consts}(t) = C$Â <a href="#fnref:in-relation-notation" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:well-typed-store-notation" role="doc-endnote">
      <p>Recall that this notation is used to say a store $\mu$ is well typed with respect to a typing context $\Gamma$ and a store typing $\Sigma$, as defined in the section on <a href="#safety">safety in STLC with stores</a>.Â <a href="#fnref:well-typed-store-notation" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:inversion-lemma-evaluation-lambda" role="doc-endnote">
      <p>Both the course and TAPL only specify the inversion lemma for evaluation <a href="#inversion-lemma">for the toy language with if-else and booleans</a>, but the same reasoning applies to get an inversion lemma for evaluation for pure lambda calculus, in which three rules can be used: $\ref{eq:e-app1}$, $\ref{eq:e-app2}$ and $\ref{eq:e-appabs}$.Â <a href="#fnref:inversion-lemma-evaluation-lambda" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET