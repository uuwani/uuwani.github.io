I"%ã<p>The course follows a few books:</p>

<ul>
  <li>Christopher Bishop, <a href="https://www.springer.com/us/book/9780387310732">Pattern Recognition and Machine Learning</a></li>
  <li>Kevin Patrick Murphy, <a href="https://www.cs.ubc.ca/~murphyk/MLbook/">Machine Learning: a Probabilistic Perspective</a></li>
  <li>Michael Nielsen, <a href="http://neuralnetworksanddeeplearning.com/">Neural Networks and Deep Learning</a></li>
</ul>

<p>The repository for code labs and lecture notes is <a href="https://github.com/epfml/ML_course">on GitHub</a>. A useful website for this course is <a href="http://www.matrixcalculus.org/">matrixcalculus.org</a>.</p>

<!-- More -->

<ul id="markdown-toc">
  <li><a href="#linear-regression" id="markdown-toc-linear-regression">Linear regression</a>    <ul>
      <li><a href="#simple-linear-regression" id="markdown-toc-simple-linear-regression">Simple linear regression</a></li>
      <li><a href="#multiple-linear-regression" id="markdown-toc-multiple-linear-regression">Multiple linear regression</a></li>
      <li><a href="#the-d--n-problem" id="markdown-toc-the-d--n-problem">The $D &gt; N$ problem</a></li>
    </ul>
  </li>
  <li><a href="#cost-functions" id="markdown-toc-cost-functions">Cost functions</a>    <ul>
      <li><a href="#properties" id="markdown-toc-properties">Properties</a></li>
      <li><a href="#good-cost-functions" id="markdown-toc-good-cost-functions">Good cost functions</a>        <ul>
          <li><a href="#mse" id="markdown-toc-mse">MSE</a></li>
          <li><a href="#mae" id="markdown-toc-mae">MAE</a></li>
        </ul>
      </li>
      <li><a href="#convexity" id="markdown-toc-convexity">Convexity</a></li>
    </ul>
  </li>
  <li><a href="#optimization" id="markdown-toc-optimization">Optimization</a>    <ul>
      <li><a href="#learning--estimation--fitting" id="markdown-toc-learning--estimation--fitting">Learning / Estimation / Fitting</a></li>
      <li><a href="#grid-search" id="markdown-toc-grid-search">Grid search</a></li>
      <li><a href="#optimization-landscapes" id="markdown-toc-optimization-landscapes">Optimization landscapes</a>        <ul>
          <li><a href="#local-minimum" id="markdown-toc-local-minimum">Local minimum</a></li>
          <li><a href="#global-minimum" id="markdown-toc-global-minimum">Global minimum</a></li>
          <li><a href="#strict-minimum" id="markdown-toc-strict-minimum">Strict minimum</a></li>
        </ul>
      </li>
      <li><a href="#smooth-differentiable-optimization" id="markdown-toc-smooth-differentiable-optimization">Smooth (differentiable) optimization</a>        <ul>
          <li><a href="#gradient" id="markdown-toc-gradient">Gradient</a></li>
          <li><a href="#gradient-descent" id="markdown-toc-gradient-descent">Gradient descent</a></li>
          <li><a href="#gradient-descent-for-linear-mse" id="markdown-toc-gradient-descent-for-linear-mse">Gradient descent for linear MSE</a></li>
          <li><a href="#stochastic-gradient-descent-sgd" id="markdown-toc-stochastic-gradient-descent-sgd">Stochastic gradient descent (SGD)</a></li>
          <li><a href="#mini-batch-sgd" id="markdown-toc-mini-batch-sgd">Mini-batch SGD</a></li>
        </ul>
      </li>
      <li><a href="#non-smooth-non-differentiable-optimization" id="markdown-toc-non-smooth-non-differentiable-optimization">Non-smooth (non-differentiable) optimization</a>        <ul>
          <li><a href="#subgradients" id="markdown-toc-subgradients">Subgradients</a></li>
          <li><a href="#subgradient-descent" id="markdown-toc-subgradient-descent">Subgradient descent</a></li>
          <li><a href="#stochastic-subgradient-descent" id="markdown-toc-stochastic-subgradient-descent">Stochastic subgradient descent</a></li>
        </ul>
      </li>
      <li><a href="#comparison" id="markdown-toc-comparison">Comparison</a></li>
      <li><a href="#constrained-optimization" id="markdown-toc-constrained-optimization">Constrained optimization</a>        <ul>
          <li><a href="#convex-sets" id="markdown-toc-convex-sets">Convex sets</a></li>
          <li><a href="#projected-gradient-descent" id="markdown-toc-projected-gradient-descent">Projected gradient descent</a></li>
          <li><a href="#turning-constrained-problems-into-unconstrained-problems" id="markdown-toc-turning-constrained-problems-into-unconstrained-problems">Turning constrained problems into unconstrained problems</a></li>
        </ul>
      </li>
      <li><a href="#implementation-issues-in-gradient-methods" id="markdown-toc-implementation-issues-in-gradient-methods">Implementation issues in gradient methods</a>        <ul>
          <li><a href="#stopping-criteria" id="markdown-toc-stopping-criteria">Stopping criteria</a></li>
          <li><a href="#optimality" id="markdown-toc-optimality">Optimality</a></li>
          <li><a href="#step-size" id="markdown-toc-step-size">Step size</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#least-squares" id="markdown-toc-least-squares">Least squares</a>    <ul>
      <li><a href="#normal-equations" id="markdown-toc-normal-equations">Normal equations</a></li>
      <li><a href="#single-parameter-linear-regression" id="markdown-toc-single-parameter-linear-regression">Single parameter linear regression</a></li>
      <li><a href="#multiple-parameter-linear-regression" id="markdown-toc-multiple-parameter-linear-regression">Multiple parameter linear regression</a>        <ul>
          <li><a href="#simplest-way" id="markdown-toc-simplest-way">Simplest way</a></li>
          <li><a href="#directly-verify-the-definition" id="markdown-toc-directly-verify-the-definition">Directly verify the definition</a></li>
          <li><a href="#compute-the-hessian" id="markdown-toc-compute-the-hessian">Compute the Hessian</a></li>
        </ul>
      </li>
      <li><a href="#geometric-interpretation" id="markdown-toc-geometric-interpretation">Geometric interpretation</a></li>
      <li><a href="#closed-form" id="markdown-toc-closed-form">Closed form</a></li>
      <li><a href="#invertibility-and-uniqueness" id="markdown-toc-invertibility-and-uniqueness">Invertibility and uniqueness</a></li>
    </ul>
  </li>
  <li><a href="#maximum-likelihood" id="markdown-toc-maximum-likelihood">Maximum likelihood</a>    <ul>
      <li><a href="#gaussian-distribution" id="markdown-toc-gaussian-distribution">Gaussian distribution</a></li>
      <li><a href="#a-probabilistic-model-for-least-squares" id="markdown-toc-a-probabilistic-model-for-least-squares">A probabilistic model for least squares</a></li>
      <li><a href="#defining-cost-with-log-likelihood" id="markdown-toc-defining-cost-with-log-likelihood">Defining cost with log-likelihood</a></li>
      <li><a href="#maximum-likelihood-estimator-mle" id="markdown-toc-maximum-likelihood-estimator-mle">Maximum likelihood estimator (MLE)</a>        <ul>
          <li><a href="#properties-of-mle" id="markdown-toc-properties-of-mle">Properties of MLE</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#overfitting-and-underfitting" id="markdown-toc-overfitting-and-underfitting">Overfitting and underfitting</a>    <ul>
      <li><a href="#underfitting-with-linear-models" id="markdown-toc-underfitting-with-linear-models">Underfitting with linear models</a></li>
      <li><a href="#extended-feature-vectors" id="markdown-toc-extended-feature-vectors">Extended feature vectors</a></li>
      <li><a href="#reducing-overfitting" id="markdown-toc-reducing-overfitting">Reducing overfitting</a></li>
    </ul>
  </li>
  <li><a href="#regularization" id="markdown-toc-regularization">Regularization</a>    <ul>
      <li><a href="#l_2-regularization-ridge-regression" id="markdown-toc-l_2-regularization-ridge-regression">$L_2$-Regularization: Ridge Regression</a>        <ul>
          <li><a href="#ridge-regression" id="markdown-toc-ridge-regression">Ridge regression</a></li>
          <li><a href="#ridge-regression-to-fight-ill-conditioning" id="markdown-toc-ridge-regression-to-fight-ill-conditioning">Ridge regression to fight ill-conditioning</a></li>
        </ul>
      </li>
      <li><a href="#l_1-regularization-the-lasso" id="markdown-toc-l_1-regularization-the-lasso">$L_1$-Regularization: The Lasso</a></li>
    </ul>
  </li>
  <li><a href="#model-selection" id="markdown-toc-model-selection">Model selection</a>    <ul>
      <li><a href="#probabilistic-setup" id="markdown-toc-probabilistic-setup">Probabilistic setup</a></li>
      <li><a href="#training-error-vs-generalization-error" id="markdown-toc-training-error-vs-generalization-error">Training Error vs. Generalization Error</a></li>
      <li><a href="#splitting-the-data" id="markdown-toc-splitting-the-data">Splitting the data</a></li>
      <li><a href="#generalization-error-vs-test-error" id="markdown-toc-generalization-error-vs-test-error">Generalization error vs test error</a></li>
      <li><a href="#method-and-criteria-for-model-selection" id="markdown-toc-method-and-criteria-for-model-selection">Method and criteria for model selection</a>        <ul>
          <li><a href="#grid-search-on-hyperparameters" id="markdown-toc-grid-search-on-hyperparameters">Grid search on hyperparameters</a></li>
          <li><a href="#model-selection-based-on-test-error" id="markdown-toc-model-selection-based-on-test-error">Model selection based on test error</a></li>
        </ul>
      </li>
      <li><a href="#cross-validation" id="markdown-toc-cross-validation">Cross-validation</a></li>
      <li><a href="#bias-variance-decomposition" id="markdown-toc-bias-variance-decomposition">Bias-Variance decomposition</a>        <ul>
          <li><a href="#data-generation-model" id="markdown-toc-data-generation-model">Data generation model</a></li>
          <li><a href="#error-decomposition" id="markdown-toc-error-decomposition">Error Decomposition</a></li>
          <li><a href="#interpretation-of-the-decomposition" id="markdown-toc-interpretation-of-the-decomposition">Interpretation of the decomposition</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#classification" id="markdown-toc-classification">Classification</a>    <ul>
      <li><a href="#linear-classifier" id="markdown-toc-linear-classifier">Linear classifier</a></li>
      <li><a href="#is-classification-a-special-case-of-regression" id="markdown-toc-is-classification-a-special-case-of-regression">Is classification a special case of regression?</a></li>
      <li><a href="#nearest-neighbor" id="markdown-toc-nearest-neighbor">Nearest neighbor</a></li>
      <li><a href="#linear-decision-boundaries" id="markdown-toc-linear-decision-boundaries">Linear decision boundaries</a></li>
      <li><a href="#optimal-classification-for-a-known-generating-model" id="markdown-toc-optimal-classification-for-a-known-generating-model">Optimal classification for a known generating model</a></li>
    </ul>
  </li>
  <li><a href="#logistic-regression" id="markdown-toc-logistic-regression">Logistic regression</a>    <ul>
      <li><a href="#training" id="markdown-toc-training">Training</a></li>
      <li><a href="#conditions-of-optimality" id="markdown-toc-conditions-of-optimality">Conditions of optimality</a></li>
      <li><a href="#gradient-descent-1" id="markdown-toc-gradient-descent-1">Gradient descent</a></li>
      <li><a href="#newtons-method" id="markdown-toc-newtons-method">Newtonâs method</a>        <ul>
          <li><a href="#hessian-of-the-cost" id="markdown-toc-hessian-of-the-cost">Hessian of the cost</a></li>
          <li><a href="#closed-form-for-newtons-method" id="markdown-toc-closed-form-for-newtons-method">Closed form for Newtonâs method</a></li>
        </ul>
      </li>
      <li><a href="#regularized-logistic-regression" id="markdown-toc-regularized-logistic-regression">Regularized logistic regression</a></li>
    </ul>
  </li>
  <li><a href="#generalized-linear-models" id="markdown-toc-generalized-linear-models">Generalized Linear Models</a>    <ul>
      <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
      <li><a href="#exponential-family" id="markdown-toc-exponential-family">Exponential family</a>        <ul>
          <li><a href="#link-function" id="markdown-toc-link-function">Link function</a></li>
          <li><a href="#example-bernoulli" id="markdown-toc-example-bernoulli">Example: Bernoulli</a></li>
          <li><a href="#example-poisson" id="markdown-toc-example-poisson">Example: Poisson</a></li>
          <li><a href="#example-gaussian" id="markdown-toc-example-gaussian">Example: Gaussian</a></li>
          <li><a href="#properties-1" id="markdown-toc-properties-1">Properties</a></li>
        </ul>
      </li>
      <li><a href="#application-in-ml" id="markdown-toc-application-in-ml">Application in ML</a>        <ul>
          <li><a href="#maximum-likelihood-parameter-estimation" id="markdown-toc-maximum-likelihood-parameter-estimation">Maximum Likelihood Parameter Estimation</a></li>
          <li><a href="#conditions-of-optimality-1" id="markdown-toc-conditions-of-optimality-1">Conditions of optimality</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#nearest-neighbor-classifiers-and-the-curse-of-dimensionality" id="markdown-toc-nearest-neighbor-classifiers-and-the-curse-of-dimensionality">Nearest neighbor classifiers and the curse of dimensionality</a>    <ul>
      <li><a href="#k-nearest-neighbor-knn" id="markdown-toc-k-nearest-neighbor-knn">K Nearest Neighbor (KNN)</a></li>
      <li><a href="#analysis" id="markdown-toc-analysis">Analysis</a></li>
    </ul>
  </li>
  <li><a href="#support-vector-machines" id="markdown-toc-support-vector-machines">Support Vector Machines</a>    <ul>
      <li><a href="#definition" id="markdown-toc-definition">Definition</a></li>
      <li><a href="#alternative-formulation-duality" id="markdown-toc-alternative-formulation-duality">Alternative formulation: Duality</a>        <ul>
          <li><a href="#how-do-we-find-a-suitable-function-g" id="markdown-toc-how-do-we-find-a-suitable-function-g">How do we find a suitable function G?</a></li>
          <li><a href="#when-is-it-ok-to-switch-min-and-max" id="markdown-toc-when-is-it-ok-to-switch-min-and-max">When is it OK to switch min and max?</a></li>
          <li><a href="#when-is-the-dual-easier-to-optimize-than-the-primal" id="markdown-toc-when-is-the-dual-easier-to-optimize-than-the-primal">When is the dual easier to optimize than the primal?</a></li>
        </ul>
      </li>
      <li><a href="#kernel-trick" id="markdown-toc-kernel-trick">Kernel trick</a>        <ul>
          <li><a href="#alternative-formulation-of-ridge-regression" id="markdown-toc-alternative-formulation-of-ridge-regression">Alternative formulation of ridge regression</a></li>
          <li><a href="#representer-theorem" id="markdown-toc-representer-theorem">Representer theorem</a></li>
          <li><a href="#kernelized-ridge-regression" id="markdown-toc-kernelized-ridge-regression">Kernelized ridge regression</a></li>
          <li><a href="#kernel-functions" id="markdown-toc-kernel-functions">Kernel functions</a>            <ul>
              <li><a href="#trivial-kernels" id="markdown-toc-trivial-kernels">Trivial kernels</a></li>
              <li><a href="#polynomial-kernel" id="markdown-toc-polynomial-kernel">Polynomial kernel</a></li>
              <li><a href="#radial-basis-function-kernel" id="markdown-toc-radial-basis-function-kernel">Radial basis function kernel</a></li>
              <li><a href="#new-kernel-functions-from-old-ones" id="markdown-toc-new-kernel-functions-from-old-ones">New kernel functions from old ones</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#classifying-with-the-kernel" id="markdown-toc-classifying-with-the-kernel">Classifying with the kernel</a></li>
      <li><a href="#properties-of-kernels" id="markdown-toc-properties-of-kernels">Properties of kernels</a></li>
    </ul>
  </li>
  <li><a href="#unsupervised-learning" id="markdown-toc-unsupervised-learning">Unsupervised learning</a>    <ul>
      <li><a href="#k-means" id="markdown-toc-k-means">K-Means</a>        <ul>
          <li><a href="#coordinate-descent-interpretation" id="markdown-toc-coordinate-descent-interpretation">Coordinate descent interpretation</a></li>
          <li><a href="#matrix-factorization-interpretation" id="markdown-toc-matrix-factorization-interpretation">Matrix factorization interpretation</a></li>
          <li><a href="#probabilistic-interpretation" id="markdown-toc-probabilistic-interpretation">Probabilistic interpretation</a></li>
          <li><a href="#issues-with-k-means" id="markdown-toc-issues-with-k-means">Issues with K-means</a></li>
        </ul>
      </li>
      <li><a href="#gaussian-mixture-model-gmm" id="markdown-toc-gaussian-mixture-model-gmm">Gaussian Mixture Model (GMM)</a>        <ul>
          <li><a href="#clustering-with-gaussians" id="markdown-toc-clustering-with-gaussians">Clustering with Gaussians</a></li>
          <li><a href="#soft-clustering" id="markdown-toc-soft-clustering">Soft clustering</a></li>
          <li><a href="#likelihood" id="markdown-toc-likelihood">Likelihood</a></li>
          <li><a href="#marginal-likelihood" id="markdown-toc-marginal-likelihood">Marginal likelihood</a></li>
          <li><a href="#maximum-likelihood-1" id="markdown-toc-maximum-likelihood-1">Maximum likelihood</a></li>
        </ul>
      </li>
      <li><a href="#em-algorithm" id="markdown-toc-em-algorithm">EM algorithm</a>        <ul>
          <li><a href="#expectation-step" id="markdown-toc-expectation-step">Expectation step</a></li>
          <li><a href="#maximization-step" id="markdown-toc-maximization-step">Maximization step</a></li>
          <li><a href="#interpretation" id="markdown-toc-interpretation">Interpretation</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#matrix-factorization" id="markdown-toc-matrix-factorization">Matrix Factorization</a>    <ul>
      <li><a href="#prediction-using-a-matrix-factorization" id="markdown-toc-prediction-using-a-matrix-factorization">Prediction using a matrix factorization</a></li>
      <li><a href="#choosing-k" id="markdown-toc-choosing-k">Choosing K</a></li>
      <li><a href="#regularization-1" id="markdown-toc-regularization-1">Regularization</a></li>
      <li><a href="#stochastic-gradient-descent" id="markdown-toc-stochastic-gradient-descent">Stochastic gradient descent</a></li>
      <li><a href="#alternating-least-squares-als" id="markdown-toc-alternating-least-squares-als">Alternating least squares (ALS)</a>        <ul>
          <li><a href="#no-missing-entries" id="markdown-toc-no-missing-entries">No missing entries</a></li>
          <li><a href="#missing-entries" id="markdown-toc-missing-entries">Missing entries</a></li>
        </ul>
      </li>
      <li><a href="#text-representation-learning" id="markdown-toc-text-representation-learning">Text representation learning</a>        <ul>
          <li><a href="#co-occurrence-matrix" id="markdown-toc-co-occurrence-matrix">Co-occurrence matrix</a></li>
          <li><a href="#motivation-1" id="markdown-toc-motivation-1">Motivation</a></li>
          <li><a href="#bag-of-words" id="markdown-toc-bag-of-words">Bag of words</a></li>
          <li><a href="#word2vec" id="markdown-toc-word2vec">Word2vec</a></li>
          <li><a href="#glove" id="markdown-toc-glove">GloVe</a></li>
          <li><a href="#fasttext" id="markdown-toc-fasttext">FastText</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#svd-and-pca" id="markdown-toc-svd-and-pca">SVD and PCA</a>    <ul>
      <li><a href="#motivation-2" id="markdown-toc-motivation-2">Motivation</a></li>
      <li><a href="#svd" id="markdown-toc-svd">SVD</a></li>
      <li><a href="#svd-and-dimensionality-reduction" id="markdown-toc-svd-and-dimensionality-reduction">SVD and dimensionality reduction</a>        <ul>
          <li><a href="#svd-and-matrix-factorization" id="markdown-toc-svd-and-matrix-factorization">SVD and matrix factorization</a></li>
        </ul>
      </li>
      <li><a href="#pca-and-decorrelation" id="markdown-toc-pca-and-decorrelation">PCA and decorrelation</a></li>
      <li><a href="#computing-the-svd-efficiently" id="markdown-toc-computing-the-svd-efficiently">Computing the SVD efficiently</a></li>
      <li><a href="#pitfalls-of-pca" id="markdown-toc-pitfalls-of-pca">Pitfalls of PCA</a></li>
    </ul>
  </li>
  <li><a href="#neural-networks" id="markdown-toc-neural-networks">Neural Networks</a>    <ul>
      <li><a href="#motivation-3" id="markdown-toc-motivation-3">Motivation</a></li>
      <li><a href="#structure" id="markdown-toc-structure">Structure</a></li>
      <li><a href="#how-powerful-are-neural-nets" id="markdown-toc-how-powerful-are-neural-nets">How powerful are neural nets?</a></li>
      <li><a href="#approximation-in-average" id="markdown-toc-approximation-in-average">Approximation in average</a>        <ul>
          <li><a href="#other-activation-functions" id="markdown-toc-other-activation-functions">Other activation functions</a></li>
        </ul>
      </li>
      <li><a href="#popular-activation-functions" id="markdown-toc-popular-activation-functions">Popular activation functions</a>        <ul>
          <li><a href="#sigmoid" id="markdown-toc-sigmoid">Sigmoid</a></li>
          <li><a href="#tanh" id="markdown-toc-tanh">Tanh</a></li>
          <li><a href="#relu" id="markdown-toc-relu">ReLU</a></li>
          <li><a href="#leaky-relu" id="markdown-toc-leaky-relu">Leaky ReLU</a></li>
          <li><a href="#maxout" id="markdown-toc-maxout">Maxout</a></li>
        </ul>
      </li>
      <li><a href="#sgd-and-backpropagation" id="markdown-toc-sgd-and-backpropagation">SGD and Backpropagation</a></li>
      <li><a href="#regularization-2" id="markdown-toc-regularization-2">Regularization</a></li>
      <li><a href="#dataset-augmentation" id="markdown-toc-dataset-augmentation">Dataset augmentation</a></li>
      <li><a href="#dropout" id="markdown-toc-dropout">Dropout</a></li>
      <li><a href="#convolutional-nets" id="markdown-toc-convolutional-nets">Convolutional nets</a>        <ul>
          <li><a href="#structure-1" id="markdown-toc-structure-1">Structure</a></li>
          <li><a href="#padding" id="markdown-toc-padding">Padding</a></li>
          <li><a href="#channels" id="markdown-toc-channels">Channels</a></li>
          <li><a href="#training-1" id="markdown-toc-training-1">Training</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#bayes-nets" id="markdown-toc-bayes-nets">Bayes Nets</a>    <ul>
      <li><a href="#from-distribution-to-graphs" id="markdown-toc-from-distribution-to-graphs">From distribution to graphs</a></li>
      <li><a href="#cyclic-graphs" id="markdown-toc-cyclic-graphs">Cyclic graphs</a></li>
      <li><a href="#conditional-independence" id="markdown-toc-conditional-independence">Conditional independence</a>        <ul>
          <li><a href="#tail-to-tail" id="markdown-toc-tail-to-tail">Tail-to-tail</a></li>
          <li><a href="#head-to-tail" id="markdown-toc-head-to-tail">Head-to-tail</a></li>
          <li><a href="#head-to-head" id="markdown-toc-head-to-head">Head-to-head</a></li>
          <li><a href="#d-separation" id="markdown-toc-d-separation">D-separation</a></li>
          <li><a href="#examples" id="markdown-toc-examples">Examples</a></li>
        </ul>
      </li>
      <li><a href="#markov-blankets" id="markdown-toc-markov-blankets">Markov blankets</a></li>
      <li><a href="#sampling-and-marginalizing" id="markdown-toc-sampling-and-marginalizing">Sampling and marginalizing</a></li>
      <li><a href="#factor-graphs" id="markdown-toc-factor-graphs">Factor graphs</a></li>
    </ul>
  </li>
</ul>

<p>In this course, weâll always denote the dataset as a $N \times D$ matrix $\mathbf{X}$, where $N$ is the data size and $D$ is the dimensionality, or the number of features. Weâll always use subscript $n$ for data point, and $d$ for feature. The labels, if any, are denoted in a $\mathbf{y}$ vector, and the weights are denoted by $\mathbf{w}$:</p>

\[\newcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\abs}[1]{\left\lvert#1\right\rvert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\frobnorm}[1]{\norm{#1}_{\text{Frob}}}
\newcommand{\expect}[1]{\mathbb{E}\left[#1\right]}
\newcommand{\expectsub}[2]{\mathbb{E}_{#1}\left[#2\right]}
\newcommand{\cost}[1]{\mathcal{L}\left(#1\right)}
\newcommand{\normal}[1]{\mathcal{N}\left(#1\right)}
\newcommand{\diff}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\difftwo}[3]{\frac{\partial^2 #1}{\partial #2 \partial #3}}
\newcommand{\Strain}{S_{\text{train}}}
\newcommand{\Stest}{S_{\text{test}}}
\DeclareMathOperator*{\argmax}{\arg\!\max}
\DeclareMathOperator*{\argmin}{\arg\!\min}

\vec{w}=\begin{bmatrix}
    w_1 \\ w_2 \\ \vdots \\ w_N
\end{bmatrix},
\quad
\vec{y}=\begin{bmatrix}
    y_1 \\ y_2 \\ \vdots \\ y_N
\end{bmatrix}, 
\quad
\vec{X}=\begin{bmatrix}
x_{11} &amp; x_{12} &amp; \dots &amp; x_{1D} \\
x_{21} &amp; x_{22} &amp; \dots &amp; x_{2D} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{N1} &amp; x_{N2} &amp; \dots &amp; x_{ND} \\
\end{bmatrix}\]

<p>Vectors are denoted in bold and lowercase (e.g. $\vec{y}$ or $\vec{x}_n$), and matrices are bold and uppercase (e.g. $\vec{X}$). Scalars and functions are in normal font weight<sup id="fnref:here-be-dragons" role="doc-noteref"><a href="#fn:here-be-dragons" class="footnote">1</a></sup>.</p>

<h2 id="linear-regression">Linear regression</h2>
<p>A linear regression is a model that assumes a linear relationship between inputs and the output. We will study three types of methods:</p>

<ol>
  <li>Grid search</li>
  <li>Iterative optimization algorithms</li>
  <li>Least squares</li>
</ol>

<h3 id="simple-linear-regression">Simple linear regression</h3>

<p>For a single input dimension ($D=1$), we can use a simple linear regression, which is given by:</p>

\[y_n \approx f(x_n) := w_0 + w_1 x_{n1}\]

<p>$\vec{w} = (w_0, w_1)$ are the parameters of the model.</p>

<h3 id="multiple-linear-regression">Multiple linear regression</h3>

<p>If our data has multiple input dimensions, we obtain multivariate linear regression:</p>

\[y_n \approx 
    f(\vec{x}_n) := w_0 + w_1 x_{n1} + \dots + w_D x_{wD} 
    = w_0 + \vec{x}_n^T \begin{bmatrix}
        w_1 \\
        \vdots \\
        w_D \\
    \end{bmatrix}
    = \tilde{\vec{x}}_n^T \tilde{\vec{w}}\]

<blockquote>
  <p>ð If we wanted to be a little more strict, we should write $f_{\vec{w}}(\vec{x}_n)$, as the model of course also depends on the weights.</p>
</blockquote>

<p>The tilde notation means that we have included the offset term $w_0$, also known as the <strong>bias</strong>:</p>

\[\tilde{\vec{x}}_n=\begin{bmatrix}1 \\ x_{n1} \\ \vdots \\ x_{nD} \end{bmatrix} \in \mathbb{R}^{D+1}, 
\quad
\tilde{\vec{w}} = \begin{bmatrix}w_0 \\ w_1 \\ \vdots \\ w_D\end{bmatrix} \in \mathbb{R^{D+1}}\]

<h3 id="the-d--n-problem">The $D &gt; N$ problem</h3>

<p>If the number of parameters exceeds the number of data examples, we say that the task is <em>under-determined</em>. This can be solved by regularization, which weâll get to more precisely later.</p>

<h2 id="cost-functions">Cost functions</h2>

<p>$\vec{x}_n$ is the data, which we can easily understand where comes from. But how does one find a good $\vec{w}$ from the data?</p>

<p>A <strong>cost function</strong> (also called loss function) is used to learn parameters that explain the data well. It quantifies how well our model does by giving errors a score, quantifying penalties for errors. Our goal is to find parameters that minimize the loss functions.</p>

<h3 id="properties">Properties</h3>

<p>Desirable properties of cost functions are:</p>

<ul>
  <li><strong>Symmetry around 0</strong>: that is, being off by a positive or negative amount is equivalent; what matters is the amplitude of the error, not the sign.</li>
  <li><strong>Robustness</strong>: penalizes large errors at about the same rate as very large errors. This is a way to make sure that outliers donât completely dominate our regression.</li>
</ul>

<h3 id="good-cost-functions">Good cost functions</h3>

<h4 id="mse">MSE</h4>

<p>Probably the most commonly used cost function is Mean Square Error (MSE):</p>

\[\mathcal{L}_{\text{MSE}}(\vec{w}) := \frac{1}{N} \sum_{n=1}^N \left(y_n - f(\vec{x}_n)\right)^2
\label{def:mse}\]

<p>MSE is symmetrical around 0, but also tends to penalize outliers quite harshly (because it squares error): MSE is not robust. In practice, this is problematic, because outliers occur more often than weâd like to.</p>

<p>Note that we often use MSE with a factor $\frac{1}{2N}$ instead of $\frac{1}{N}$. This is because it makes for a cleaner derivative, but weâll get into that later. Just know that for all intents and purposes, it doesnât really change anything about the behavior of the models weâll study.</p>

<h4 id="mae">MAE</h4>

<p>When outliers are present, Mean Absolute Error (MAE) tends to fare better:</p>

\[\text{MAE}(\vec{w}) := \frac{1}{N} \sum_{n=1}^N \left| y_n - f(\vec{x}_n)\right|\]

<p>Instead of squaring, we take the absolute value. This is more robust. Note that MAE isnât differentiable at 0, but weâll talk about that later.</p>

<p>There are other cost functions that are even more robust; these are available as additional reading, but are not exam material.</p>

<h3 id="convexity">Convexity</h3>

<p>A function is <strong>convex</strong> iff a line joining two points never intersects with the function anywhere else. More strictly defined, a function $f(\vec{u})$ with $\vec{u}\in\chi$ is <em>convex</em> if, for any $\vec{u}, \vec{v} \in\chi$, and for any $0 \le\lambda\le 1$, we have:</p>

\[f(\lambda\vec{u}+(1-\lambda)\vec{v})\le\lambda f(\vec{u}) +(1-\lambda)f(\vec{v})\]

<p>A function is <strong>strictly convex</strong> if the above inequality is strict ($&lt;$). This inequality is known as <em>Jensenâs inequality</em>.</p>

<p>A strictly convex function has a unique global minimum $\vec{w}^*$. For convex functions, every local minimum is a global minimum. This makes it a desirable property for loss functions, since it means that cost function optimization is guaranteed to find the global minimum.</p>

<p>Linear (and affine) functions are convex, and sums of convex functions are also convex. Therefore, MSE and MAE are convex.</p>

<p>Weâll see another way of characterizing convexity for differentiable functions <a href="#non-smooth-non-differentiable-optimization">later in the course</a>.</p>

<h2 id="optimization">Optimization</h2>

<h3 id="learning--estimation--fitting">Learning / Estimation / Fitting</h3>

<p>Given a cost function (or loss function) $\cost{\vec{w}}$, we wish to find $\vec{w}^*$ which minimizes the cost:</p>

\[\min_{\vec{w}}{\cost{\vec{w}}}, \quad\text{ subject to } \vec{w} \in \mathbb{R}^D\]

<p>This is what we call <strong>learning</strong>: learning is simply an optimization problem, and as such, weâll use an optimization algorithm to solve it â that is, find a good $\vec{w}$.</p>

<h3 id="grid-search">Grid search</h3>

<p>This is one of the simplest optimization algorithms, although far from being the most efficient one. It can be described as âtry all the valuesâ, a kind of brute-force algorithm; you can think of it as nested for-loops over the individual $w_i$ weights.</p>

<p>For instance, if our weights are $\vec{w} = \begin{bmatrix}w_1 \ w_2\end{bmatrix}$, then we can try, say 4 values for $w_1$, 4 values for $w_2$, for a total of 16 values of $\mathcal{L}(\vec{w})$.</p>

<p>But obviously, complexity is exponential $\mathcal{O}(a^D)$ (where $a$ is the number of values to try), which is really bad, especially when we can have $D\approx$ millions of parameters. Additionally, grid search has no guarantees that itâll find an optimum; itâll just find the best value we tried.</p>

<p>If grid search sounds bad for optimization, thatâs because it is. In practice, it is not used for optimization of parameters, but it <em>is</em> used to tune hyperparameters.</p>

<h3 id="optimization-landscapes">Optimization landscapes</h3>

<h4 id="local-minimum">Local minimum</h4>

<p>A vector $\vec{w}^*$ is a <em>local minimum</em> of a function $\mathcal{L}$ (weâre interested in the minimum of cost functions $\mathcal{L}$, which we denote with $\vec{w}^*$, as opposed to any other value $\vec{w}$, but this obviously holds for any function) if $\exists \epsilon &gt; 0$ such that</p>

\[\mathcal{L}(\vec{w}^*) \le \mathcal{L(\vec{w})}, \quad \forall \vec{w} : \norm{\vec{w} -\vec{w}^*} &lt; \epsilon\]

<p>In other words, the local minimum $\vec{w}^*$ is better than all the neighbors in some non-zero radius.</p>

<h4 id="global-minimum">Global minimum</h4>

<p>The global minimum $\vec{w}^*$ is defined by getting rid of the radius $\epsilon$ and comparing to all other values:</p>

\[\cost{\vec{w}^*} \le \cost{\vec{w}}, \qquad \forall\vec{w}\in\mathbb{R}^D\]

<h4 id="strict-minimum">Strict minimum</h4>

<p>A minimum is said to be <strong>strict</strong> if the corresponding equality is strict for $\vec{w} \ne \vec{w}^*$, that is, there is only one minimum value.</p>

\[\cost{\vec{w}^*} &lt; \cost{\vec{w}}, \qquad \forall\vec{w}\in\mathbb{R}^D\setminus\set{\vec{w}^*}\]

<h3 id="smooth-differentiable-optimization">Smooth (differentiable) optimization</h3>

<h4 id="gradient">Gradient</h4>

<p>A gradient at a given point is the slope of the tangent to the function at that point. It points to the direction of largest increase of the function. By following the gradient (in the opposite direction, because weâre searching for a minimum and not a maximum), we can find the minimum.</p>

<p><img src="/images/ml/mse-mae.png" alt="Graphs of MSE and MAE" /></p>

<p>Gradient is defined by:</p>

\[\nabla \mathcal{L}(\vec{w}) := \begin{bmatrix}
    \diff{\cost{\vec{w}}}{w_1} &amp; 
    \diff{\cost{\vec{w}}}{w_2} &amp; 
	\cdots &amp;
	\diff{\cost{\vec{w}}}{w_D}  \\
\end{bmatrix}^T\]

<p>This is a vector, i.e. $\nabla\cost{\vec{w}}\in\mathbb R^D$. Each dimension $i$ of the vector indicates how fast the cost $\mathcal{L}$ changes depending on the weight $w_i$.</p>

<h4 id="gradient-descent">Gradient descent</h4>

<p>Gradient descent is an iterative algorithm. We start from a candidate $\vec{w}^{(t)}$, and iterate.</p>

\[\vec{w}^{(t+1)}:=\vec{w}^{(t)} - \gamma \nabla\mathcal{L}\left(\vec{w}^{(t)}\right)\]

<p>As stated previously, weâre adding the negative gradient to find the minimum, hence the subtraction.</p>

<p>$\gamma$ is known as the <strong>step-size</strong>, which is a small value (maybe 0.1). You donât want to be too aggressive with it, or you might risk overshooting in your descent. In practice, the step-size that makes the learning as fast as possible is often found by trial and error ð¤·ð¼ââï¸.</p>

<p>As an example, we will take an analytical look at a gradient descent, in order to understand its behavior and components. We will do gradient descent on a 1-parameter model ($D=1$ and $\vec{w} = [w_0]$), in which we minimize the MSE, which is defined as follows:</p>

\[\mathcal{L}\left(w_0\right)=\frac{1}{2N}\sum_{n=1}^N{\left(y_n - w_0\right)^2}\]

<p>Note that weâre dividing by 2 on top of the regular MSE; it has no impact on finding the minimum, but when we will compute the gradient below, it will conveniently cancel out the $\frac{1}{2}$.</p>

<p>The gradient of $\cost{w_0}$ is:</p>

\[\begin{align}
\nabla\cost{\vec{w}}
	&amp; = \frac{\partial}{\partial w_0}\cost{\vec{w}} \\
	&amp; = \frac{1}{2N}\sum_{n=1}^N{-2(y_n - w_0)}  \\
	&amp; = w_0 - \bar{y}
\end{align}\]

<p>Where $\bar{y}$ denotes the average of all $y_n$ values. And thus, our gradient descent is given by:</p>

\[\begin{align}
w_0^{(t+1)}
	&amp;:= w_0^{(t)} - \gamma\nabla\mathcal{L}\left(\vec{w}\right) \\
	&amp; = w_0^{(t)} - \gamma(w_0^{(t)} - \bar{y}) \\
	&amp; = (1-\gamma)w_0^{(t)} + \gamma\bar{y}, 
	\qquad\text{where } \bar{y}:=\sum_{n}{\frac{y_n}{N}}
\end{align}\]

<p>In this case, weâve managed to find to this exact problem analytically from gradient descent. This sequence is guaranteed to converge to $\vec{w}^* = \bar{y}$<sup id="fnref:optimality-linear-mse" role="doc-noteref"><a href="#fn:optimality-linear-mse" class="footnote">2</a></sup>. This would set the cost function to 0, which is the minimum.</p>

<p>The choice of $\gamma$ has an influence on the algorithmâs outcome:</p>

<ul>
  <li>If we pick $\gamma=1$, we would get to the optimum in one step</li>
  <li>If we pick $\gamma &lt; 1$, we would get a little closer in every step, eventually converging to $\bar{y}$</li>
  <li>If we pick $\gamma &gt; 1$, we are going to overshoot $\bar{y}$. Slightly bigger than 1 (say, 1.5) would still converge; $\gamma=2$ would loop infinitely between two points; $\gamma &gt; 2$ diverges.</li>
</ul>

<h4 id="gradient-descent-for-linear-mse">Gradient descent for linear MSE</h4>

<p>Our linear regression is given by a line $\vec{y}$ that is a regression for some data $\vec{X}$:</p>

\[\vec{y}=\begin{bmatrix}
	y_1 \\ y_2 \\ \vdots \\ y_N
\end{bmatrix}, 
\quad
\vec{X}=\begin{bmatrix}
x_{11} &amp; x_{12} &amp; \dots &amp; x_{1D} \\
x_{21} &amp; x_{22} &amp; \dots &amp; x_{2D} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{N1} &amp; x_{N2} &amp; \dots &amp; x_{ND} \\
\end{bmatrix}\]

<p>We make predictions by multiplying the data by the weights, so our model is:</p>

\[f_{\vec{w}}(\vec{x}_n)=\vec{x}_n^T \vec{w}\]

<p>We define the error vector by:</p>

\[\vec{e}=\vec{y} - \vec{Xw}, 
\quad \text{ or } \quad 
e_n = y_n - \vec{x}_n^T\vec{w}\]

<p>The MSE can then be restated as follows:</p>

\[\mathcal{L}\left(\vec{w}\right)
	:= \frac{1}{2N}\sum_{n=1}^N{\left( y_n - \vec{x}_n^T \vec{w}\right)^2}
	=  \frac{1}{2N}\vec{e}^T\vec{e}\]

<p>And the gradient is, component-wise:</p>

\[\frac{\partial}{\partial\vec{w}_d} \cost{\vec{w}}
	= -\frac{1}{2N} \sum_{n=1}^N {2(y_n - \vec{x}_n^T \vec{w}) x_{nd}}
	= -\frac{1}{N} (\vec{X}_{:d})^T \vec{e}\]

<p>Weâre using column notation $\vec{X}_{:d}$ to signify column $d$ of the matrix $X$.</p>

<p>And thus, all in all, our gradient is:</p>

\[\nabla\cost{\vec{w}} = -\frac{1}{N}\vec{X}^T\vec{e}\]

<p>To compute this expression, we must compute:</p>

<ul>
  <li>The error $\vec{e}$, which takes $2N\cdot D - 1$ floating point operations (flops) for the matrix-vector multiplication, and $N$ for the subtraction, for a total of $2N\cdot D + N - 1$, which is $\mathcal{O}(N\cdot D)$</li>
  <li>The gradient $\nabla\mathcal{L}$, which costs $2N\cdot D + D - 1$, which is $\mathcal{O}(N\cdot D)$.</li>
</ul>

<p>In total, this process is $\mathcal{O}(N\cdot D)$ at every step. This is not too bad, itâs equivalent to reading the data once.</p>

<h4 id="stochastic-gradient-descent-sgd">Stochastic gradient descent (SGD)</h4>

<p>In ML, most cost functions are formulated as a sum of:</p>

\[\mathcal{L}\left(\vec{w}\right) = \frac{1}{N}\sum_{n=1}^N{\mathcal{L}_n(\vec{w})}\]

<p>In practice, this can be expensive to compute, so the solution is to sample a training point $n\in\set{1, N}$ uniformly at random, to be able to make the sum go away.</p>

<p>The stochastic gradient descent step is thus:</p>

\[\vec{w}^{(t+1)}:=\vec{w}^{(t)} - \gamma \nabla\mathcal{L}_n\left({\vec{w}^{(t)}}\right)\]

<p>Why is it allowed to pick just one $n$ instead of the full thing? We wonât give a full proof, but the intuition is that:</p>

\[\expect{\nabla\mathcal{L}_n(\vec{w})}
	= \frac{1}{N} \sum_{n=1}^N{\nabla\mathcal{L}_n(\vec{w})}
	= \nabla\left(\frac{1}{N} \sum_{n=1}^N{\mathcal{L}_n(\vec{w})}\right)
	\equiv \nabla\mathcal{L}\left(\vec{w}\right)\]

<p>The gradient of a single n is:</p>

\[\mathcal{L}_n(\vec{w}) = \frac{1}{2} \left(y_n -\vec{x}_n^T \vec{w}\right)^2 \\
\nabla\mathcal{L}_n(\vec{w}) = (-\vec{x}_n^T) (y_n-\vec{x}_n^T \vec{w})\]

<p>Note that $\vec{x}_n^T \in\mathbb{R}^D$, and $e_n = (y_n-\vec{x}_n^T \vec{w})\in\mathbb{R}$. Computational complexity for this is $\mathcal{O}(D)$.</p>

<h4 id="mini-batch-sgd">Mini-batch SGD</h4>

<p>But perhaps just picking a <strong>single</strong> value is too extreme; there is an intermediate version in which we choose a subset $B\subseteq \set{1, \dots, N}$ instead of a single point.</p>

\[\vec{g} := \frac{1}{|B|}\sum_{n\in B}{\nabla\mathcal{L}_n(\vec{w}^{(t)})} \\
\vec{w}^{(t+1)} := \vec{w}^{(t)} - \gamma\vec{g}\]

<p>Note that if $\abs{B} = N$ then weâre performing a full gradient descent.</p>

<p>The computation of $\vec{g}$ can be parallelized easily over $\abs{B}$ GPU threads, which is quite common in practice; $\abs{B}$ is thus often dictated by the number of available threads.</p>

<p>Computational complexity is $\mathcal{O}(\abs{B}\cdot D)$.</p>

<h3 id="non-smooth-non-differentiable-optimization">Non-smooth (non-differentiable) optimization</h3>

<p>Weâve defined <a href="#convexity">convexity previously</a>, but we can also use the following alternative characterization of convexity, for differentiable functions:</p>

\[\cost{\vec{u}} \ge \cost{\vec{w}} + \nabla \cost{\vec{w}}^T (\vec{u} - \vec{w}) 
\quad \forall \vec{u}, \vec{w}
\iff \mathcal{L} \text{ convex}\]

<p>Meaning that the function must always lie above its linearization (which is the first-order Taylor expansion) to be convex.</p>

<p><img src="/images/ml/convex-above-linearization.png" alt="A convex function lies above its linearization" /></p>

<h4 id="subgradients">Subgradients</h4>

<p>A vector $\vec{g}\in\mathbb{R}^D$ such that:</p>

\[\mathcal{L}\left(\vec{u}\right) \ge \mathcal{L}\left(\vec{w}\right) + \vec{g}^T(\vec{u} - \vec{w}) \quad \forall \vec{u}\]

<p>is called a <strong>subgradient</strong> to the function $\mathcal{L}$ at $\vec{w}$. The subgradient forms a line that is always below the curve, somewhat like the gradient of a convex function.</p>

<p><img src="/images/ml/subgradient-below-function.png" alt="The subgradient lies below the function" /></p>

<p>This definition is valid even for an arbitrary $\mathcal{L}$ that may not be differentiable, and not even necessarily convex.</p>

<p>If the function $\mathcal{L}$ is differentiable at $\vec{w}$, then the <em>only subgradient</em> at $\vec{w}$ is $\vec{g} = \nabla\mathcal{L}\left(\vec{w}\right)$.</p>

<h4 id="subgradient-descent">Subgradient descent</h4>

<p>This is exactly like gradient descent, except for the fact that we use the <em>subgradient</em> $\vec{g}$ at the current iterate $\vec{w}^{(t)}$ instead of the <em>gradient</em>:</p>

\[\vec{w}^{(t+1)} := \vec{w}^{(t)} - \gamma\vec{g}\]

<p>For instance, MAE is not differentiable at 0, so we must use the subgradient.</p>

\[\text{Let }h: \mathbb{R} \rightarrow \mathbb{R}, \quad h(e) := |e| \\
\text{At } e, \text{the subgradient }
g \in \partial h = \begin{cases}
-1 &amp; \text{if } e &lt; 0 \\
[-1, 1] &amp; \text{if } e = 0 \\
1 &amp; \text{if } e &gt; 0 \\
\end{cases}\]

<p>Here, $\partial h$ is somewhat confusing notation for the set of all possible subgradients at our position.</p>

<p>For linear regressions, the (sub)gradient is easy to compute using the <em>chain rule</em>.</p>

<p>Let $h$ be non-differentiable, $q$ differentiable, and $\mathcal{L}\left(\vec{w}\right) = h(q(w))$. The chain rule tells us that, at $\vec{w}$, our subgradient is:</p>

\[g \in \partial h(q(\vec{w})) \cdot \nabla q(\vec{w})\]

<h4 id="stochastic-subgradient-descent">Stochastic subgradient descent</h4>

<p>This is still commonly abbreviated SGD.</p>

<p>Itâs exactly the same, except that $\vec{g}$ is a subgradient to the randomly selected $\mathcal{L}_n$ at the current iterate $\vec{w}^{(t)}$.</p>

<h3 id="comparison">Comparison</h3>

<table>
  <thead>
    <tr>
      <th>Â </th>
      <th>Smooth</th>
      <th>Non-smooth</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Full gradient descent</td>
      <td>Gradient of \(\mathcal{L}\) <br />Complexity is $\mathcal{O}(N\cdot D)$</td>
      <td>Subgradient of $\mathcal{L}$<br />Complexity is $\mathcal{O}(N\cdot D)$</td>
    </tr>
    <tr>
      <td>Stochastic gradient descent</td>
      <td>Gradient of $\mathcal{L}_n$</td>
      <td>Subgradient of $\mathcal{L}_n$</td>
    </tr>
  </tbody>
</table>

<h3 id="constrained-optimization">Constrained optimization</h3>

<p>Sometimes, optimization problems come posed with an additional constraint.</p>

<h4 id="convex-sets">Convex sets</h4>

<p>Weâve seen convexity for functions, but we can also define it for sets. A set $\mathcal{C}$ is convex iff the line segment between any two points of $\mathcal{C}$ lies in $\mathcal{C}$. That is, $\forall \vec{u}, \vec{v} \in \mathcal{C}, \quad \forall 0 \le \theta \le 1$, we have:</p>

\[\theta \vec{u} + (1 - \theta)\vec{v} \in \mathcal{C}\]

<p>This means that the line between any two points in the set $\mathcal{C}$ must also be fully contained within the set.</p>

<p><img src="/images/ml/convex-sets.png" alt="Examples of convex and non-convex sets" /></p>

<p>A couple of properties of convex sets:</p>

<ul>
  <li>Intersection of convex sets is also convex.</li>
  <li>Projections onto convex sets are <strong>unique</strong> (and often efficient to compute).</li>
</ul>

<h4 id="projected-gradient-descent">Projected gradient descent</h4>

<p>When dealing with constrained problems, we have two options. The first one is to add a projection onto $\mathcal{C}$ in every step:</p>

\[P_\mathcal{C}(\vec{w}') := \argmin_{\vec{v}\in\mathcal{C}}{\norm{\vec{v}-\vec{w}'}}\]

<p>The rule for gradient descent can thus be updated to become:</p>

\[\vec{w}^{(t+1)} := P_\mathcal{C}\left(\vec{w}^{(t)} - \gamma \nabla \cost{\vec{w}^{(t)}} \right)\]

<p>This means that at every step, we compute the new $w^{(t+1)}$ normally, but apply a projection on top of that. In other words, if the regular gradient descent sets our weights outside of the constrained space, we project them back.</p>

<figure>
    <img alt="Steps of projected SGD" src="/images/ml/projected-sgd.png" />
    <figcaption>Here, $\vec{w}'$ is the result of regular SGD, i.e. $\vec{w}' = \vec{w}^{(t)} - \gamma \nabla\cost{\vec{w}^{(t)}}$</figcaption>
</figure>

<p>This is the same for stochastic gradient descent, and we have the same convergence properties.</p>

<p>Note that the computational cost of the projection is very important here, since it is performed at every step.</p>

<h4 id="turning-constrained-problems-into-unconstrained-problems">Turning constrained problems into unconstrained problems</h4>

<p>If projection as described above is approach A, this is approach B.</p>

<p>We use a <strong>penalty function</strong>, such as the âbrick wallâ indicator function below:</p>

\[I_\mathcal{C}(\vec{w}) = \begin{cases}
0 &amp; \vec{w} \in \mathcal{C} \\
+\infty &amp; \vec{w} \notin \mathcal{C}
\end{cases}\]

<p>We could also perhaps use something with a less drastic error value than $+\infty$, if we donât care about the constraint quite as extreme.</p>

<p>Note that this is similar to regularization, which weâll talk about later.</p>

<p>Now, instead of directly solving $\min_{\vec{w}\in\mathcal{C}}{\mathcal{L}(\vec{w})}$, we solve for:</p>

\[\min_{\vec{w}\in \mathbb{R}^D} {
    \mathcal{L}(\vec{w}) + I_\mathcal{C}(\vec{w})
}\]

<h3 id="implementation-issues-in-gradient-methods">Implementation issues in gradient methods</h3>

<h4 id="stopping-criteria">Stopping criteria</h4>

<p>When $\norm{\nabla\mathcal{L}(\vec{w})}$ is zero (or close to zero), we are often close to the optimum.</p>

<h4 id="optimality">Optimality</h4>
<p>For a convex optimization problem, a <em>necessary</em> condition for optimality is that the gradient is 0 at the optimum:</p>

\[\text{optimum at }\vec{w}^*, \quad \mathcal{L} \text{ convex} 
\implies 
\nabla\cost{\vec{w}^*} = 0\]

<p>For convex functions, if the gradient is 0, then weâre at an optimum:</p>

\[\nabla\cost{\vec{w}^*} = 0, \quad \mathcal{L} \text{ convex} 
\implies 
\text{optimum at }\vec{w}^*\]

<p>This tells us when $\vec{w}^*$ is an optimum, but says nothing about whether itâs a minimum or a maximum. To know about that, we must look at the second derivative, or in the general case where $D &gt; 1$, the Hessian. The Hessian is the matrix of second derivatives, defined as follows:</p>

\[\vec{H}_{ij} = \difftwo{\mathcal{L}}{w_i}{w_j}\]

<p>If the Hessian of the optimum is <a href="https://en.wikipedia.org/wiki/Positive-definite_matrix">positive semi-definite</a>, then it is a minimum (and not a maximum or a saddle point):</p>

\[\vec{H}(\vec{w}^*) := \difftwo{\cost{\vec{w}^*}}{\vec{w}}{\vec{w}^T} \text{ positive semidefinite}
\implies
\vec{w}^* \text{ is a minimum}\]

<p>The Hessian is also related to convexity; it is positive semi-definite on its entire domain (i.e. all its eigenvalues are non-negative) if and only if the function is convex.</p>

\[\vec{H} \text{ positive semidefinite}
\iff
\mathcal{L} \text{ convex}\]

<h4 id="step-size">Step size</h4>

<p>If $\gamma$ is too big, we might diverge (<a href="#gradient-descent">as seen previously</a>). But if it is too small, we might be very slow! Convergence is only guaranteed for $\gamma &lt; \gamma_{min}$, which is a value that depends on the problem.</p>

<h2 id="least-squares">Least squares</h2>

<h3 id="normal-equations">Normal equations</h3>

<p>In some rare cases, we can take an analytical approach to computing the optimum of the cost function, rather than a computational one; for instance, for linear regression with MSE, as weâve done previously. These types of equations are sometimes called <strong>normal equations</strong>. This is one of the most popular methods for data fitting, called <strong>least squares</strong>.</p>

<p>How do we get these normal equations?</p>

<p>First, we show that the problem is convex. If that is the case, then according to the <a href="#optimality">optimality conditions</a> for convex functions, the point at which the derivative is zero is the optimum:</p>

\[\nabla\cost{\vec{w}^*}=\vec{0}\]

<p>This gives us a system of $D$ equations known as the normal equations.</p>

<h3 id="single-parameter-linear-regression">Single parameter linear regression</h3>
<p>Letâs try this for a single parameter linear regression (where $D = 1$), with MSE as the cost function. We will start by accepting that the cost function is convex in the $w_0$ parameter<sup id="fnref:mse-is-convex" role="doc-noteref"><a href="#fn:mse-is-convex" class="footnote">3</a></sup>.</p>

<p>As <a href="#gradient-descent">proven previously</a>, we know that for the single parameter model, the derivative is:</p>

\[\begin{align}
\nabla\mathcal{L}\left(\vec{w}\right)
    &amp; = \frac{\partial}{\partial w_0}\mathcal{L} \\
    &amp; = \frac{1}{2N}\sum_{n=1}^N{-2(y_n - w_0)}  \\
    &amp; = w_0 - \bar{y}
\end{align}\]

<p>This means that the derivative is 0 for $w_0 = \bar{y}$. This allows us to define our optimum parameter $\vec{w}^*$ as $\vec{w}^* = \begin{bmatrix}\bar{y}\end{bmatrix}$.</p>

<h3 id="multiple-parameter-linear-regression">Multiple parameter linear regression</h3>

<p>Having done $D=1$, letâs look at the general case where $D \ge 1$. As we know by now, the cost function for linear regression with MSE is:</p>

\[\mathcal{L}\left(\vec{w}\right)
	:= \frac{1}{2N}\sum_{n=1}^N{\left( y_n - \vec{x}_n^T \vec{w}\right)^2}
	=  \frac{1}{2N}(\vec{y-Xw})^T(\vec{y-Xw})\]

<p>Where the matrices are defined as:</p>

\[\vec{y}=\begin{bmatrix}
	y_1 \\ y_2 \\ \vdots \\ y_N
\end{bmatrix}, 
\quad
\vec{X}=\begin{bmatrix}
x_{11} &amp; x_{12} &amp; \dots &amp; x_{1D} \\
x_{21} &amp; x_{22} &amp; \dots &amp; x_{2D} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{N1} &amp; x_{N2} &amp; \dots &amp; x_{ND} \\
\end{bmatrix}\]

<p>We denote the $i^\text{th}$ row of $X$ by $x_i^T$. Each $x_i^T$ represents a different data point.</p>

<p>We claim that this cost function is <em>convex</em> in $\vec{w}$. We can prove that in any of the following ways:</p>

<hr />

<h4 id="simplest-way">Simplest way</h4>
<p>The cost function is the sum of many convex functions, and is thus also convex.</p>

<h4 id="directly-verify-the-definition">Directly verify the definition</h4>

\[\forall \lambda\in [0,1], 
\quad \forall \vec{w}, \vec{w}',
\qquad
\mathcal{L}\left(\lambda\vec{w} + \left(1-\lambda\right)\vec{w}'\right) 
- \left(\lambda\mathcal{L}(\vec{w}) + \left( 1-\lambda \right) \mathcal{L}(\vec{w}')\right) \le 0\]

<p>The left-hand side of the inequality reduces to:</p>

\[-\frac{1}{2N}\lambda(1-\lambda)\norm{\vec{X}(\vec{w}-\vec{w}')}_2^2\]

<p>which indeed is $\le 0$.</p>

<h4 id="compute-the-hessian">Compute the Hessian</h4>

<p>As <a href="#optimality">weâve seen previously</a>, if the Hessian is positive semidefinite, then the function is convex. For our case, the Hessian is given by:</p>

\[\frac{1}{N}\vec{X}^T\vec{X}\]

<p>This is indeed positive semi-definite, as its eigenvalues are the squares of the eigenvalues of $\vec{X}$, and must therefore be positive.</p>

<hr />

<p>Knowing that the function is convex, we can find the minimum. If we take the gradient of this expression, we get:</p>

\[\nabla\mathcal{L}(\vec{w}) = -\frac{1}{N}\vec{X}^T(\vec{y-Xw})\]

<p>We can set this to 0 to get the normal equations for linear regression, which are:</p>

\[\vec{X}^T(\vec{y-Xw}) =: \vec{X}^T\vec{e} = \vec{0}\]

<p>This proves that the normal equations for linear regression are given by $\vec{X}^T\vec{e} = \vec{0}$.</p>

<h3 id="geometric-interpretation">Geometric interpretation</h3>

<p>The above definition of normal equations are given by $\vec{X}^T\vec{e} = \vec{0}$. How can visualize that?</p>

<p>The error is given by:</p>

\[\vec{e} := \vec{y} - \vec{Xw}\]

<p>By definition, this error vector is orthogonal to all columns of $\vec{X}$. Indeed, it tells us how far above or below the span our prediction $\vec{y}$ is.</p>

<p>The <strong>span</strong> of $\vec{X}$ is the space spanned by the columns of $\vec{X}$. Every element of the span can be written as $\vec{u} = \vec{Xw}$ for some choice of $\vec{w}$.</p>

<p>For the normal equations, we must pick an optimal $\vec{w}^*$ for which the gradient is 0. Picking an $\vec{w}^*$ is equivalent to picking an optimal $\vec{u}^* = \vec{Xw}^*$ from the span of $\vec{X}$.</p>

<p>But which element of $\text{span}(\vec{X})$ shall we take, which one is the optimal one? The normal equations tell us that the optimum choice for $\vec{u}$, called \(\vec{u}^*\) is the element such that \(\vec{y} - \vec{u}^*\) is orthogonal to $\text{span}(X)$.</p>

<p>In other words, we should pick $\vec{u}^*$ to be the projection of $\vec{y}$ onto $\text{span}(\vec{X})$.</p>

<p><img src="/images/ml/geometric-interpretation-normal-equations.png" alt="Geometric interpretation of the normal equations" /></p>

<h3 id="closed-form">Closed form</h3>
<p>All weâve done so far is to solve the same old problem of a matrix equation:</p>

\[Ax = b\]

<p>But weâve always done so with a bit of a twist; there may not be an exact value of $x$ satisfying exact equality, but we could find one that gets us as close as possible:</p>

\[Ax \approx b\]

<p>This is also what least squares does. It attempts to minimize the MSE to get as $Ax$ close as possible to $b$.</p>

<p>In this course, we often denote the data matrix $A$ as $\vec{X}$, the weights $x$ as $\vec{w}$, and $b$ as $y$; in other words, weâre trying to solve:</p>

\[\vec{X}\vec{w} \approx \vec{y}\]

<p>In least squares, we multiply this whole equation by $\vec{X}^T$ on the left. We attempt to find $\vec{w}^*$, the minimal weight that gets us as minimally wrong as possible. In other weâre trying to solve:</p>

\[\left( \vec{X}^T\vec{X} \right) \vec{w} \approx \vec{X}^T\vec{y}\]

<p>One way to solve this problem would simply be to invert the $A$ matrix, which in our case is $\vec{X}^T\vec{X}$:</p>

\[\vec{w}^* = (\vec{X}^T\vec{X})^{-1} \vec{X}^T y\]

<p>As such, we can use this model to predict values for unseen data points:</p>

\[\hat{y}_m := \vec{x}_m^T \vec{w}^* = \vec{x}_m^T (\vec{X}^T\vec{X})^{-1} \vec{X}^T y\]

<h3 id="invertibility-and-uniqueness">Invertibility and uniqueness</h3>
<p>Note that the Gram matrix, defined as $\vec{X}^T\vec{X} \in \mathbb{R}^{D\times D}$, is invertible <strong>if and only if</strong> $\vec{X}$ has <strong>full column rank</strong>, or in other words, $\text{rank}(\vec{X}) = D$.</p>

\[\vec{X}^T\vec{X} \in \mathbb{R}^{D\times D} \text{ invertible}
\iff
\text{rank}(\vec{X}) = D\]

<p>Unfortunately, in practice, our data matrix $\vec{X}\in\mathbb{R}^{N\times D}$ is often <strong>rank-deficient</strong>.</p>

<ul>
  <li>If $D&gt;N$, we always have $\text{rank}(\vec{X}) &lt; D$ (since column and row rank are the same, which implies that $\text{rank}(\vec{X}) \le N &lt; D$).</li>
  <li>
    <p>If $D \le N$, but some of the columns $\vec{X}_{:d}$ are collinear (or in practice, nearly collinear), then the matrix is <strong>ill-conditioned</strong>. This leads to numerical issues when solving the linear system.</p>

    <p>To know how bad things are, we can compute the condition number, which is the maximum eigenvalue of the Gram matrix, divided by the minimum See course contents of Numerical Methods.</p>
  </li>
</ul>

<p>If our data matrix is rank-deficient or ill-conditioned (which is practically always the case), we certainly shouldnât be inverting it directly! Weâll introduce high numerical errors that falsify our output.</p>

<p>That doesnât mean we canât do least squares in practice. We can still use a linear solver. In Python, that means you should use <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html"><code class="highlighter-rouge">np.linalg.solve</code></a>, which uses a LU decomposition internally and thus avoids the worst numerical errors. In any case, do not directly invert the matrix as we have done above!</p>

<h2 id="maximum-likelihood">Maximum likelihood</h2>
<p>Maximum likelihood offers a second interpretation of least squares, but starting with a probabilistic approach.</p>

<h3 id="gaussian-distribution">Gaussian distribution</h3>
<p>A Gaussian random variable in $\mathbb{R}$ has mean $\mu$ and variance $\sigma^2$. Its distribution is given by:</p>

\[\normal{y \mid \mu, \sigma^2} = 
    \frac{1}{\sqrt{2\pi\sigma^2}} 
    \exp{\left[ -\frac{(y-\mu)^2}{2\sigma^2} \right]}\]

<p>For a Gaussian random <em>vector</em>, we have $\vec{y} \in \mathbb{R}^N$ (instead of a single random variable in $\mathbb{R}$). The vector has mean $\pmb{\mu}$ and covariance $\pmb{\Sigma}$ (which is positive semi-definite), and its distribution is given by:</p>

\[\pmb{\mathcal{N}}(\vec{y} \mid \pmb{\mu}, \pmb{\Sigma}) = 
    \frac{1}
         {\sqrt{(2\pi)^D \text{ det}(\pmb{\Sigma})}} 

    \exp{\left[ -\frac{1}{2} (\vec{y} - \pmb{\mu})^T \pmb{\Sigma}^{-1} (\vec{y} - \pmb{\mu}) \right]}\]

<p>As another reminder, two variables $x$ and $y$ are said to be <strong>independent</strong> when $p(x, y) = p(x)p(y)$.</p>

<h3 id="a-probabilistic-model-for-least-squares">A probabilistic model for least squares</h3>
<p>We assume that our data is generated by a linear model $\vec{x}_n^T\vec{w}$, with added Gaussian noise $\epsilon_n$:</p>

\[y_n = \vec{x}_n^T\vec{w} + \epsilon_n\]

<p>This is often a realistic assumption in practice.</p>

<p><img src="/images/ml/gaussian-noise.png" alt="Noise generated by a Gaussian source" /></p>

<p>The noise is $\epsilon_n \overset{\text{i.i.d.}}{\sim}\normal{y_n \mid \mu = 0, \sigma^2}$ for each dimension $n$. In other words, it is centered at 0, has a certain variance, and the error in each dimension is independent of that in other dimensions.</p>

<p>The model $\vec{w}$ is, as always, unknown. But we can try to do a thought experiment: if we did know the model $\vec{w}$ the data $\vec{X}$, in a system without the noise $\epsilon_n$, we would know the labels $\vec{y}$ with 100% certainty. The only thing that prevents that is the noise $\epsilon_n$; therefore, given the model and data, the probability distribution of seeing a certain $\vec{y}$ is only given by all the noise sources $\epsilon_n$. Since they are generated independently in each dimension, we can take the product of these noise sources.</p>

<p>Therefore, given $N$ samples, the <strong>likelihood</strong> of the data vector $\vec{y} = (y_1, \dots, y_n)$ given the model $\vec{w}$ and the input $\vec{X}$ is:</p>

\[p(\vec{y} \mid \vec{X}, \vec{w}) 
    = \prod_{n=1}^N {p(y_n \mid \vec{x}_n, \vec{w})}
    = \prod_{n=1}^N {\normal{y_n \mid \vec{x}_n^T\vec{w}, \sigma^2}}\]

<p>Intuitively, weâd like to maximize this likelihood over the choice of the best model $\vec{w}$. The best model is the one that maximizes this likelihood.</p>

<h3 id="defining-cost-with-log-likelihood">Defining cost with log-likelihood</h3>
<p>The log-likelihood (LL) is given by:</p>

\[\mathcal{L}_{LL}(\vec{w}) := \log{p(\vec{y} \mid \vec{X}, \vec{w})}
    = - \frac{1}{2\sigma^2} \sum_{n=1}^N{\left(y_n - \vec{x}_n^T\vec{w}\right)^2} + \text{ cnst}\]

<p>Taking the log allows us to get away from the nasty product, and get a nice sum instead. Notice that this definition looks pretty similar to MSE:</p>

\[\mathcal{L}_{\text{MSE}}(\vec{w}) := \frac{1}{N} \sum_{n=1}^N \left(y_n - \vec{x}_n^T\vec{w}\right)^2\]

<p>Note that we would like to minimize MSE, but we want the log-likelihood to be as high as possible (intuitively, we can look at the sign to understand that).</p>

<h3 id="maximum-likelihood-estimator-mle">Maximum likelihood estimator (MLE)</h3>
<p>Maximizing the log-likelihood (and thus the likelihood) will be equivalent to minimizing the MSE; this gives us another way to design cost functions. We can describe the whole process as:</p>

\[\argmin_{\vec{w}}{\mathcal{L}_\text{MSE}(\vec{w})} =
\argmax_{\vec{w}}{\mathcal{L}_\text{LL}(\vec{w})}\]

<p>The maximum likelihood estimator (MLE) can be understood as finding the model under which the observed data is most likely to have been generated from (probabilistically). This interpretation has some advantages that we discuss below.</p>

<h4 id="properties-of-mle">Properties of MLE</h4>
<p>MLE is a <em>sample</em> approximation to the <em>expected log-likelihood</em>. In other words, if we had an infinite amount of data, MLE would perfectly be equal to the true expected value of the log-likelihood.</p>

\[\mathcal{L}_{LL}(\vec{w}) 
    \approx \expectsub{p(y, \vec{x})}{\log{p(y \mid \vec{x}, \vec{w})}}\]

<p>This means that MLE is <strong>consistent</strong>, i.e. it gives us the correct model assuming we have enough data. This means it converges in probability<sup id="fnref:convergence-prob-distrib" role="doc-noteref"><a href="#fn:convergence-prob-distrib" class="footnote">4</a></sup> to the true value:</p>

\[\vec{w}_\text{MLE} \overset{p}{\longrightarrow} \vec{w}_\text{true}\]

<p>MLE is asymptotically normal, meaning that the difference between the approximation and the true value of the weights converges in distribution<sup id="fnref:convergence-prob-distrib:1" role="doc-noteref"><a href="#fn:convergence-prob-distrib" class="footnote">4</a></sup> to a normal distribution centered at 0, and with variance $\frac{1}{N}$ times the Fisher information of the true value:</p>

\[(\vec{w}_{\text{MLE}} - \vec{w}_{\text{true}}) 
\overset{d}{\longrightarrow}
\frac{1}{\sqrt{N}} \normal{\vec{w}_{\text{MLE}} \mid \vec{0}, \vec{F}^{-1}(\vec{w}_{\text{true}})}\]

<p>Where the Fisher information<sup id="fnref:fisher-information" role="doc-noteref"><a href="#fn:fisher-information" class="footnote">5</a></sup> is:</p>

\[\vec{F}(\vec{w}) 
= -\expectsub{p(\vec{y})}{
    \frac{\partial^2\mathcal{L}}{\partial\vec{w}\partial\vec{w}^T}
}\]

<p>This sounds amazing, but the catch is that this all is under the assumption that the noise $\epsilon$ indeed was generated under a Gaussian model, which may not always be true. Weâll relax this assumption later when we talk about <a href="#exponential-family">exponential families</a>.</p>

<h2 id="overfitting-and-underfitting">Overfitting and underfitting</h2>
<p>Models can be too limited; when we canât find a function that fits the data well, we say that we are <em>underfitting</em>. But on the other hand, models can also be too rich: in this case, we donât just model the data, but also the underlying noise. This is called <em>overfitting</em>. Knowing exactly where we are on this spectrum is difficult, since all we have is data, and we donât know a priori what is signal and what is noise.</p>

<p>Sections 3 and 5 of Pedro Domingosâ paper <a href="https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf"><em>A Few Useful Things to Know about Machine Learning</em></a> are a good read on this topic.</p>

<h3 id="underfitting-with-linear-models">Underfitting with linear models</h3>
<p>Linear models can very easily underfit; as soon as the data itself is given by anything more complex than a line, fitting a linear model will underfit: the model is too simple for the data, and weâll have huge errors.</p>

<p>But we can also easily overfit, where our model learns the specificities of the data too intimately. And this happens quite easily with linear combination of high-degree polynomials.</p>

<h3 id="extended-feature-vectors">Extended feature vectors</h3>
<p>We can actually get high-degree linear combinations of polynomials, but still keep our linear model. Instead of making the model more complex, we simply âaugmentâ the input to become degree $M$. If the input is one-dimensional, we can add a polynomial basis to the input:</p>

\[\pmb{\phi}(x_n) =
\begin{bmatrix}
1 &amp; x_n &amp; x_n^2 &amp; x_n^3 &amp; \dots &amp; x_n^M
\end{bmatrix}\]

<p>Note that this is basically a <a href="https://en.wikipedia.org/wiki/Vandermonde_matrix">Vandermonde matrix</a>.</p>

<p>We then fit a linear model to this extended feature vector $\pmb{\phi}(x_n)$:</p>

\[y_n \approx w_0 + w_1 x_n + w_2 x_n^2 + \dots + w_m x_n^M =: \pmb{\phi}(x_n)^T\vec{w}\]

<p>Here, $\vec{w}\in\mathbb{R}^{M+1}$. In other words, there are $M+1$ parameters in a degree $M$ extended feature vector. One should be careful with this degree; too high may overfit, too low may underfit.</p>

<p>If it is important to distinguish the original input $\vec{x}$ from the augmented input $\pmb{\phi}(\vec{x})$ then we will use the $\pmb{\phi}(\vec{x})$ notation. But often, we can just consider this as a part of the pre-processing, and simply write $\vec{x}$ as the input, which will save us a lot of notation.</p>

<h3 id="reducing-overfitting">Reducing overfitting</h3>
<p>To reduce overfitting, we can chose a less complex model (in the above, we can pick a lower degree $M$), but we could also just add more data:</p>

<p><img src="/images/ml/reduce-overfit-add-data.png" alt="An overfitted model acts more reasonably when we add a bunch of data" /></p>

<h2 id="regularization">Regularization</h2>
<p>To prevent overfitting, we can introduce <strong>regularization</strong> to penalize complex models. This can be applied to any model.</p>

<p>The idea is to not only minimize cost, but also minimize a regularizer:</p>

\[\min_{\vec{w}} {\mathcal{L}(\vec{w}) + \Omega(\vec{w})}\]

<p>The $\Omega$ function is the regularizer, measuring the complexity of the model. Weâll see some good candidates for the regularizer below.</p>

<h3 id="l_2-regularization-ridge-regression">$L_2$-Regularization: Ridge Regression</h3>
<p>The most frequently used regularizer is the standard Euclidean norm ($L_2$-norm):</p>

\[\Omega(\vec{w}) = \lambda \norm{\vec{w}}^2_2\]

<p>Where $\lambda \in \mathbb{R}$. The value of $\lambda$ will affect the fit; $\lambda \rightarrow 0$ can have overfitting, while $\lambda \rightarrow \infty$ can have underfitting.</p>

<p>The norm is given by:</p>

\[\norm{\vec{w}}_2^2 = \sum_i{w_i^2}\]

<p>The main effect of this is that large model weights $w_i$ will be penalized, while small ones wonât affect our minimization too much.</p>

<h4 id="ridge-regression">Ridge regression</h4>
<p>Depending on the values we choose for $\mathcal{L}$ and $\Omega$, we get into some special cases. For instance, choosing MSE for $\mathcal{L}$ is called <strong>ridge regression</strong>, in which we optimize the following:</p>

\[\min_{\vec{w}} {\left(\frac{1}{N} \sum_{n=1}^N \left[y_n - f(\vec{x}_n)\right]^2 \quad + \quad \Omega(\vec{w})\right)}\]

<p>Least squares is also a special case of ridge regression, where $\lambda = 0$</p>

<p>We can find an explicit solution for $\vec{w}$ in ridge regression by differentiating the cost and regularizer, and setting them to zero:</p>

\[\begin{align}
\nabla \mathcal{L}(\vec{w}) &amp; = -\frac{1}{N} \vec{X}^T (\vec{y} - \vec{Xw}) \\ \\
\nabla \Omega(\vec{w}) &amp; = 2\lambda \vec{w} \\
\end{align}\]

<p>We can now set the full cost to zero, which gives us the result:</p>

\[\vec{w}^*_\text{ridge} = (\vec{X}^T\vec{X} + \lambda' \vec{I})^{-1}\vec{X}^T\vec{y}\]

<p>Where $\frac{\lambdaâ}{2N} = \lambda$. Note that for $\lambda = 0$, we have the least squares solution.</p>

<h4 id="ridge-regression-to-fight-ill-conditioning">Ridge regression to fight ill-conditioning</h4>
<p>This formulation of $\vec{w}^*$ is quite nice, because adding the identity matrix helps us get something that always is invertible; in cases where we have ill-conditioned matrices, it also means that we can invert with more stability.</p>

<p>Weâll prove that the matrix indeed is invertible. The gist is that the eigenvalues of $(\vec{X}^T\vec{X} + \lambdaâ \vec{I})$ are all at least $\lambdaâ$.</p>

<p>To prove it, weâll write the singular value decomposition (SVD) of $\vec{X}^T\vec{X}$ as $\vec{USU}^T$. We then have:</p>

\[\vec{X}^T\vec{X} + \lambda'\vec{I} = \vec{USU}^T + \lambda'\vec{UIU}^T = \vec{U}(\vec{S} + \lambda'\vec{I})\vec{U}^T\]

<p>The singular value is âliftedâ by an amount $\lambdaâ$. Thereâs an alternative proof in the class notes, but we wonât go into that.</p>

<h3 id="l_1-regularization-the-lasso">$L_1$-Regularization: The Lasso</h3>
<p>We can use a different norm as an alternative measure of complexity. The combination of $L_1$-norm and MSE is known as <strong>The Lasso</strong>:</p>

\[\min_{\vec{w}} {\frac{1}{2N} \sum_{n=1}^N \left[y_n - f(\vec{x}_n)\right]^2 + \lambda \norm{\vec{w}}_1}\]

<p>Where the $L_1$-norm is defined as</p>

\[\norm{\vec{w}}_1 := \sum_i{\abs{w_i}}\]

<p>If we draw out a constant value of the $L_1$ norm, we get a sort of âballâ. Below, weâve graphed $\set{\vec{w} : \norm{\vec{w}}_1 \le 5}$.</p>

<p><img src="/images/ml/lasso.png" alt="Graph of the lasso" /></p>

<p>To keep things simple in the following, weâll just claim that $\vec{X}^T\vec{X}$ is invertible. Weâll also claim that the following set is an ellipsoid which scales around the origin as we change $\alpha$:</p>

\[\set{\vec{w} : \norm{\vec{y} - \vec{Xw}}^2 = \alpha}\]

<p>The slides have a formal proof for this, but we wonât get into it.</p>

<p>Note that the above definition of the set corresponds to the set of points with equal loss (which we can assume is MSE, for instance):</p>

\[\set{\vec{w} : \cost{\vec{w}} = \alpha}\]

<p>Under these assumptions, we claim that for $L_1$ regularization, the optimum solution will likely be sparse (many zero components) compared to $L_2$ regularization.</p>

<p>To prove this, suppose we know the $L_1$ norm of the optimum solution. Visualizing that ball, we know that our optimum solution $\vec{w}^*$ will be somewhere on the surface of that ball. We also know that there are ellipsoids, all with the same mean and rotation, describing the equal error surfaces. The optimum solution is where the âsmallestâ of these ellipsoids just touches the
$L_1$ ball.</p>

<p><img src="/images/ml/ball-ellipse.png" alt="Intersection of the L1 ball and the cost ellipses" /></p>

<p>Due to the geometry of this ball this point is more likely to be on one of the âcornerâ points. In turn, sparsity is desirable, since it leads to a âsimpleâ model.</p>

<h2 id="model-selection">Model selection</h2>
<p>As weâve seen in ridge regression, we have a <em>regularization parameter</em> $\lambda &gt; 0$ that can be tuned to reduce overfitting by reducing model complexity. We say that the parameter $\lambda$  is a <strong>hyperparameter</strong>.</p>

<p>Weâve also seen ways to enrich model complexity, like <a href="#extended-feature-vectors">polynomial feature expansion</a>, in which the degree $M$ is also a hyperparameter.</p>

<p>Weâll now see how best to choose these hyperparameters; this is called the <strong>model selection</strong> problem.</p>

<h3 id="probabilistic-setup">Probabilistic setup</h3>
<p>We assume that there is an (unknown) underlying distribution $\mathcal{D}$ producing the dataset, with range $\mathcal{X}\times\mathcal{Y}$. The dataset $S$ we see is produced from samples from $\mathcal{D}$:</p>

\[S = \set{
    (\vec{x}_n, y_n) \overset{\text{i.i.d}}{\sim} \mathcal{D}
}_{n=1}^N\]

<p>Based on this, the <em>learning algorithm</em> $\mathcal{A}$ choses the âbestâ model using the dataset $S$, under the parameters of the algorithm. The resulting prediction function is $f_s = \mathcal{A}(S)$. To indicate that $f_s$ sometimes depend on hyperparameters, we can write the prediction function as $f_{s, \lambda}$.</p>

<h3 id="training-error-vs-generalization-error">Training Error vs. Generalization Error</h3>
<p>Given a model $f$, how can we assess if $f$ is any good? We already have the loss function, but its result is highly dependent on the error in the data, not to how good the model is. Instead, we can compute the <em>expected error</em> over all samples chosen according to $\mathcal{D}$.</p>

\[L_\mathcal{D}(f) = \expectsub{\mathcal{D}}{\mathcal{l}(y, f(\vec{x}))}\]

<p>Where $\mathcal{l}(\cdot, \cdot)$ is our loss function; e.g. for ridge regression, $\mathcal{l}(y, f(\vec{x})) = \frac{1}{2}(y-f(\vec{x}))^2$.</p>

<p>The quantity $L_\mathcal{D}(f)$ has many names, including <strong>generalization error</strong> (or true/expected error/risk/loss). This is the quantity that we are fundamentally interested in, but we cannot compute it since $\mathcal{D}$ is unknown.</p>

<p>What we do know is the data subset<sup id="fnref:data-subset-training-data" role="doc-noteref"><a href="#fn:data-subset-training-data" class="footnote">6</a></sup> $S$. Itâs therefore natural to compute the equivalent <em>empirical</em> quantity, which is the average loss:</p>

\[L_S(f) = \frac{1}{\abs{S}} \sum_{(\vec{x}_n, y_n)\in S} {\mathcal{l}(y_n, f(\vec{x}_n))}\]

<p>But again, we run into trouble. The function $f$ is itself a function of the data $S$, so what we really do is to compute the quantity:</p>

\[L_S(f_S) = \frac{1}{\abs{S}} \sum_{(\vec{x}_n, y_n)\in S} {\mathcal{l}(y_n, f_S(\vec{x}_n))}\]

<p>$f_S$ is the trained model. This is called the <strong>training error</strong>. Usually, the training error is smaller than the generalization error, because overfitting can happen (even with regularization, because the hyperparameter may still be too low).</p>

<h3 id="splitting-the-data">Splitting the data</h3>
<p>To avoid validating the model on the same data subset we trained it on (which is conducive to overfitting), we can split the data into a <strong>training set</strong> and a <strong>test set</strong> (aka <em>validation set</em>), which we call $\Strain$ and $\Stest$, so that $S = \Strain \oplus \Stest$. A typical split could be 80% for training and 20% for testing.</p>

<p>We apply the learning algorithm $\mathcal{A}$ on the training set $\Strain$, and compute the function $f_{\Strain}$. We then compute the error on the test set, which is the <strong>test error</strong>:</p>

\[L_{\Stest}(f_{\Strain}) = \frac{1}{\abs{\Stest}} \sum_{(\vec{x}_n, y_n)\in \Stest} {\mathcal{l}(y_n, f_{\Strain}(\vec{x}_n))}\]

<p>If we have duplicates in our data, then this could be a bit dangerous. Still, in general, this really helps us with the problem of overfitting since $\Stest$ is a âfreshâ sample, which means that we can hope that $L_{\Stest}(f_{\Strain})$ defined above is close to the quantity $L_\mathcal{D}(f_{\Strain})$. Indeed, <em>in expectation</em> both are the same:</p>

\[L_\mathcal{D}(f_{\Strain}) 
= \expectsub{\Stest\sim\mathcal{D}}{
    L_{\Stest}(f_{\Strain})
}\]

<p>The subscript on the expectation means that the expectation is over samples of the test set, and not for a particular test set (which could give a different result due to the randomness of the selection of $\Stest$).</p>

<p>This is a quite nice property, but we paid a price for this. We had to split the data and thus reduce the size of our training data. But we will see that this can be mediated using cross-validation.</p>

<h3 id="generalization-error-vs-test-error">Generalization error vs test error</h3>
<p>Assume that we have a model $f$ and that our loss function $\mathcal{l}(\cdot, \cdot)$ is bounded in $[a, b]$. We are given a test set $\Stest$ chosen i.i.d. from the underlying distribution $\mathcal{D}$.</p>

<p>How far apart is the empirical test error from the true generalization error? As weâve seen above, they are the same in expectation. But we need to worry about the variation, about how far off from the true error we typically are:</p>

<p>We claim that:</p>

\[\mathbb{P}\left[
    \abs{L_\mathcal{D}(f) - L_{\Stest}(f)}
    \ge
    \sqrt{\frac{(b-a)^2 \ln{(2/\delta)}}{2\abs{\Stest}}}
\right]
\le \delta
\label{eq:loss-bound}
\tag{loss-bound}\]

<p>Where $\delta &gt; 0$ is a quality parameter. This gives us an upper bound on how far away our empirical loss is from the true loss.</p>

<p>This bound gives us some nice insights. Error decreases in the size of the test set as $\mathcal{O}(1/\sqrt{\abs{\Stest}})$, so the more data points we have, the more confident we can be in the empirical loss being close to the true loss.</p>

<p>Weâll prove $\ref{eq:loss-bound}$. We assumed that each sample in the test set is chosen independently. Therefore, given a model $f$, the associated losses $\mathcal{l}(y_n, f(\vec{x}_n))$ are also i.i.d. random variables, taking values in $[a, b]$ by assumption. We can call each such loss $\Theta_n$:</p>

\[\Theta_n = \mathcal{l}(y_n, f(\vec{x}_n))\]

<p>This is just a naming alias; since the underlying value is that of the loss function, the expected value of $\Theta_n$ is simply that of the loss function, which is the true loss:</p>

\[\expect{\Theta_n} = \expect{\mathcal{l}(y_n, f(\vec{x}_n))} = L_\mathcal{D}(f)\]

<p>The empirical loss on the other hand is equal to the average of $\abs{\Stest}$ such i.i.d. values.</p>

<p>The formula of $\ref{eq:loss-bound}$ gives us the probability that empirical loss $L_{\Stest}(f)$ diverges from the true loss by more than a given constant, which is a classical problem addressed in the following lemma (which weâll just assert, not prove).</p>

<p><strong>Chernoff Bound</strong>: Let $\Theta_1, \dots, \Theta_N$ be a sequence of i.i.d random variables with mean $\expect{\Theta}$ and range $[a, b]$. Then, for any $\epsilon &gt; 0$:</p>

\[\mathbb{P}\left[
    \abs{\frac{1}{N}\sum_{n=1}^N {\Theta_n - \expect{\Theta}}}
    \ge
    \epsilon
\right]
\le
2\exp{\left(\frac{-2N\epsilon^2}{(b-a)^2}\right)}
\label{eq:Chernoff}
\tag{Chernoff}\]

<p>Using $\ref{eq:Chernoff}$ we can show $\ref{eq:loss-bound}$. By setting $\delta = 2\exp{\left(\frac{-2N\epsilon^2}{(b-a)^2}\right)}$, we find that $\epsilon = \sqrt{\frac{(b-a)^2 \ln{(2/\delta)}}{2\abs{\Stest}}}$ as claimed.</p>

<h3 id="method-and-criteria-for-model-selection">Method and criteria for model selection</h3>

<h4 id="grid-search-on-hyperparameters">Grid search on hyperparameters</h4>
<p>Our main goal was to look for a way to select the hyperparameters of our model. Given a finite set of values $\lambda_k$ for $k=1, \dots, K$ of a hyperparameter $\lambda$, we can run the learning algorithm $K$ times on the same training set $\Strain$, and compute the $K$ prediction functions $f_{\Strain, \lambda_k}$. For each such prediction function we compute the test error, and choose the $\lambda_k$ which minimizes the test error.</p>

<p><img src="/images/ml/cross-validation.png" alt="Grid search on lambda" /></p>

<p>This is essentially a grid search on $\lambda$ using the test error function.</p>

<h4 id="model-selection-based-on-test-error">Model selection based on test error</h4>
<p>How do we know that, for a fixed function $f$, $L_{\Stest}(f)$ is a good approximation to $L_\mathcal{D}(f)$? If weâre doing a grid search on hyperparameters to minimize the test error $L_{\Stest}(f)$, we may pick a model that obtains a lower test error, but that may increase $\abs{L_\mathcal{D}(f) - L_{\Stest}(f)}$.</p>

<p>Weâll therefore try to see how much the bound increases if we pick a false positive, a model that has lower test error but that actually strays further away from the generalization error.</p>

<p>The answer to this follows the same idea as when we talked about <a href="#generalization-error-vs-test-error">generalization vs test error</a>, but we now assume that we have $K$ models $f_k$ for $k=1, \dots, K$. We assume again that the loss function is bounded in $[a, b]$, and that weâre given a test set whose samples are chosen i.i.d. in $\mathcal{D}$.</p>

<p>How far is each of the $K$ (empirical) test errors $L_{\Stest}(f_k)$ from the true $L_\mathcal{D}(f_k)$? As before, we can bound the deviation for all $k$ candidates, by:</p>

\[\mathbb{P}\left[
    \max_k {\abs{L_\mathcal{D}(f_k) - L_{\Stest}(f_k)}}
    \ge
    \sqrt{\frac{(b-a)^2 \ln{(2K/\delta)}}{2\abs{\Stest}}}
\right]
\le \delta\]

<p>A bit of intuition of where this comes from: for a general $K$, we check the deviations for $K$ independent samples and ask for the probability that for at least one such sample we get a deviation of at least $\epsilon$ (this is what the $\ref{eq:Chernoff}$ bound answers). Then by the <a href="https://en.wikipedia.org/wiki/Boole%27s_inequality">union bound</a> this probability is at most $K$ times as large as in the case where we are only concerned with a single instance. Thus the upper bound in Chernoff becomes $2K\exp{\left(\frac{-2N\epsilon^2}{(b-a)^2}\right)}$, which gives us $\epsilon = \sqrt{\frac{(b-a)^2 \ln{(2K/\delta)}}{2\abs{\Stest}}}$ as above.</p>

<p>As before, this tells us that error decreases in $\mathcal{O}(1/\sqrt{\abs{\Stest}})$.</p>

<p>However, now that we test $K$ hyperparameters, our error only goes up by a tiny amount of $\sqrt{\ln{(K)}}$. This follows from $\ref{eq:loss-bound}$, which we proved for the special case of $K = 1$. So we can reasonably do grid search, knowing that in the worst case, the error will only increase by a tiny amount.</p>

<h3 id="cross-validation">Cross-validation</h3>
<p>Splitting the data once into two parts (one for training and one for testing) is not the most efficient way to use the data. Cross-validation is a better way.</p>

<p>K-fold cross-validation is a popular variant. We randomly partition the data into $K$ groups, and train $K$ times. Each time, we use one of the $K$ groups as our test set, and the remaining $Kâ1$ groups for training.</p>

<p>To get a common result, we average out the $K$ results. This means weâll use  the average weights to get the average test error over the $K$ folds.</p>

<p>Cross-validation returns an unbiased estimate of the generalization error and its variance.</p>

<h3 id="bias-variance-decomposition">Bias-Variance decomposition</h3>
<p>When we perform model selection, there is an inherent <a href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff">biasâvariance</a> trade-off.</p>

<figure>
    <img src="/images/ml/bias-variance.png" alt="Bullseye representation of bias vs variance" />
    <figcaption>Graphical illustration of bias and variance. Taken from <a href="http://scott.fortmann-roe.com/docs/BiasVariance.html">Scott Fortmann-Roe's website</a></figcaption>
</figure>

<p>If we were to build the same model over and over again with re-sampled datasets, our predictions would change because of the randomness in the used datasets. Bias tells us how far off from the correct value our predictions are in general, while variance tells us about the variability in predictions for a given point in-between realizations of the models.</p>

<p>For now, weâll just look at âhigh-bias &amp; low-varianceâ models, and âhigh-variance &amp; low-biasâ models.</p>

<ul>
  <li><strong>High-bias &amp; low-variance</strong>: the model is too simple. Itâs underfit, has a large bias, and and the variance of $L_\mathcal{D}(f_S)$ is small (the variations due to the random sample $S$).</li>
  <li><strong>High-variance &amp; low-bias</strong>: the model is too complex. Itâs overfit, has a small bias and large variance of $L_\mathcal{D}(f_S)$ (the error depends largely on the exact choice of $S$; a single addition of a data point is likely to change the prediction function $f_S$ considerably)</li>
</ul>

<p>Consider a linear regression with one-dimensional input and <a href="#extended-feature-vectors">polynomial feature expansion</a> of degree $d$. The former can be achieved by picking a too low value for $d$, while the latter by picking $d$ too high. The same principle applies for other parameters, such as ridge regression with hyperparameter $\lambda$.</p>

<h4 id="data-generation-model">Data generation model</h4>
<p>Letâs assume that our data is generated by some arbitrary, unknown function $f$, and a noise source $\epsilon$ with distribution $\mathcal{D}_\epsilon$ (i.i.d. from sample to sample, and independent from the data). We can think of $f$ representing the precise, hypothetical function that perfectly produced the data. We assume that the noise has mean zero (without loss of generality, as a non-zero mean could be encoded into $f$).</p>

\[y = f(\vec{x}) + \epsilon\]

<p>We assume that $\vec{x}$ is generated according to some fixed but unknown distribution $\mathcal{D}_{\vec{x}}$. Weâll be working with square loss $\mathcal{l}(y, f(\vec{x})) = \frac{1}{2}(y-f(\vec{x}))^2$. We will denote the joint distribution on pairs $(\vec{x}, y)$ as $\mathcal{D}$.</p>

\[\begin{align}
\epsilon     &amp; \sim \mathcal{D}_\epsilon \\
\vec{x}      &amp; \sim \mathcal{D}_x \\
(\vec{x}, y) &amp; \sim \mathcal{D} \\
\end{align}\]

<h4 id="error-decomposition">Error Decomposition</h4>
<p>As always, we have a training set $\Strain$, which consists of $N$ i.i.d. samples from $\mathcal{D}$. Given our learning algorithm $\mathcal{A}$, we compute the prediction function $f_{\Strain} = \mathcal{A}(\Strain)$. The square loss of a single prediction for a fixed element $\vec{x}_0$ is given by the computation of:</p>

\[\mathcal{l}(y_0, f_{\Strain}(\vec{x}_0))
=
\bigl( y_0 - f_{\Strain}(\vec{x}_0) \bigr)^2
= 
\bigl( f(\vec{x}_0) + \epsilon - f_{\Strain}(\vec{x}_0) \bigr)^2\]

<p>Our experiment was to create $\Strain$, learn $f_{\Strain}$, and then evaluate the performance by computing the square loss for a fixed element $\vec{x}_0$. If we run this experiment many times, the expected value is written as:</p>

\[\expectsub{\Strain \sim \mathcal{D},\ \epsilon\sim\mathcal{D}_\epsilon}{
    \left( f(\vec{x}_0) + \epsilon - f_{\Strain}(\vec{x}_0) \right)^2
}\]

<p>This expectation is over randomly selected training sets of size $N$, and over noise sources. We will now show that this expression can be rewritten as a sum of three non-negative terms:</p>

\[\newcommand{\otherconstantterm}{\expectsub{\Strain'\sim\mathcal{D}}{f_{\Strain'}(\vec{x}_0)}}

\begin{align}
&amp; \expectsub{\Strain \sim \mathcal{D},\ \epsilon\sim\mathcal{D}_\epsilon} {
    \left( f(\vec{x}_0) + \epsilon - f_{\Strain}(\vec{x}_0) \right)^2
} \\

\overset{(a)}{=}\  &amp; 
    \expectsub{\epsilon\sim\mathcal{D}_\epsilon} {
        \epsilon^2
    }
    + \expectsub{\Strain \sim \mathcal{D}} {
        \bigl(f(\vec{x}_0) - f_{\Strain}(\vec{x}_0)\bigl)^2
    } \\

\overset{(b)}{=}\ &amp; 
    \text{Var}_{\epsilon\sim\mathcal{D}_\epsilon}\left[\epsilon\right]
    + \expectsub{\Strain \sim \mathcal{D}}{
        \bigl(f(\vec{x}_0) - f_{\Strain}(\vec{x}_0)\bigl)^2
    } \\

\overset{(c)}{=}\ &amp;
    \underbrace{
        \text{Var}_{\epsilon\sim\mathcal{D}_\epsilon}\left[\epsilon\right]
    }_\text{noise variance} \\
&amp; + \underbrace{
    \left( f(\vec{x}_0) - \otherconstantterm \right)^2
}_\text{bias} \\
&amp; + \expectsub{\Strain\sim\mathcal{D}} {
        \underbrace{
            \left( \otherconstantterm - f_{\Strain(\vec{x}_0)} \right)^2
        }_\text{variance}
    } \\
\end{align}\]

<p>Note that here, $S'_\text{train}$ is a second training set, also sampled from $\mathcal{D}$, that is independent of the training set $\Strain$. It has the same expectation, but it is different and thus produces a different trained model $f_{Sâ}$.</p>

<p>Step $(a)$ uses $(u+v)^2 = u^2 + 2uv + v^2$ as well as linearity of expectation to produce $\expect{(u+v)^2} = \expect{u^2} + 2\expect{uv} + \expect{v^2}$. Note that the $2uv$ part is zero as the noise $\epsilon$ is independent from $\Strain$.</p>

<p>Step $(b)$ uses the definition of variance as:</p>

\[\text{Var}(X) = \expect{(X - \expect{X})^2} = \expect{X^2} - \expect{X}^2\]

<p>Seeing that our noise $\epsilon$ has mean zero, we have $\expect{\epsilon}^2 = 0$ and therefore $\text{Var}(\epsilon) = \expect{\epsilon^2}$.</p>

<p>In step $(c)$, we add and subtract the constant term $\otherconstantterm$ to the expression like so:</p>

\[\expectsub{\Strain \sim \mathcal{D}}{\left(
    \underbrace{f(\vec{x}_0) - \otherconstantterm}_u 
+   \underbrace{\otherconstantterm - f_{\Strain}(\vec{x}_0)}_v
\right)^2}\]

<p>We can then expand the square $(u+v)^2 = u^2 + 2uv + v^2$, where $u^2$ becomes the bias, and $v^2$ the variance. We can drop the expectation around $u^2$ as it is over $\Strain$, while $u^2$ is only defined in terms of $\Strainâ$, which is independent from $\Strain$. The $2uv$ part of the expansion is zero, as we show below:</p>

\[\begin{align}
&amp; 2 \cdot \expectsub{\Strain\sim\mathcal{D}} {
    \left( 
        f(\vec{x}_0) - \otherconstantterm 
    \right) \cdot \left(
        \otherconstantterm - f_{\Strain}(\vec{x}_0)
    \right)
} \\
&amp; = 2 \cdot \left(
    f(\vec{x}_0) - \otherconstantterm 
\right) \cdot \expectsub{\Strain\sim\mathcal{D}} {
    \otherconstantterm - f_{\Strain}(\vec{x}_0)
} \\
&amp; = 2 \cdot \left(
    f(\vec{x}_0) - \otherconstantterm 
\right) \cdot \left(
    \otherconstantterm - \expectsub{\Strain\sim\mathcal{D}}{f_{\Strain}(\vec{x}_0)}
\right) \\
&amp; = 0 \\
\end{align}\]

<p>In the first step, we can pull $u$ out of the expectation as it is a constant term with regards to $\Strain$. The same reasoning applies to $\otherconstantterm$ in the second step. Finally, we get zero in the third step by realizing that:</p>

\[\otherconstantterm = \expectsub{\Strain\sim\mathcal{D}}{f_{\Strain}(\vec{x}_0)}\]

<h4 id="interpretation-of-the-decomposition">Interpretation of the decomposition</h4>
<p>Each of the three terms in non-negative, so each of them is a lower bound on the expected loss when we predict the value for the input $\vec{x}_0$.</p>

<ul>
  <li>When the data contains <strong>noise</strong>, then that imposes a strict lower bound on the error we can achieve.</li>
  <li>The <strong>bias term</strong> is a non-negative term that tells us how far we are from the true value, in expectation. Itâs the square loss between the true value $f(\vec{x}_0)$ and the expected prediction $\otherconstantterm$, where the expectation is over the training sets. As <a href="#bias-variance-decomposition">we discussed above</a>, with a simple model we will not find a good fit on average, which means the bias will be large, which adds to the error we observe.</li>
  <li>The <strong>variance term</strong> is the variance of the prediction function. For complex models, small variations in the data set can produce vastly different models, and our prediction will vary widely, which also adds to our total error.</li>
</ul>

<h2 id="classification">Classification</h2>
<p>When we did regression, our data was of the form:</p>

\[\Strain = \set{(\vec{x}_n, y_n)}_{n=1}^N,
\qquad \vec{x}_n \in \mathbb{R}^d,\ y_n \in\mathbb{R}\]

<p>With <strong>classification</strong>, our prediction is no longer discrete. Now, $y_n\in\set{\mathcal{C}_0, \dots, \mathcal{C}_{K-1}}$. If it can only take two values (i.e. $K=2$), then it is called <strong>binary classification</strong>. If it can take more than two values, it is <strong>multi-class classification</strong>.</p>

<p>There is no ordering among these classes, so we may sometimes denote these labels as $y\in\set{0, 1, 2, \dots, K-1}$.</p>

<p>If we knew the underlying distribution $\mathcal{D}$, then it would be clear how we could measure the probability of error. We have a correct prediction when $y - f(\vec{x}) = 0$, and an incorrect one otherwise, so:</p>

\[\expectsub{\mathcal{D}}{\mathbb{I}\set{y-f(\vec{x}) \ne 0}} = \mathbb{P}(y-f(\vec{x}) \ne 0)\]

<p>Where $\mathbb{I}$ is an indicator function that returns 1 when the condition is correct, and 0 otherwise. If we donât know the distribution, we could just take an empirical sum, and use that instead.</p>

<p>A classifier will divide the input space into a collection of regions belonging to each class; the boundaries are called <strong>decision boundaries</strong>.</p>

<h3 id="linear-classifier">Linear classifier</h3>

<p>A linear classifier splits the input with a line in 2D, a plane in 3D, or more generally, a hyperplane. But a linear classifier can also classify more complex shapes if we allow for <a href="#extended-feature-vectors">feature augmentation</a>. For instance (in 2D), if we augment the input to degree $M=2$ and a constant factor, our linear classifier can also detect ellipsoids. So without loss of generality, weâll simply study linear classifiers and allow feature augmentation, without loss of generality.</p>

<h3 id="is-classification-a-special-case-of-regression">Is classification a special case of regression?</h3>
<p>From the initial definition of classification, we see that it is a special case of regression, where the output $y$ is restricted to a small discrete set instead of a continuous spectrum.</p>

<p>We could construct classification from regression by simply rounding to the nearest $\mathcal{C}_i$ value. For instance, if we have $y\in\left\{0, 1\right\}$, we can use (regularized) least-squares to learn a prediction function $f_{\Strain}$ for this regression problem. We can then convert the regression to a classification by rounding: we decide on $\mathcal{C}_1=0$ if $f_{\Strain}(\vec{x})&lt;0.5$ and $\mathcal{C}_2=1$ if $f_{\Strain}(\vec{x})&gt;0.5$.</p>

<p>But this is somewhat questionable as an approach. MSE penalizes points that are far away from the result <strong>before rounding</strong>, even though they would be correct <strong>after rounding</strong>.</p>

<p>This means that if we have a small loss with MSE, we can guarantee a small classification error (as before), but crucially, the opposite is not true: a regression function can have very high MSE though the classification error is very very small.</p>

<p>It also means that the regression line will likely not be very good. With MSE, the âpositionâ of the line defined by $f_{\Strain}$ will depend crucially on how many points are in each class, and where the points lie. This is not desirable for classification: instead of minimizing the cost function, weâd like for the fraction of misclassified cases to be small. The mean-squared error turns out to be only loosely related to this.</p>

<p><img src="/images/ml/regression-for-classification.png" alt="Example of a regression being skewed by the number of points in each class" /></p>

<p>So instead of building classification as a special case of regression, letâs take a look at some basic alternative ideas to perform classification.</p>

<h3 id="nearest-neighbor">Nearest neighbor</h3>
<p>In some cases it is reasonable to postulate that there is some spatial correlations between points of the same class: inputs that are âcloseâ are also likely to have the same label. Closeness may be measured by Euclidean distance, for instance.</p>

<p>This can be generalized easily: instead of taking the single nearest neighbor, a process very prone to being swayed by outliers, we can take the $k$ nearest neighbors (which weâll talk about <a href="#k-nearest-neighbor-knn">later in the course</a>), or a weighted linear combination of elements in the neighborhood (<a href="https://en.wikipedia.org/wiki/Kernel_smoother">smoothing kernels</a>, which we wonât talk about).</p>

<p>But this idea fails miserably in high dimensions, where the geometry renders the idea of âclosenessâ meaningless. High-dimensional space is a very lonely place; in a high-dimensional space, if we grow the area around a point, weâre likely to see no one for a very long time, and then once we get close to the boundaries of the space, ð¥, everyone is there at once. This is known as the <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality">curse of dimensionality</a>.</p>

<p>The idea also fails when we have too little data, especially in high dimensions, where the closest point may actually be far away and a very bad indicator of the local situation.</p>

<h3 id="linear-decision-boundaries">Linear decision boundaries</h3>
<p>As a starting point, we can assume that decision boundaries are linear (hyperplanes). To keep things simple, we can assume that there is a separating hyperplane, i.e. a hyperplane so that no point in the training set is misclassified.</p>

<p>There may be many such lines, so which one do we pick? This may be a little hand-wavy, but the intuition is the most ârobustâ, or the one that offers the greatest âmarginâ: we want to be able to âwiggleâ the inputs (by changing the training set) as much as possible while keeping the numbers of misclassifications low. This idea will lead us to <a href="#support-vector-machines"><em>support vector machines</em> (SVMs)</a>.</p>

<p>But the linear decision boundaries are limited, and in many cases too strong of an assumption. We can augment the feature vector with some non-linear functions, which is what we do with <a href="#kernel-trick">the kernel trick</a>, which we will talk about later. Another option is to use neural networks to find an appropriate non-linear transform of the inputs.</p>

<h3 id="optimal-classification-for-a-known-generating-model">Optimal classification for a known generating model</h3>
<p>To find a solution, we can gain some insights if we assume that we know the joint distribution $p(\vec{x}, y)$ that created the data (where $y$ takes values in a discrete set $\mathcal{y}$). In practice, we donât know the model, but this is just a thought experiment. We can assume that the data was generated from a model $(\vec{x}, y)\sim\mathcal{D}$, where $y=g(\vec{x})+\epsilon$, where $\epsilon$ is noise.</p>

<p>Given the fact that there is noise, a perfect solution may not always be possible. But if we see an input $\vec{x}$, how can we pick an optimal choice $\hat{y}(\vec{x})$ for this distribution? We want to maximize the probability of guessing the correct label, so we should choose according to the rule:</p>

\[\hat{y}(\vec{x}) = \argmax_{y\in\mathcal{Y}}{p(y\mid\vec{x})}\]

<p>This is known as the maximum a-posteriori (MAP) criterion, since we maximize the posterior probability (the probability of a class label <em>after</em> having observed the input).</p>

<p>The probability of a correct guess is thus the average over all inputs of the MAP, i.e.:</p>

\[\mathbb{P}(\hat{y}(\vec{x}) = y) = \int{p(\vec{x})p(\hat{y}(\vec{x})\mid \vec{x})dx}\]

<p>In practice we of course do not know the joint distribution, but we could use this approach by using the data itself to learn the distribution (perhaps under the assumption that it is Gaussian, and just fitting the $\mu$ and $\sigma$ parameters).</p>

<h2 id="logistic-regression">Logistic regression</h2>
<p>Recall that <a href="#is-classification-a-special-case-of-regression">we discussed</a> what happens if we look at binary classification as a regression. We also discussed that it is tempting to look at the predicted value as a probability (i.e. if the regression says 0.8, we could interpret it as 80% certainty of $\mathcal{C}_1 = 1$ and 20% probability of $\mathcal{C}_0 = 0$). But this leads to problems, as the predicted values may not be in $[0, 1]$, even largely surpassing these bounds, and this contributes to the error in MSE even though they indicate high certainty.</p>

<p>So the natural idea is to <em>transform</em> the prediction, which can take values in $(-\infty, \infty)$, into a true probability in $[0, 1]$. This is done by applying an appropriate function<sup id="fnref:squishification-function" role="doc-noteref"><a href="#fn:squishification-function" class="footnote">7</a></sup>, one of which is the <em>logistic function</em>, or <em>sigmoid function</em><sup id="fnref:logistic-implementation" role="doc-noteref"><a href="#fn:logistic-implementation" class="footnote">8</a></sup>:</p>

\[\sigma(z) := \frac{e^z}{1+e^z} = \frac{1}{1+e^{-z}}\]

<p>How do we use this? Letâs consider binary classification, with labels 0 and 1. Given a training set, we learn a weight vector $\vec{w}$. Given a new feature vector $\vec{x}$, the <em>probability</em> of the class labels given $\vec{x}$ are:</p>

\[\begin{align}
p(1 \mid \vec{x}) &amp; = \sigma(\vec{x}^T\vec{w}) \\
p(0 \mid \vec{x}) &amp; = 1 - \sigma(\vec{x}^T\vec{w}) \\
\end{align}\]

<p>This allows us to predict a certainty, which is a real value and not a label, which is why logistic regression is called regression, even though it is still part of a classification scheme. The second step of the scheme would be to quantize this value to a binary value. For binary classification, weâd pick 0 if the value is less than 0.5, and 1 otherwise.</p>

<h3 id="training">Training</h3>
<p>To train the classifier, the intuition is that weâd like to maximize the likelihood of our weight vector explaining the data:</p>

\[\argmax_{\vec{w}}{p(\vec{y}, \vec{X} \mid \vec{w})}\]

<p>We know that <a href="#properties-of-mle">maximizing the likelihood</a> is <strong>consistent</strong>, it gives us the correct model assuming we have enough data. Using the chain rule for probabilities, the probability becomes:</p>

\[p(\vec{y}, \vec{X} \mid \vec{w}) = p(\vec{X}\mid\vec{w})p(\vec{y} \mid \vec{X}, \vec{w}) = p(\vec{X})p(\vec{y} \mid \vec{X}, \vec{w})\]

<p>As weâre trying to get the argmax over the weights, we can discard $p(\vec{X})$ as it doesnât depend on $\vec{w}$. Therefore:</p>

\[\argmax_{\vec{w}}{p(\vec{y}, \vec{X} \mid \vec{w})} = \argmax_{\vec{w}}{p(\vec{y} \mid \vec{X}, \vec{w})}\]

<p>Using the fact that the samples in the dataset are independent, and given the above formulation of the prior, we can express the maximum likelihood criterion (still for the binary case $K=2$)</p>

\[\begin{align}
p(\vec{y} \mid \vec{X}, \vec{w})
    &amp; = p(y_1, \dots, y_N \mid \vec{x}_1, \dots, \vec{x}_N, \vec{w}) \\
    &amp; = \prod_{n=1}^N{p(y_n \mid \vec{x}_n, \vec{w})} \\
    &amp; = \prod_{n=1}^N{\sigma(\vec{x}_n^T \vec{w})^{y_n} (1-\sigma(\vec{x}_n^T \vec{w}))^{1-y_n}} \\
\end{align}\]

<p>But this product is nasty, so weâll remove it by taking the log. We also multiply by $-1$, which means we also need to be careful about taking the minimum instead of the maximum. The resulting cost function is thus:</p>

\[\begin{align}
\cost{\vec{w}}
    &amp; = -\sum_{n=1}^N{\left[
        y_n \log{(\sigma(\vec{x}_n^T \vec{w}))} + (1-y_n)\log{(1-\sigma(\vec{x}_n^T \vec{w}))}
    \right]} \\
    &amp; = \sum_{n=1}^N{\log{(1+\exp{(\vec{x}_n^T \vec{w})})} - y_n \vec{x}_n^T \vec{w}}
    \tag{Log-Likelihood}\label{eq:log-likelihood}
\end{align}\]

<h3 id="conditions-of-optimality">Conditions of optimality</h3>
<p>As we discuss above, weâd like to minimize the cost $\cost{\vec{w}}$. Letâs look at the stationary points of our cost function by computing its gradient and setting it to zero.</p>

<p>It just turns out that taking the derivative of the logarithm in the inner part of the sum above gives us the logistic function:</p>

\[\diff{\log{(1+\exp{(\vec{x}_n^T \vec{w})})}}{\vec{x}_n} = \sigma(\vec{x}_n)\]

<p>Therefore, the whole derivative is:</p>

\[\begin{align}
\nabla\cost{\vec{w}} 
    &amp; = \sum_{n=1}^N {\vec{x}_n (\sigma(\vec{x}_n^T\vec{w}) - y_n)} \\
    &amp; = \vec{X}^T \left[ \sigma(\vec{Xw}) - \vec{y} \right]
\end{align}\]

<p>The matrix $\vec{X}$ is $N\times N$; both $\vec{y}$ and $\vec{w}$ are column vectors of length $N$. Therefore, to simplify notation, we let $\sigma(\vec{Xw})$ represent element-wise application of the sigmoid function on the size $N$ vector resulting from $\vec{Xw}$.</p>

<p>There is no closed-form solution for this, so weâll discuss how to solve it in an iterative fashion by using gradient descent or the Newton method.</p>

<h3 id="gradient-descent-1">Gradient descent</h3>
<p>$\ref{eq:log-likelihood}$ is convex in the weight vector $\vec{w}$. We can therefore do gradient descent on this cost function as weâve always done:</p>

\[\vec{w}^{(t+1)} := \vec{w}^{(t)} - \gamma^{(t)}\nabla\cost{\vec{w}^{(t)}}\]

<h3 id="newtons-method">Newtonâs method</h3>
<p>Gradient descent is a <em>first-order</em> method, using only the first derivative of the cost function. We can get a more powerful optimization algorithm using the second derivative. This is based on the idea of Taylor expansions. The 2<sup>nd</sup> order Taylor expansion of the cost, around $\vec{w}^*$, is:</p>

\[\cost{\vec{w}} \approx \cost{\vec{w}^*}^T(\vec{w}-\vec{w}^*) + \frac{1}{2}(\vec{w}-\vec{w}^*)^T \vec{H}(\vec{w}^*)(\vec{w}-\vec{w}^*)\]

<p>Where $\vec{H}$ denotes the Hessian, the $D\times D$ symmetric matrix with entries:</p>

\[\vec{H}_{i, j} = \frac{\partial^2\cost{\vec{w}}}{\partial w_i \partial w_j}\]

<h4 id="hessian-of-the-cost">Hessian of the cost</h4>
<p>Letâs compute this Hessian matrix. Weâve already computed the gradient of the cost function <a href="#conditions-of-optimality">in the section above</a>, where saw that the gradient of a single term is:</p>

\[\vec{x}_n \sigma(\vec{x}_n^T\vec{w}) - y_n\]

<p>Each term only depends on $\vec{w}$ in the $\sigma(\vec{x}_n^T w)$ term. Therefore, the Hessian associated to one term is:</p>

\[\vec{x}_n(\nabla\sigma(\vec{x}_n^T\vec{w}))^T\]

<p>Given that the derivative of the sigmoid is $\sigmaâ(x) = \sigma(x)(1-\sigma(x))$, by the <a href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a>, each term of the sum gives rise to the Hessian:</p>

\[\vec{x}_n\vec{x}_n^T\sigma(\vec{x}_n^T \vec{w})(1 - \sigma(\vec{x}_n^T \vec{w}))\]

<p>This is the Hessian for a single term; if we sum up over all terms, we get to the following matrix product:</p>

\[\begin{align}
\vec{H}(\vec{w}) 
    &amp; = \sum_{n=1}^N{\nabla^2\mathcal{L}_n(\vec{w})} \\
    &amp; = \sum_{n=1}^N{
        \underbrace{\vec{x}_n \vec{x}_n^T}_{D\times D}
        \sigma(\vec{x}_n^T \vec{w})
        \bigl(1 - \sigma(\vec{x}_n^T \vec{w}) \bigr)
    } \\
    &amp; = \underbrace{\ \vec{X}^T \ }_{D\times N} \ 
        \underbrace{\ \vec{S}   \ }_{N\times N} \ 
        \underbrace{\ \vec{X}   \ }_{N\times D} \\
\end{align}\]

<p>The $\vec{S}$ matrix is diagonal, with positive entries, which means that the Hessian is positive semi-definite, and therefore that the problem indeed is convex. The entries are:</p>

\[S_{n, n} = \sigma(\vec{x}_n^T \vec{w})\bigl(1 - \sigma(\vec{x}_n^T \vec{w}) \bigr)\]

<h4 id="closed-form-for-newtons-method">Closed form for Newtonâs method</h4>
<p>In this model, weâll assume that the Taylor expansion above denotes the cost function exactly instead of approximately. In other words, weâre assuming strict equality $=$ instead of approximation $\approx$ as above. This is only an assumption; it isnât strictly true, but itâs a decent approximation. Where does this take minimum value? To know that, letâs set the gradient of the Taylor expansion to zero. This yields:</p>

\[H(\vec{w}^*)^{-1} \nabla\cost{\vec{w}^*} = \vec{w}^* - \vec{w}\]

<p>If we solve for $\vec{w}$, this gives us an iterative algorithm for finding the optimum:</p>

\[\vec{w}^{(t+1)} = \vec{w}^{(t)} - \vec{H}\left(\vec{w}^{(t)}\right)^{-1} \nabla\cost{\vec{w}^{(t)}} \gamma^{(t)}\]

<p>The trade-off for the Newton method is that while we need fewer iterations, each of them is more costly. In practice, which one to use depends, but at least we have another option with the Newton method.</p>

<h3 id="regularized-logistic-regression">Regularized logistic regression</h3>
<p>If the data is linearly separable, there is no finite-weight vector. Running the iterative algorithm will make the weights diverge to infinity. To avoid this, we can regularize with a penalty term.</p>

\[\argmin_w{-\sum_{n=1}^N{\log{p(y_n \mid \vec{x}_n^T\vec{w})}} + \frac{\lambda}{2}\norm{\vec{w}}^2}\]

<h2 id="generalized-linear-models">Generalized Linear Models</h2>
<p>Previously, with <a href="#a-probabilistic-model-for-least-squares">least squares</a>, we assumed that our data was of the form:</p>

\[y = x^T \vec{w} + z, \quad \text{with } z\sim\normal{0, \sigma^2}\]

<p>This is a D-linear model. When talking about generalized linear models, weâre still talking about something linear, but we allow the noise $z$ to be something else than a Gaussian distribution.</p>

<h3 id="motivation">Motivation</h3>
<p>The motivation for this is that while standard logistic regression only allows for binary outputs<sup id="fnref:binary-logistic-regression" role="doc-noteref"><a href="#fn:binary-logistic-regression" class="footnote">9</a></sup>, we may want to have something equivalently computationally efficient for, say, $y\in\mathbb{N}$. To do so, we introduce a different class of distributions, called the <em>exponential family</em>, with which we can revisit logistic regression and get other properties.</p>

<p>This will be useful in adding a degree of freedom. Previously, we most often used linear models, in which we model the data as a line, plus zero-mean Gaussian noise. As we saw, this leads to least squares. When the data is more complex than a simple line, we saw that we could augment the features (e.g. with $x^2$, $x^3$), and still use a linear model. The idea was to augment the feature space $x$. This gave us an added degree of freedom, and allowed us to use linear models for higher-degree problems.</p>

<p>These linear models predicted the mean of the distribution from which we assumed the data to be sampled. When talking about mean here, we mean what we assume the data to be modeled after, without the noise. In this section, weâll see how we can use the linear model to predict a different quantity than the mean. This will allow us to add another degree of freedom, and use linear models to get other predictions than just the shape of the data.</p>

<p>Weâve actually already done this, without knowing it. In <a href="#logistic-regression">(binary) logistic regression</a>, the probability of the classes was:</p>

\[\begin{align}
p(y = 1 \mid \eta) &amp; = \sigma(\eta) \\
p(y = 0 \mid \eta) &amp; = 1 -  \sigma(\eta) \\
\end{align}\]

<p>Weâre using $\eta$ as a shorthand for $\vec{x}^T\vec{w}$, and will do so in this section. More compactly, we can write this in a single formula:</p>

\[p(y\mid\eta) = \frac{e^{\eta y}}{1 + e^\eta} = \exp{\left[
    \eta y - \log{(1 + e^\eta)}
\right]}, \qquad y\in\set{0, 1}\]

<p>Note that the linear model $\vec{x}^T\vec{w}$ does not predict the mean, which weâll denote $\mu$ (donât get confused by this notation; in this section, $\mu$ is not a scalar, but represents the âreal valuesâ that the data is modeled after, without the noise). Instead, our linear model predicts $\eta = \vec{x}^T\vec{w}$, which is transformed into the mean by using the $\sigma$ function:</p>

\[\mu = \sigma(\eta)\]

<p>This relation between $\mu$ and $\sigma$ is known as the <strong>link function</strong>. It is a nonlinear function that makes it possible to use a linear model to predict something else than the mean $\mu$.</p>

<h3 id="exponential-family">Exponential family</h3>
<p>In general, the form of a distribution in the exponential family is:</p>

\[p(y\mid\pmb{\eta}) = h(y)\exp{\left[\pmb{\eta}^T\pmb{\phi}(y) - A(\pmb{\eta})\right]}\]

<p>Letâs take a look at the various components of this distribution:</p>

<ul>
  <li>$\pmb{\phi}(y)$ is called a <strong>sufficient statistic</strong>. Itâs usually a vector. Its name stems from the fact that its empirical average is all we need to estimate $\pmb{\eta}$</li>
  <li>$A(\pmb{\eta})$ is the <strong>log-partition function</strong>, or the <strong>cumulant</strong>.</li>
</ul>

<p>The domain of $y$ can be vary: we could choose $y\in\mathbb{R}$, $y\in\left\{0, 1\right\}$, $y\in\mathbb{N}$, etc. Depending on this, we may have to do sums or integrals in the following.</p>

<p>We require that the probability be non-negative, so we need to ensure that $h(y) \ge 0$. Additionally, a probability distribution needs to integrate to 1, so we also require that that:</p>

\[\int_y{h(y)\exp{\left[\pmb{\eta}^T\pmb{\phi}(y) - A(\pmb{\eta})\right]}} dy = 1\]

<p>This can be rewritten to:</p>

\[\int_y{h(y)\exp{\left[\pmb{\eta}^T\pmb{\phi}(y)\right]}} dy = \exp{A(\pmb{\eta})}\]

<p>The role of $A(\pmb{\eta})$ is thus only to ensure a proper normalization. To create a member of the exponential family, we can choose the factor $h(y)$, the vector $\pmb{\phi}(y)$ and the parameter $\pmb{\eta}$; the cumulant $A(\pmb{\eta})$ is then determined for each such choice, and ensures that the expression is properly normalized. From the above, it follows that $A(\pmb{\eta})$ is defined as:</p>

\[A(\pmb{\eta}) = \log{\left[\int_y{h(y)\exp{\left[\pmb{\eta}^T\pmb{\phi}(y) - A(\pmb{\eta})\right]}} dy\right]}\]

<p>We exclude the case where the integral is infinite, as we cannot compute a real $A(\pmb{\eta})$ for that case.</p>

<h4 id="link-function">Link function</h4>
<p>There is a relationship between the mean $\pmb{\mu}$ and $\pmb{\eta}$ using the link function $g$:</p>

\[\pmb{\eta} = g(\pmb{\mu}) \iff \pmb{\mu} = g^{-1}(\pmb{\eta})\]

<p>The link function is a 1-to-1 transformation from the <strong>usual parameters</strong> $\pmb{\mu}$ (e.g. $\pmb{\mu} = \set{\mu, \sigma^2}$ for Gaussian distributions) to the <strong>natural parameters</strong> $\pmb{\eta}$ (e.g. $\pmb{\eta} = \set{\frac{\mu}{\sigma^2}, -\frac{1}{2\sigma^2}}$ for Gaussian distributions).</p>

<p>For a list of such functions, consult the chapter on Generalized Linear Models in <a href="https://www.cs.ubc.ca/~murphyk/MLbook/">the KPM book</a>.</p>

<h4 id="example-bernoulli">Example: Bernoulli</h4>
<p>The Bernoulli distribution is a member of the exponential family. Its probability density is given by:</p>

\[\begin{align}
p(y\mid\mu) 
    &amp; = \mu^y(1-\mu)^{1-y}, \quad \text{where } \mu\in(0, 1) \\
    &amp; = \exp{\left[
        \left( \log{\frac{\mu}{1-\mu}} \right) y +
        \log{(1 - \mu)}
     \right]} \\
    &amp; = \exp{\left[\eta \phi(y) - A(\eta)\right]}
\end{align}\]

<p>The parameters are thus:</p>

\[\begin{align}
h(y)    &amp; = 1 \\
\phi(y) &amp; = y \\
\eta    &amp; = \log{\frac{\mu}{1-\mu}} \\
A(\eta) &amp; = -\log{(1-\mu)}=\log{(1 + e^{\eta})} \\
\end{align}\]

<p>Here, $\phi(y)$ is a scalar, which means that the family only depends on a single parameter. Note that $\eta$ and $\mu$ are linked:</p>

\[\eta 
= g(\mu) 
= \log{\frac{\mu}{1-\mu}} 
\iff 
\mu
= g^{-1}(\eta)
= \log{\frac{e^{\eta}}{1+e^{\eta}}} 
= \sigma(\eta)\]

<p>The link function is the same sigmoid function we encountered in logistic regression.</p>

<h4 id="example-poisson">Example: Poisson</h4>
<p>The Poisson distribution with mean $\mu$ is given by:</p>

\[p(y\mid\mu) = \frac{\mu^y e^{-\mu}}{y!} = \frac{1}{y!}\exp{\left[
    y \log{(\mu)} - \mu
\right]} = h(y)\exp{\left[
    \eta \phi(y) - A(\eta)
\right]}\]

<p>Where the parameters of the exponential family are given by:</p>

\[\begin{align}
h(y)    &amp; = \frac{1}{y!} \\
\phi(y) &amp; = y \\
\eta    &amp; = g(\mu) = \log{(\mu)} \\
A(\eta) &amp; = \mu = g^{-1}(\eta) = e^\eta
\end{align}\]

<h4 id="example-gaussian">Example: Gaussian</h4>
<p>Notation for Gaussian distributions can be a little confusing, so weâll make sure to distinguish the notation of the usual parameter vectors $\pmb{\mu}$ (in bold), from the parameters themselves, which are the Gaussian mean $\mu$ and variance $\sigma^2$.</p>

<p>The density of a Gaussian $\normal{\mu, \sigma^2}$ is:</p>

\[p(y\mid\mu,\sigma^2) = \frac{1}{\sqrt{2\pi\sigma^2}}\exp{-\frac{(y-\mu)^2}{2\sigma^2}},
\qquad \mu\in\mathbb{R}, 
\quad \sigma\in\mathbb{R}^+\]

<p>There are two parameters to choose in a Gaussian, $\mu$ and $\sigma$, so we can expect something of degree 2 in exponential form. Letâs rewrite the above:</p>

\[\begin{align}
p(y\mid\mu,\sigma^2) &amp; = \exp{\left[
    - \frac{y^2}{2\sigma^2}
    + \frac{\mu y}{\sigma^2}
    - \underbrace{
        \frac{\mu^2}{2\sigma^2} - \frac{1}{2}\log{(2\pi\sigma^2)}
    }_{A(\pmb{\eta})}
\right]} \\
&amp; = \exp{\left[
    \pmb{\eta}^T \pmb{\phi}(y) - A(\pmb{\eta})
\right]}
\end{align}\]

<p>Where:</p>

\[\begin{align}
h(y) &amp; = 1 \\

\pmb{\phi}(y) &amp; = \begin{bmatrix}
    y   \\
    y^2 \\
\end{bmatrix} \\

\pmb{\eta} &amp; = \begin{bmatrix}
    \eta_1 \\
    \eta_2 \\
\end{bmatrix} = \begin{bmatrix}
    \frac{\mu}{\sigma^2} \\
    -\frac{1}{2\sigma^2} \\
\end{bmatrix} \\

A(\pmb{\eta}) &amp; = \frac{\mu^2}{2\sigma^2} - \frac{1}{2}\log{(2\pi\sigma^2)}
    = \frac{\eta_1^2}{4\eta_2} - \frac{1}{2}\log{(-\eta_2/\pi)}
\end{align}\]

<p>Indeed, this time $\pmb{\phi}(y)$ is a vector of dimension 2, which reflects that the distribution depends on 2 parameters. As the formulation of $\pmb{\eta}$ shows, we have a 1-to-1 correspondence to $\pmb{\eta}=(\eta_1, \eta_2)$ and the $(\mu, \sigma^2)$ parameters:</p>

\[\eta_1 = \frac{\mu}{\sigma^2},\ \eta_2 = -\frac{1}{2\sigma^2}
\quad \iff \quad
\mu = -\frac{\eta_1}{2\eta_2},\ \sigma^2 = -\frac{1}{2\eta_2}\]

<h4 id="properties-1">Properties</h4>
<ol>
  <li>$A(\pmb{\eta})$ is convex</li>
  <li>$\nabla_{\pmb{\eta}}   A(\pmb{\eta}) = \expect{\pmb{\phi}(y)}$</li>
  <li>$\nabla_{\pmb{\eta}}^2 A(\pmb{\eta}) = \expect{\pmb{\phi}(y)^T\pmb{\phi}(y)} - \expect{\pmb{\phi}(y)}^T\expect{\pmb{\phi}(y)}$</li>
  <li>$\pmb{\mu} := \expect{\pmb{\phi}(y)}$</li>
</ol>

<p>Proofs for the first 3 properties are in the lecture notes. The last property is given without proof.</p>

<h3 id="application-in-ml">Application in ML</h3>

<p>We use $\eta_n = \vec{x}_n^T\vec{w}$, or equivalently,  $\pmb{\eta} = \vec{X}^T\vec{w}$.</p>

<h4 id="maximum-likelihood-parameter-estimation">Maximum Likelihood Parameter Estimation</h4>
<p>Assume that we have samples composing our training set, $\Strain = \set{(\vec{x}_n, y_n)}_{n=1}^N$ i.i.d. from some distribution, which we assume is some exponential family. Assume we have picked a model, i.e. that we fixed $h(y)$ and $\pmb{\phi}(y)$, but that $\pmb{\eta}$ is unknown. How can we find an optimal $\pmb{\eta}$?</p>

<p>We said previously that $\pmb{\phi}(y)$ is a sufficient statistic, and that we could find $\pmb{\eta}$ from its empirical average; this is what weâll do here. We can use the maximum likelihood principle to find this parameter, meaning that we want to minimize log-likelihood:</p>

\[\begin{align}
\mathcal{L}_{LL}(\pmb{\eta})
    &amp; = -\log{(p(y \mid \pmb{\eta}))} \\
    &amp; = \sum_{n=1}^N{\left(
        -\log{\left[h(y_n)\right] - \eta_n^T\pmb{\phi}(y_n) + A(\eta_n)}
    \right)}
\end{align}\]

<p>This is a convex function in $\pmb{\eta}$: the $h(y)$ term does not depend on $\pmb{\eta}$, $\pmb{\eta}^T\pmb{\phi}(y_n)$ is linear, $A(\pmb{\eta})$ has the <a href="#properties-1">property of being convex</a>.</p>

<p>If we assume that we have the link function already, we can get $\pmb{\eta}$ by setting the gradient of our exponential family to 0. We also multiply by $\frac{1}{N}$ to get a more convenient form, i.e. with $\expect{\pmb{\phi}(y)}$ instead of $N\cdot\expect{\pmb{\phi}(y)}$:</p>

\[\begin{align}
\frac{1}{N} \nabla\cost{\pmb{\eta}}
  &amp; = -\frac{1}{N}\sum_{n=1}^N{\bigl[\pmb{\phi}(y_n) 
      - \nabla A(\eta_n)\bigr]} \\
  &amp; = -\frac{1}{N}\left( \sum_{n=1}^N{\pmb{\phi}(y_n)} \right)
      + \expect{\pmb{\phi}(y)}  \\
  &amp; = 0
\end{align}\]

<p>Since $\pmb{\mu} := \expect{\pmb{\phi}(y)}$, we get:</p>

\[\pmb{\mu} := \expect{\pmb{\phi}(y)} = \frac{1}{N} \sum_{n=1}^N{\pmb{\phi}(y_n)}\]

<p>Therefore, we can get $\pmb{\eta}$ by using the link function:</p>

\[\pmb{\eta} 
    = g^{-1}(\pmb{\mu}) 
    = g^{-1}\left( \frac{1}{N}\sum_{n=1}^N{\pmb{\phi}(y_n)} \right) \\\]

<p>With this, we can see the justification for calling $\pmb{\phi}(y)$ a sufficient statistic.</p>

<h4 id="conditions-of-optimality-1">Conditions of optimality</h4>
<p>If we assume that our samples follow the distribution of an exponential family, we can construct a <em>generalized linear model</em>. As weâve explained previously, this is a generalization of the model we used for logistic regression.</p>

<p>For such a model, the maximum likelihood problem, as described above, is easy to solve. As weâve noted above, the cost function is convex, so a greedy, iterative algorithm should work well. Letâs look at the gradient of the cost in terms of $\vec{w}$ (instead of $\pmb{\eta} = \vec{x}^T\vec{w}$ as previously):</p>

\[\begin{align}
\cost{\vec{w}} 
    &amp; = -\sum_{n=1}^N{
        \log{(h(y_n))} + \vec{x}_n^T\vec{w} \pmb{\phi}(y_n) - A(\vec{x}_n^T\vec{w})
    } \\

\nabla_{\vec{w}}\cost{\vec{w}} 
    &amp; = -\sum_{n=1}^N{
        \vec{x}_n \pmb{\phi}(y_n) - \nabla_{\vec{w}} A(\vec{x}_n^T\vec{w})
    }
\end{align}\]

<p>Letâs recall that the derivative of the cumulant is:</p>

\[\frac{\partial A(\pmb{\eta})}{\partial \pmb{\eta}} = \expect{\pmb{\phi}(y)} = g^{-1}(\pmb{\eta})\]

<p>Hence the gradient of the cost function is:</p>

\[\nabla_{\vec{w}}\cost{\vec{w}} 
= - \sum_{n=1}^N {\vec{x}_n \pmb{\phi}(y_n) 
  - \vec{x}_n g^{-1}(\vec{x}_n^T\vec{w})}\]

<p>Setting this to zero gives us the condition of optimality. Using matrix notation, we can rewrite this sum as follows:</p>

\[\nabla_{\vec{w}}\cost{\vec{w}} 
= \vec{X}^T\left( g^{-1}(\vec{Xw}) - \pmb{\phi}(\vec{y}) \right) 
= 0\]

<p>Note that this is a more general form of the formula we had <a href="#conditions-of-optimality">for logistic regression</a>. At this point, seeing that the function is convex, we can use a greedy iterative algorithm like gradient descent to find the minimum.</p>

<h2 id="nearest-neighbor-classifiers-and-the-curse-of-dimensionality">Nearest neighbor classifiers and the curse of dimensionality</h2>
<p>For simplicity, letâs assume that weâre operating in a d-dimensional box, that is, in the domain $\chi = [0, 1]^d$. As always, we have a training set $\Strain=\set{(\vec{x}_n, y_n)}$.</p>

<h3 id="k-nearest-neighbor-knn">K Nearest Neighbor (KNN)</h3>
<p>Given a âfreshâ input $\vec{x}$, we can make a prediction using $\text{nbh}_{\Strain,\ k}(\vec{x})$. This is a set of the $k$ inputs in the training set that are closest to $\vec{x}$.</p>

<p>For the regression problem, we can take the average of the k nearest neighbors:</p>

\[f(\vec{x}) = \frac{1}{k}\sum_{n\in\text{nbh}_{\Strain,\ k}(\vec{x})}{y_n}\]

<p>For binary classification, we take the majority element in the $k$-neighborhood. Itâs a good idea to pick $k$ to be odd so that there is a clear winner.</p>

\[f(\vec{x}) = \text{maj}\set{y_n : n \in \text{nbh}_{\Strain, k}(\vec{x})}\]

<p>If we pick a large value of $k$, then we are smoothing over a large area. Therefore, a large $k$ gives us a simple model, with simpler boundaries, while a small $k$ is a more complex model. In other words, complexity is inversely proportional to $k$. As we saw when we talked about <a href="#bias-variance-decomposition">bias and variance</a>, if we pick a small value of $k$ we can expect a small bias but huge variance. If we pick a large $k$ we can expect large bias but small variance.</p>

<h3 id="analysis">Analysis</h3>
<p>Weâll analyze the simplest setting, a binary KNN model (that is, there are only two output labels, 0 and 1). Letâs start by simplifying our notation. Weâll introduce the following function:</p>

\[\eta(\vec{x}) = \mathbb{P}\left\{y=1\mid\vec{x}\right\}\]

<p>This is the conditional probability that the label is 1, given that the input is $\vec{x}$. If this probability is to be meaningful at all, we must have some correlation between the âpositionâ x and the associated label; knowing the labels close by must give us some information. This means that we need an assumption on the distribution $\mathcal{D}$:</p>

\[\abs{\eta(\vec{x}) - \eta(\vec{x}')} \le \mathcal{c}\norm{\vec{x} - \vec{x}'}
\label{eq:lipschitz-bound}\tag{Lipschitz bound}\]

<p>On the right-hand side we have Euclidean distance. In other words, we ask that the conditional probability $\mathbb{P}\left\{y=1\mid\vec{x}\right\}$, denoted by $\eta(x)$, be <a href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Lipschitz continuous</a> with Lipschitz constant $\mathcal{c}$. We will use this assumption later on to prove a performance bound for our KNN model.</p>

<p>Letâs assume for a moment that we know the actual underlying distribution. This is not something that we actually know in practice, but is useful for deriving a formulation for the optimal model. Knowing the distribution probability distribution, our optimum decision rule is given by the classifier:</p>

\[f_*(\vec{x}) = \mathbb{I}\left[ \eta(\vec{x}) &gt; \frac{1}{2} \right]\]

<p>The idea of this classifier is that with two labels, weâll pick the label that is likely to happen more than half of the time. The intuition is that if we were playing heads or tails and knew the probability in advance, we would always pick the option that has probability more than one half, and that is the best strategy we can use. This is known as the <strong>Bayes classifier</strong>, also called <strong>maximum a posteriori (MAP) classifier</strong>. It is optimal, in that it has the smallest probability of misclassification of any classifier, namely:</p>

\[\cost{f_*} = \expectsub{\vec{x}\sim\mathcal{D}}{
    \min{\set{ \eta(\vec{x}), 1-\eta(\vec{x}) }}
}\]

<p>Letâs compare this to the probability of misclassification of the real model:</p>

\[\cost{f_{\Strain,\ k=1}} = \expect{\mathbb{I}\left[ f_{\Strain}(\vec{x}) \ne y \right]}\]

<p>This tells us that the risk (that is, the error probability of our $k=1$ nearest neighbor classifier) is the above expectation. Itâs hard to find a closed form for that expectation, but we can place a bound on it by comparing the ideal, theoretical model to the actual model. Weâll state the following lemma:</p>

\[\begin{align}
\cost{f_{\Strain}}
    &amp; \le 2 \cost{f_*} + \mathcal{c} \expectsub{\Strain, \vec{x}\sim\mathcal{D}}{\norm{\vec{x} - \text{nbh}_{\Strain, 1}(\vec{x})}} \\
    
    &amp; \le 2 \cost{f_*} + 4\mathcal{c}\sqrt{d} N^{-\frac{1}{d+1}} \\
\end{align}\]

<p>Before we see where this comes from, letâs just interpret it. The above gives us a bound on the real classifier, compared to the optimal one. The actual classifier is upper bounded by twice the risk of the optimal classifier (this is good), plus a geometric term reflecting dimensionality (it depends on $d$: this will cause us some trouble).</p>

<p>This second term of the sum is the average distance of a randomly chosen point to the nearest point in the training set, times the Lipschitz constant $\mathcal{c}$. It intuitively makes sense to incorporate this factor into our bound: if we are basing our prediction on a point that is very close, weâre more likely to be right, and if itâs far away, less so. If weâre in a box of $[0, 1]^d$, then the distance between two corners would be $\sqrt{d}$ (by Pythagorasâ theorem). The term $N^{-\frac{1}{d+1}}$ indicates that the closest data point may be closer than the opposite corner of the cube: if we have more data, weâll probably not have to go that far. However, for large dimensions, we need much more data to have something thatâll probably be close.</p>

<p>Letâs prove where this geometric term comes from by considering the cube $[0, 1]^d$, the space of inputs containing $\vec{x}$. We can cut this large cube into small cubes of side length $\epsilon$. Consider the small cube containing $\vec{x}$. If we are lucky, this small cube also contains a neighboring data point at distance at most $\sqrt{d}\epsilon$ (at the opposite corner of the small cube; we use Pythagorasâ theorem as above). However, if weâre less lucky, the closest neighbor may be at the other corner of the big cube, at distance $\sqrt{d}$. So what is the probability of a point not having a neighbor in its small $\epsilon$ cube?</p>

<p>Letâs denote the probability of $\vec{x}$ landing in a particular box by $\mathbb{P}_i$. The chance that none of the N training points are in the box is $(1-\mathbb{P}_i)^N$. We donât know the distribution $\mathcal{D}$, so we canât really express $\mathbb{P}_i$ in a closed form, but that doesnât matter, this notation allows us to abstract over that. The rest of the proof is calculus, carefully choosing the right scaling for $\epsilon$ in order to get a good bound.</p>

<p>Now, letâs understand where the term $2\cost{f_*}$ comes from. If we flip two coins, $y$ and $yâ$, what is the probability of the outcome being different?</p>

\[\mathbb{P}\left\{y \ne y' \right\} = 2p(1-p)\]

<p>Now, letâs consider two points $\vec{x}$ and $\vec{x}â$, both elements of $[0, 1]^d$. Their labels are $y$ and $yâ$, respectively. The probability of these two labels being different is roughly the same as above (although the probabilities of the two events may not be the same in general):</p>

\[\begin{align}
\mathbb{P}\left\{ y \ne y'\right\}
    =   &amp; \eta(\vec{x})(1-\eta(\vec{x}')) + \eta(\vec{x}')(1-\eta(\vec{x})) \\
    =   &amp; 2\eta(\vec{x})(1-\eta(\vec{x})) + (2\eta(\vec{x})-1)(\eta(\vec{x})-\eta(\vec{x}')) \\
    \le &amp; 2\eta(\vec{x})(1-\eta(\vec{x})) + (\eta(\vec{x}) - \eta(\vec{x}')) \\
    \le &amp; 2\eta(\vec{x})(1-\eta(\vec{x})) + \mathcal{c}\norm{\vec{x}-\vec{x}'}
\end{align}\]

<p>The second to last step uses the fact that $\eta$ is a probability distribution, so $-1 \le 2\eta(\vec{x})-1 \le 1$. The last step uses the $\ref{eq:lipschitz-bound}$.</p>

<p>Therefore, we can confirm the following bound:</p>

\[\mathbb{P}\left\{ y\ne y' \right\} \le  2\eta(\vec{x})(1-\eta{\vec{x}}) + \mathcal{c}\norm{\vec{x} - \vec{x}'}\]

<p>But we are still one step away from explaining how we can compare this to the optimal estimator. In the above, we derived a bound for two labels being different. How is this related to our KNN model? The probability of getting a wrong prediction from KNN with $k=1$ (which we denoted $\expectsub{\Strain}{\cost{f_{\Strain}}}$) is the probability of the predicted label being different from the solution label.</p>

<p>We get to our lemma by the following reasoning:</p>

\[2\eta(\vec{x})(1-\eta{\vec{x}}) 
    \le 2\min{\left\{ \eta(\vec{x}), 1-\eta(\vec{x}) \right\}}
    = 2\cost{f_*}\]

<p>Additionally, the average of the term $\mathcal{c}\norm{\vec{x} - \vec{x}â}$ is $\mathcal{c}\expectsub{\Strain, \vec{x}\sim\mathcal{D}}{\norm{\vec{x} - \text{nbh}_{\Strain, 1}(\vec{x})}}$</p>

<p>If we had assumed that it was a ball instead of a cube, we wouldâve gotten slightly different results. But thatâs besides the point: the main insight from this is that it depends on the dimension, and that for low dimensions at least, we still have a fairly good classifier. But finding a closest neighbor in high dimension can quickly become meaningless.</p>

<h2 id="support-vector-machines">Support Vector Machines</h2>
<h3 id="definition">Definition</h3>
<p>Letâs re-consider binary classification. In the following it will be more convenient to consider $y_n\in\set{\pm 1}$. This is equivalent to what weâve done previously, under the mapping $0 \mapsto -1$ and $1\mapsto 1$. Note that this mapping can be done continuously in the range $[0, 1] \mapsto [-1, 1]$ by computing $\tilde{y}_n = 2y_n - 1$, and back with $y_n = \frac{1}{2}(\tilde{y}_n + 1)$.</p>

<p>Previously, we used MSE or logistic loss. MSE is symmetric, so something being positive or negative is punished at an equal rate. With logistic regression, we always have a loss, but its value is asymmetric, shrinking the further we go right.</p>

<p>If we instead use hinge loss (as defined below), with an additional regularization term, we get <strong>Support Vector Machines</strong> (SVM).</p>

\[\text{Hinge}(z, y) =  [1-yz]_+ = \max{\left\{ 0, 1-yz \right\}}\]

<p>Here, we use $z$ as shorthand for $\vec{x}^T \vec{w}$. The function multiplies the prediction with the actual label, which produces a positive result if they are of the same sign, and a negative result if they have different signs (this is why we wanted our labels in $\set{\pm 1}$). When the prediction is correct and above one, $1-yz$ becomes negative, and hinge loss returns 0. This makes hinge loss a linear function when predictions are incorrect or below one; it does not punish correct predictions above one, which pushes us to give predictions that we can be very confident about (above one).</p>

<p><img src="/images/ml/hinge-mse-logistic.png" alt="Graph of hinge loss, MSE and logistic" /></p>

<p>SVMs correspond to the following optimization problem:</p>

\[\min_{\vec{w}}{\sum_{n=1}^N{\left[ 1 - y_n \vec{x}_n^T \vec{w}\right]_+} + \frac{\lambda}{2}\norm{\vec{w}}^2}\]

<p>What does this optimization problem correspond to, intuitively?</p>

<p><img src="/images/ml/margin.png" alt="Margin of a dataset" /></p>

<p>In the figure above, the pink region represents the âmarginâ created by the SVM. The center of the margin is the separating hyperplane; its direction is perpendicular to $\vec{w}$, the normal vector defining the hyperplane. The marginâs total width is $2/\norm{\vec{w}}$.</p>

<p>Points inside the margin are feature vectors $\vec{x}$ for which $\abs{\vec{x}^T\vec{w}} &lt; 1$. These points incur a cost with hinge loss. Any points outside the margin, for which $\abs{\vec{x}^T\vec{w}} \ge 1$, do not incur any cost, as long as theyâre on the correct side. Thus, depending on the $\vec{w}$ that we choose, the orientation and size of the margin will change; there will be a different number of points in it, and the cost will change.</p>

<p>How can we pick a good margin? Letâs assume $\lambda$ is small; we wonât define that further, the main point is just we pick one with the following priorities (in order):</p>

<ol>
  <li>We want a separating hyperplane</li>
  <li>We want a scaling of $\vec{w}$ so that no point of the data is in the margin</li>
  <li>We want the margin to be as wide as possible</li>
</ol>

<p>With conditions 1 and 2, we can ensure that there is no cost incurred in the first expression (the sum over $[1 - y_n \vec{x}_n^T \vec{w}]_+$). The third condition is ensured by the fact that weâre minimizing $\norm{\vec{w}}^2$. Since the size of the margin is inversely proportional to that, weâre maximizing the margin.</p>

<p>Weâve introduced SVMs for the general case, where the data is not necessarily linearly separable, which is the <em>soft-margin</em> formulation. In the <em>hard-margin</em> formulation, the data is linearly separable by a separating hyperplane. Maximizing the margin size in the hard-margin formulation implies that some points will lie exactly on the margin boundary (on the correct side). These points are called <strong>essential support vectors</strong>. For the soft-margin case, this interpretation becomes a little more muddled.</p>

<h3 id="alternative-formulation-duality">Alternative formulation: Duality</h3>
<p>Now that we know what function weâre optimizing, letâs look at how we can optimize it efficiently. The function is convex, and has a subgradient in $\vec{w}$, which means we can use SGD with subgradients. This is good news! Weâll discuss an alternative, but equivalent formulation via the concept of <em>duality</em>, which can lead us to a more efficient implementation in some cases. More importantly though, the dual problem can point us to a more general formulation, called the <a href="#kernel-trick">kernel trick</a>.</p>

<p>Letâs say that weâre interested in minimizing a cost function $\cost{\vec{w}}$. Letâs assume this can be defined through an auxiliary function $G$, such that:</p>

\[\cost{\vec{w}} = \max_{\pmb{\alpha}}{G(\vec{w}, \pmb{\alpha})}\]

<p>The minimization in question is thus:</p>

\[\min_{\vec{w}}{\cost{\vec{w}}}
= \min_{\vec{w}}{\max_{\pmb{\alpha}}{G(\vec{w}, \pmb{\alpha})}}\]

<p>We call this the <strong>primal problem</strong>. In some cases though, it may be easier to find this in the other direction:</p>

\[\max_{\pmb{\alpha}}{\min_{\vec{w}}{G(\vec{w}, \pmb{\alpha})}}\]

<p>We call this the <strong>dual problem</strong>. This leads us to a few questions:</p>

<h4 id="how-do-we-find-a-suitable-function-g">How do we find a suitable function G?</h4>
<p>Thereâs a general theory on this topic (see <a href="http://www.athenasc.com/nonlinbook.html">Nonlinear Programming</a> by Dimitri Bertsekas). In the case of SVMs though, the finding the function G is rather straightforward, once we restate the hinge loss as follows:</p>

\[[z]_+ = \max{\left\{ 0, z \right\}} = \max_{\alpha}{\alpha z}, \qquad \text{with } \alpha\in[0, 1]\]

<p>The SVM problem then becomes:</p>

\[\min_{\vec{w}}{\max_{\pmb{\alpha}\in[0, 1]^N}{
    \underbrace{
        \sum_{n=1}^N{
            \alpha_n (1 - y_n \vec{x}_n^T \vec{w})
        } + \frac{\lambda}{2}\norm{\vec{w}}^2
    }_{G(\vec{w}, \pmb{\alpha})}
}}
\label{eq:svm-primal}\tag{Primal problem}\]

<p>Note that G is convex in $\vec{w}$, and linear, hence concave, in $\pmb{\alpha}$.</p>

<h4 id="when-is-it-ok-to-switch-min-and-max">When is it OK to switch min and max?</h4>
<p>It is always true that:</p>

\[\max_{\pmb{\alpha}}{\min_{\vec{w}}{G(\vec{w}, \pmb{\alpha})}}
\le
\min_{\vec{w}}{\max_{\pmb{\alpha}}{G(\vec{w}, \pmb{\alpha})}}\]

<p>This is proven by:</p>

\[\begin{align}
\min_{\vec{w}'}{G(\vec{w}', \pmb{\alpha})} 
&amp; \le G(\vec{w}, \pmb{\alpha}) 
  \quad \forall \vec{w}, \pmb{\alpha} 
&amp; \iff \\

\max_{\pmb{\alpha}}{\min_{\vec{w}'}{G(\vec{w}', \pmb{\alpha})}} 
&amp; \le \max_{\pmb{\alpha}}{G(\vec{w}, \pmb{\alpha})} 
  \quad \forall \vec{w} 
&amp; \iff \\

\max_{\pmb{\alpha}}{\min_{\vec{w}'}{G(\vec{w}', \pmb{\alpha})}} 
&amp; \le \min_{\vec{w}} \max_{\pmb{\alpha}}{G(w, \pmb{\alpha})} 
&amp; \\
\end{align}\]

<p>Equality is achieved when the function looks like a saddle: when $G$ is a continuous function that is convex in $\vec{w}$, concave in $\pmb{\alpha}$, and the domains of both are compact and convex.</p>

<p><img src="/images/ml/saddle.png" alt="Saddle function" /></p>

<p>For SVMs, this condition is fulfilled, and the switch between min and max can be done. The alternative formulation of SVMs is:</p>

\[\max_{\pmb{\alpha}\in[0, 1]^N}{\min_{\vec{w}}{
    \underbrace{
        \sum_{n=1}^N{
            \alpha_n (1 - y_n \vec{x}_n^T \vec{w})
        } + \frac{\lambda}{2}\norm{\vec{w}}^2
    }_{G(\vec{w}, \pmb{\alpha})}
}}
\label{eq:svm-dual}\tag{Dual problem}\]

<p>We can take the derivative with respect to $\vec{w}$:</p>

\[\nabla_{\vec{w}}G(\vec{w}, \pmb{\alpha}) 
    = -\sum_{n=1}^N{\alpha_n y_n \vec{x}_n + \lambda\vec{w}}\]

<p>Weâll set this to zero to find a formulation of $\vec{w}$ in terms of $\alpha$. We get:</p>

\[\vec{w}(\pmb{\alpha}) = \frac{1}{\lambda}\sum_{n=1}^N{\alpha_n y_n \vec{x}_n} = \frac{1}{\lambda}\vec{X}^T\vec{Y}\pmb{\alpha}\]

<p>Where $\vec{Y} := \text{diag}(\vec{y})$. If we plug this into $\ref{eq:svm-dual}$, we get the following dual problem, in quadratic form:</p>

\[\begin{align}
&amp;   \max_{\pmb{\alpha}\in[0, 1]^N}{
    \sum_{n=1}^N \alpha_n(1 - \frac{1}{\lambda}y_n \vec{x}_n^T \vec{X}^T\vec{Y}\pmb{\alpha}) + \frac{\lambda}{2}\norm{\frac{1}{\lambda}\vec{X}^T\vec{Y}\pmb{\alpha}}^2
} \\
&amp; = \max_{\pmb{\alpha}\in[0, 1]^N}{
    \pmb{\alpha}^T\vec{1} - \frac{1}{2\lambda}\pmb{\alpha}^T\vec{YXX}^T\vec{Y}\pmb{\alpha}
} \label{eq:svm-quadratic-form} \tag{Quadratic form}
\end{align}\]

<h4 id="when-is-the-dual-easier-to-optimize-than-the-primal">When is the dual easier to optimize than the primal?</h4>
<ol>
  <li>When the dual is a differentiable quadratic problem (as SVM is). This is a problem that takes the same $\ref{eq:svm-quadratic-form}$ as above. In this case, we can optimize by using <strong>coordinate descent</strong> (or more precisely, ascent, as weâre searching for the maximum). Crucially, this method only changes one $\alpha_n$ variable at a time.</li>
  <li>In the $\ref{eq:svm-quadratic-form}$ above, the data enters the formula in the form $\vec{K} = \vec{XX}^T$. This is called the <strong>kernel</strong>. We say this formulation is <em>kernelized</em>. Using this representation is called the <em>kernel trick</em>, and gives us some nice consequences that weâll discuss later.</li>
  <li>Typically, the solution $\pmb{\alpha}$ is sparse, being non-zero only in the training examples that are instrumental in determining the decision boundary. If we recall how we defined $\alpha$ in <a href="#how-do-we-find-a-suitable-function-g">an alternative formulation</a> of $[z]_+$, we can see that there are three distinct cases to consider:
    <ol>
      <li>Examples that lie on the correct side, and outside the margin, for which $\alpha_n = 0$. These are <strong>non-support vectors</strong></li>
      <li>Examples that are on the correct side and just on the margin, for which $y_n \vec{x}_n^T \vec{w} = 1$, so $\alpha_n \in (0, 1)$. These $\vec{x}_n$ are <strong>essential support vectors</strong></li>
      <li>Examples that are strictly within the margin, or on the wrong side have $\alpha_n = 1$, and are called <strong>bound support vectors</strong></li>
    </ol>
  </li>
</ol>

<h3 id="kernel-trick">Kernel trick</h3>
<p>We saw previously that our data only enters $\ref{eq:svm-quadratic-form}$ in the form of a kernel, $\vec{K} = \vec{XX}^T$. Weâll see now that when weâre using the kernel, we can easily go to a much larger dimensional space (even infinite dimensional space) without adding any complexity. This isnât always applicable though, so weâll also see which kernel functions are admissible for this trick.</p>

<h4 id="alternative-formulation-of-ridge-regression">Alternative formulation of ridge regression</h4>
<p>Letâs recall that least squares is a special case of ridge regression (where $\lambda = 0$). Ridge regression corresponds to the following optimization problem:</p>

\[\vec{w}^* = \min_{\vec{w}}{\sum_{n=1}^N{(y_n - \vec{x}_n^T w)^2 + \frac{\lambda}{2}\norm{\vec{w}}^2}}\]

<p>We saw that the solution has a closed form:</p>

\[\vec{w}^* = (\vec{X}^T\vec{X} + \lambda\vec{I}_D)^{-1} \vec{X}^T y\]

<p>We claim that this can be alternatively written as:</p>

\[\vec{w}^* = 
    \vec{X}^T
    (\underbrace{\vec{XX}^T\vec{X} +  \lambda\vec{I}_N}_{N\times N})^{-1}
    y\]

<p>The original formulationâs runtime is $\mathcal{O}(D^3 + ND^2)$, while the alternative is $\mathcal{O}(N^3 + DN^2)$. Which is more efficient depends on $D$ and $N$.</p>

<details><summary><p>Proof</p>
</summary><div class="details-content">
<p>We can prove this formulation by using the following identity. If we let $\vec{P}$ be an $N\times M$ matrix, and $\vec{Q}$ be $M\times N$. Then:</p>

\[\vec{P}(\vec{QP} + \vec{I}_M) = \vec{PQP} + \vec{P} = (\vec{PQ} + \vec{I}_N)\vec{P}\]

<p>Assuming that $(\vec{QP} + \vec{I}_M)$ and $(\vec{PQ} + \vec{I}_N)$ are invertible, we have the identity:</p>

\[(\vec{PQ}+\vec{I}_N)^{-1}\vec{P} = \vec{P}(\vec{QP}+\vec{I}_M)^{-1}\]

<p>To derive the formula, we can let $\vec{P} = \vec{X}^T$ and $\vec{Q} = \frac{1}{\lambda}\vec{X}$.</p>
</div></details>

<h4 id="representer-theorem">Representer theorem</h4>
<p>The representer theorem generalizes what we just saw about ridge regression. For a $\vec{w}^*$ minimizing the following, for any cost $\mathcal{L}_n$,</p>

\[\min_{\vec{w}}{\sum_{n=1}^N{
    \mathcal{L}_n(\vec{x}_n^T \vec{w}, y_n) + \frac{\lambda}{2}\norm{\vec{w}}^2
}}\]

<p>there exists $\pmb{\alpha^*}$ such that $\vec{w}^* = \vec{X}^T \pmb{\alpha}^*$.</p>

<h4 id="kernelized-ridge-regression">Kernelized ridge regression</h4>
<p>The above theorem gives us a new way of searching for $\vec{w}^*$: we can first search for $\pmb{\alpha^*}$, which might be easier, and then get back to the optimal weights by using the identity $\vec{w}^* = \vec{X}^T \pmb{\alpha}^*$.</p>

<p>Therefore, for ridge regression, we can equivalently optimize our alternative formula in terms of $\alpha$:</p>

\[\pmb{\alpha}^* = \argmin_{\pmb{\alpha}}{
    \frac{1}{2}\pmb{\alpha}^T(\vec{XX}^T + \lambda \vec{I}_N)\pmb{\alpha} 
    - \pmb{\alpha}^T \vec{y}}\]

<p>We see that our data enters in kernel form. How do we get the solution to this minimization problem? We can, as always, take the gradient of the cost function according to $\pmb{\alpha}$ and set it to zero:</p>

\[\nabla_{\pmb{\alpha}}\cost{\pmb{\alpha}} 
= (\vec{XX}^T + \lambda \vec{I}_N)\pmb{\alpha} - \vec{y} = 0\]

<p>Solving for $\alpha$ results in:</p>

\[\begin{align}
\pmb{\alpha}^*  &amp; = (\vec{XX}^T + \lambda \vec{I}_N)^{-1} \vec{y} \\
\vec{w}^*       &amp; = \vec{X}^T\pmb{\alpha}^* 
                  = \vec{X}^T(\vec{XX}^T + \lambda \vec{I}_N)^{-1} \vec{y}
\end{align}\]

<p>Weâve effectively gotten back to our claimed alternative formulation for the optimal weights.</p>

<h4 id="kernel-functions">Kernel functions</h4>
<p>The kernel is defined as $\vec{K} = \vec{XX}^T$. Weâll call this the <strong>linear kernel</strong>. The elements are defined as:</p>

\[\vec{K} = \vec{XX}^T = \begin{bmatrix}
\vec{x}_1^T\vec{x}_1 &amp; \vec{x}_1^T\vec{x}_2 &amp; \cdots &amp; \vec{x}_1^T\vec{x}_N \\
\vec{x}_2^T\vec{x}_1 &amp; \vec{x}_2^T\vec{x}_2 &amp; \cdots &amp; \vec{x}_2^T\vec{x}_N \\
\vdots               &amp; \vdots               &amp; \ddots &amp; \vdots               \\
\vec{x}_N^T\vec{x}_1 &amp; \vec{x}_N^T\vec{x}_2 &amp; \cdots &amp; \vec{x}_N^T\vec{x}_N \\  
\end{bmatrix}\]

<p>The kernel matrix is a $N\times N$ matrix. Now, assume that we had first augmented the feature space with $\phi(\vec{x})$; the elements of the kernel would then be:</p>

\[\vec{K} = \pmb{\Phi}\pmb{\Phi}^T = \begin{bmatrix}
\phi(\vec{x}_1)^T\phi(\vec{x}_1) &amp; \phi(\vec{x}_1)^T\phi(\vec{x}_2) &amp; \cdots &amp; \phi(\vec{x}_1)^T\phi(\vec{x}_N) \\
\phi(\vec{x}_2)^T\phi(\vec{x}_1) &amp; \phi(\vec{x}_2)^T\phi(\vec{x}_2) &amp; \cdots &amp; \phi(\vec{x}_2)^T\phi(\vec{x}_N) \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\phi(\vec{x}_N)^T\phi(\vec{x}_1) &amp; \phi(\vec{x}_N)^T\phi(\vec{x}_2) &amp; \cdots &amp; \phi(\vec{x}_N)^T\phi(\vec{x}_N) \\
\end{bmatrix}\]

<p>Using this formulation allows us to keep the size of $\vec{K}$ the same, regardless of how much we augment. In other words, we can now solve a problem where the size is independent of the feature space.</p>

<p>The feature augmentation goes from $\vec{x}_n \in \mathbb{R}^D$ to $\phi(\vec{x}_n) \in \mathbb{R}^{Dâ}$ with $Dâ \gg D$, or even to an infinite dimension.</p>

<p>The big advantage of using kernels is that rather than first augmenting the feature space and then computing the kernel by taking the dot product, we can do both steps together, and we can do it more efficiently.</p>

<p>Letâs define a kernel function $\kappa(\vec{x}, \vec{x}â)$. Weâll let entries in the kernel $K$ be defined by:</p>

\[K_{i, j} = \kappa(\vec{x}_i, \vec{x}_j)\]

<p>We can pick different kernel functions and get some interesting results. If we pick the right kernel, it can be equivalent to augmenting the features with some $\phi(\vec{x})$, and then computing the inner product:</p>

\[\kappa(\vec{x}, \vec{x}') = \phi(\vec{x})^T\phi(\vec{x}')\]

<p>Hopefully, $\kappa$ is simple enough of a function that itâll still be easier to compute than going to the higher dimensional space via $\phi$ and then computing the dot product.</p>

<p>Letâs take a look at a few examples of choices for $\kappa$ and see what happens. In the following, weâll go the other way around, picking a $\kappa$ and showing that itâs equivalent to a particular feature augmentation $\phi$.</p>

<h5 id="trivial-kernels">Trivial kernels</h5>
<p>This is the trivial example, in which there is no feature augmentation. The following definition of $\kappa$ is equivalent to the identity âaugmentationâ:</p>

\[\kappa(\vec{x}_1, \vec{x}_2) = \vec{x}_1^T\vec{x}_2 \implies \phi(\vec{x}) = \vec{x}\]

<p>Another trivial example assumes that $x_1, x_2 \in \mathbb{R}$. Weâll define the following kernel function, which is equivalent to the feature augmentation that takes the square:</p>

\[\kappa(x_1, x_2) = (x_1 \cdot x_2)^2 \implies \phi(x) = x^2\]

<h5 id="polynomial-kernel">Polynomial kernel</h5>
<p>Letâs assume that $\vec{x}â, \vec{x}â \in\mathbb{R}^3$. Letâs define the kernel function as follows:</p>

\[\begin{align}
\kappa(\vec{x}, \vec{x}') 
    &amp; = \left(x_1 x'_1 + x_2 x'_2 + x_3 x'_3\right)^2 \\
    &amp; = \left( x_1 x'_1 \right)^2
      + \left( x_2 x'_2 \right)^2
      + \left( x_3 x'_3 \right)^2
      + 2 x_1 x'_1 x_2 x'_2
      + 2 x_1 x'_1 x_3 x'_3
      + 2 x_2 x'_2 x_3 x'_3
\end{align}\]

<p>What is the $\phi$ corresponding to this? The inner product that would produce the above would is produced by taking the inner product $\phi(\vec{x})^T\phi(\vec{x}â)$, where $\phi$ is defined as follows:</p>

\[\phi(\vec{x}) = \begin{bmatrix}
\sqrt{2} x_1 x_2 &amp;
\sqrt{2} x_1 x_3 &amp;
\sqrt{2} x_3 x_3 &amp;
x_1^2 &amp;
x_2^2 &amp;
x_3^2
\end{bmatrix}\]

<h5 id="radial-basis-function-kernel">Radial basis function kernel</h5>
<p>The following kernel corresponds to an infinite feature map:</p>

\[\kappa(\vec{x}, \vec{x}') = \exp{\left[-(\vec{x} - \vec{x}')^T(\vec{x} - \vec{x}')\right]}\]

<p>This is called the <em>radial basis function</em> (RBF) kernel.</p>

<p>Consider the special case in which $\vec{x}$ and $\vec{x}â$ are scalars; weâll look at the Taylor expansion of the function:</p>

\[\begin{align}
\kappa(x, x')
&amp; = \exp{\left[-(x - x')^2\right]} \\
&amp; = \exp{\left[-(x^2 + (x')^2 - 2xx')\right]} \\
&amp; = e^{-x^2} e^{-(x')^2} e^{2xx'} \\
&amp; = e^{-x^2} e^{-(x')^2} 
    \sum_{k=0}^\infty{\frac{2^k(x)^k(x')^k}{k!}}
\end{align}\]

<p>We can think of this infinite sum as the dot-product of two infinite vectors, whose $k$-th components are equal to, respectively:</p>

\[e^{-x^2} \sqrt{\frac{2^k}{k!}} x^k
\quad \text{and} \quad
e^{-(x')^2} \sqrt{\frac{2^k}{k!}} (x')^k\]

<p>Although it isnât obvious, weâll state that this kernel cannot be represented as an inner product in finite-dimensional space; it is inherently the product of infinite dimensional vectors.</p>

<h5 id="new-kernel-functions-from-old-ones">New kernel functions from old ones</h5>
<p>We can simply construct a new kernel as a linear combination of old kernels:</p>

\[\begin{align}
\kappa(\vec{x}, \vec{x'})
     &amp; = a\kappa_1(\vec{x}, \vec{x'}) + b\kappa_2(\vec{x}, \vec{x'}),
     &amp; \quad \forall a, b \ge 0 \\

\kappa(\vec{x}, \vec{x'})
    &amp; = \kappa_1(\vec{x}, \vec{x'}) \kappa_2(\vec{x}, \vec{x'}) \\

\kappa(\vec{x}, \vec{x'}) 
    &amp; = \kappa_1(f(\vec{x}), f(\vec{x'})),
    &amp; \quad f: \mathbb{R}^D \rightarrow \mathbb{R}^D \\

\kappa(\vec{x}, \vec{x}') 
    &amp; = f(\vec{x})f(\vec{x}'),
    &amp; \text{in which case } \phi(\vec{x}) = f(\vec{x}) \\
\end{align}\]

<p>Proofs are in the lecture notes. If we accept these, we can combine them to prove much more complex kernel functions.</p>

<h3 id="classifying-with-the-kernel">Classifying with the kernel</h3>
<p>So far, weâve seen how to compute the optimal parameter $\pmb{\alpha}$ using only the kernel, without having to go to the extended feature space. This also allows us to have infinite feature spaces. Now, letâs see how to use all of this to create predictions using only the kernel.</p>

<p>Recall that the classifier predicts $y_n = \phi(\vec{x}_n)^T\vec{w}^*$, and that $\vec{w}^* = \vec{X}^T \pmb{\alpha}^*$. This leads us to:</p>

\[y_m = \phi(\vec{x}_m)^T \phi(\vec{X})^T \pmb{\alpha} 
  = \sum_{n=1}^N{\kappa(\vec{x}_m, \vec{x}_n)\pmb{\alpha}}\]

<h3 id="properties-of-kernels">Properties of kernels</h3>
<p>How can we ensure that there exists a feature augmentation $\phi$ corresponding to a given kernel $\vec{K}$? A kernel function must be an inner-product in some feature space. Mercerâs condition states that we have this iff the following conditions are fulfilled:</p>

<ol>
  <li>$K$ is symmetric, i.e. $\kappa(\vec{x}, \vec{x}â) = \kappa(\vec{x}â, \vec{x})$</li>
  <li>For any arbitrary input set $\set{\vec{x}_n}$ and all $N$, $K$ is positive semi-definite</li>
</ol>

<h2 id="unsupervised-learning">Unsupervised learning</h2>
<p>So far, all weâve done is supervised learning: weâve gone from a training set with features vectors and labels, and we wanted to output a classification or a regression.</p>

<p>There is a second very important framework in ML called <em>unsupervised</em> learning. Here, the training set is only composed of the feature vectors; there are no associated labels:</p>

\[\Strain = \set{(\vec{x}_n)}_{n=1}^N\]

<p>We would then like to learn from this dataset without having access to the training labels. The two main directions in unsupervised learning are:</p>

<ul>
  <li>Representation learning &amp; feature learning</li>
  <li>Density estimation &amp; generative models</li>
</ul>

<p>Letâs take a birdâs eye view of the existing techniques through some examples.</p>

<ol>
  <li><strong>Matrix factorization</strong>: can be used for both supervised and unsupervised. Weâll give an example for each
    <ol>
      <li><strong>Netflix, collaborative filtering</strong>: this is an example of supervised learning. We have a large, sparse matrix with rows of users, columns of  movies, containing ratings. If we can approximate the matrix reasonably well by a matrix of rank one (i.e. outer product of two vectors), then this extracts useful features both for the users and the movies; it might group movies by genres, and users by type.</li>
      <li><strong>word2vec</strong>: this is an example of unsupervised learning. The idea is to map every word from a large corpus to a vector $w_i \in \mathbb{R}^K$, where K is relatively large. This would allow us to represent natural language in some numeric space. To get this, we build a matrix $N\times N$, with $N$ being the number of words in the corpus. We then factorize the matrix by means of two matrices of rank $K$ to give us the desired representation. The results are pretty astounding, as <a href="https://www.tensorflow.org/tutorials/representation/word2vec">this article</a> shows; closely related words are close in the vector space, and itâs easy to get a mapping from concepts to associated concepts (say, countries to capitals).</li>
    </ol>
  </li>
  <li><strong>PCA and SVD</strong> (Principle Component Analysis and Singular Value Decomposition): Features are vectors in $\mathbb{R}^d$ for some d. If we wanted to âcompressâ this down to one dimension (this doesnât have to be an existing feature, it could be a newly generated one from the existing ones), we could ask that the variance of the projected data be as large as possible. This will lead us to PCA, which we compute using SVD.</li>
  <li><strong>Clustering</strong>: to reveal structure in data, we can cluster points given some similarity measure (e.g. Euclidean distance) and the number of clusters we want. We can also ask clusters to be hierarchical (clusters within clusters).</li>
  <li><strong>Generative models</strong>: a generative model models the distribution of the data
    <ol>
      <li><strong>Auto-encoders</strong>: these are a form of compression algorithm, trying to find good weights for encoding and compressing the data</li>
      <li><strong>Generative Adversarial Networks</strong> (GANs): the idea is to use two neural nets, one that tries to generate samples that look like the data we get, and another that tries to distinguish the real samples from the fake ones. The aim is that after sufficient training, a classifier cannot distinguish real samples from artificial ones. If we achieve that, then we have built a good model.</li>
    </ol>
  </li>
</ol>

<h3 id="k-means">K-Means</h3>
<p>A common algorithm for unsupervised learning is called K-means (also called vector quantization in signal processing, or the Baum-Welch algorithm for hidden Markov models). The aim of this algorithm is to cluster the data: we want to find a partition such that every point is exactly one group, such that within a group, the (Euclidean) distance between points is much smaller than across the groups.</p>

<p>In K-means, we find these clusters in terms of cluster centers $\pmb{\mu}$ (also called means). Each center dictates the partition: which cluster a point belongs to depends on which center is closest to the point. In other words, weâre minimizing the distance over all $N$ points and $K$ clusters:</p>

\[\min_{\pmb{\mu}, \vec{z}}{\mathcal{L}_{\text{K-means}}(\vec{z}, \pmb{\mu})}
= \min_{\set{\pmb{\mu}_k}, \set{z_{nk}}}{
    \sum_{n=1}^N{\sum_{k=1}^K{
        z_{nk} \norm{\vec{x}_n - \pmb{\mu}_k}^2
    }}
}\]

<p>The $z_{nk}$ is the k<sup>th</sup> number in the $\vec{z}_n$ vector, which is a one-hot vector encoding the cluster assignment. Every datapoint $\vec{x}_n$ has an associated vector $\vec{z}_n$ of length K, that takes value 1 in the index of the cluster to which $\vec{x}_n$ belongs, and 0 everywhere else. Mathematically, we can write this constraint as:</p>

\[z_{nk} \in \set{0, 1}, \quad \sum_{k=1}^K{z_{nk}} = 1\]

<p>To recap, we have the following vectors:</p>

\[\begin{align}
\vec{z}_n &amp; = \left[z_{n1}, z_{n2}, \dots, z_{nK}  \right]^T \\
\vec{z}   &amp; = \left[\vec{z}_1, \vec{z}_2, \dots, \vec{z}_N\right]^T \\ 
\pmb{\mu} &amp; = \left[\pmb{\mu}_1, \pmb{\mu}_2, \dots, \pmb{\mu}_K\right]^T \\
\end{align}\]

<p>This formulation of the problem gives rise to two conditions, which will give us an intuitive algorithm for solving this iteratively. We see that there are two sets of variables to optimize under: $\pmb{\mu}_k$ and $z_{nk}$. The idea is to fix one and optimize the other.</p>

<p>First, letâs fix the centers $\set{\pmb{\mu}_k}$ and work on the assignments. To minimize the sum:</p>

\[z_{nk} = \begin{cases}
    1, &amp; k = \argmin_{k'}{\norm{\vec{x}_n - \pmb{\mu}_{k'}}^2} \\
    0, &amp; \text{otherwise}
\end{cases}\]

<p>Intuitively, this means that weâre grouping the points by the closest center.</p>

<p>Having computed this, we can fix the assignments $z_{nk}$ to compute optimal centers $\pmb{\mu}_k$. These centers should correspond to the center of the cluster. This minimizes the distance that all points can have to the center.</p>

\[\pmb{\mu}_k = \frac{\sum_{n=1}^N{z_{nk} \vec{x}_n}}{\sum_{n=1}^N{z_{nk}}}\]

<p>Note that in this formulation, $k$ is fixed by $\pmb{\mu}_k$, and $n$ varies in the sum. This gives us some kind of average: the sum of all the positions of the points in the cluster, divided by the number of points in the cluster.</p>

<p>How did we get to this formulation? If we take the derivative of the cost function and set it to zero, and then solve it for $\pmb{\mu}_k$, we get to the above.</p>

\[\nabla_{\pmb{\mu}_k}\mathcal{L}_{\text{K-means}} 
= \sum_{n=1}^N{2 z_{nk} \pmb{\mu}_k - 2 z_{nk} \vec{x}_n}
= 0\]

<p>Solving this confirms that taking the average position in the cluster indeed is the best way to optimize our cost.</p>

<p>These observations give rise to an algorithm:</p>

<ol>
  <li>Initialize the centers $\set{\pmb{\mu}_k^{(0)}}$. In practice, the algorithmâs convergence may depend on this choice, but there is no general best strategy. As such, they can in general be initialized randomly.</li>
  <li>Repeat until convergence:
    <ol>
      <li>Choose $\vec{z}^{(t+1)}$ given $\pmb{\mu}^{(t)}$</li>
      <li>Choose $\pmb{\mu}^{(t+1)}$ given $\vec{z}^{(t+1)}$</li>
    </ol>
  </li>
</ol>

<p>Each of these two steps will only make the partitioning better, if possible. Still, this may get stuck at a local minimum, thereâs no guarantee of it converging to the global optimum; itâs a greedy algorithm.</p>

<h4 id="coordinate-descent-interpretation">Coordinate descent interpretation</h4>
<p>There are other ways to look at K-means. One way is to think of it as a coordinate descent, minimizing a cost function by finding parameters $\pmb{\mu}$ and $\vec{z}$ iteratively:</p>

\[\begin{align}
\vec{z}^{(t+1)}   &amp; = \argmin_{\vec{z}} \cost{\vec{z}, \pmb{\mu}^{(t)}} \\
\pmb{\mu}^{(t+1)} &amp; = \argmin_{\pmb{\mu}} \cost{\vec{z}^{(t+1)}, \pmb{\mu}}
\end{align}\]

<p>This doesnât actually give us much new insight, but itâs a nice way to think about it.</p>

<h4 id="matrix-factorization-interpretation">Matrix factorization interpretation</h4>
<p>Another way to think about it is as a matrix factorization. We can rewrite K-means as the following minimization:</p>

\[\min_{\pmb{\mu}, \vec{z}}{\mathcal{L}_{\text{K-means}}(\vec{z}, \pmb{\mu})} 
= \min_{\vec{M}, \vec{Z}}{\frobnorm{\vec{X}^T - \vec{M} \vec{Z}^T}}^2\]

<p>A few notes on this notation:</p>

<ul>
  <li>$\vec{X}$ is, as always, the $N\times D$ data matrix</li>
  <li>$\vec{M}$ is a $D\times K$ matrix representing the mean, the $\pmb{\mu}_k$ vectors; each column represents a different center</li>
  <li>$\vec{Z}^T$ is the $K\times N$ assignment matrix containing the $\vec{z}_n$ vectors. This means that the columns of $\vec{Z}^T$ are one-hot vectors, i.e. that exactly one element of each column of $\vec{Z}^T$ is 1</li>
  <li>$\vec{X}^T - \vec{M} \vec{Z}^T$ computes a matrix whose rows are vectors from each point to its corresponding cluster center.</li>
  <li>The $\frobnorm{\cdot}$ norm here is the <a href="https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm">Frobenius norm</a>, the sum of the squares of all elements in matrix. Using the Frobenius norm allows us to get a sum of errors squared, which should be reminiscent of most loss functions weâve used so far</li>
</ul>

<p>This is indeed a matrix factorization as weâre trying to find two matrices $\vec{M}$ and $\vec{Z}$ that minimize the above criterion.</p>

<h4 id="probabilistic-interpretation">Probabilistic interpretation</h4>
<p>A probabilistic interpretation of K-means will lead us to <a href="#gaussian-mixture-model-gmm">Gaussian Mixture Models (GMMs)</a>. Having a probabilistic approach is useful because it allows us to account for the model that we think generated the data.</p>

<p>The assumption is that we have generated the data by using $K$ separate $D$-dimensional Gaussian distributions. Each sample $\vec{x}_n$ comes from one of the $K$ distributions uniformly at random. These distributions are assumed to have means $\set{\pmb{\mu}_k}$, and the identity matrix as their covariance matrix (that is, variance 1 in each dimension, and the dimensions are i.i.d).</p>

<p>Letâs write down the likelihood of a sample $\vec{x}_n$. Itâs the Gaussian density function of the cluster to which the sample belongs:</p>

\[p(\vec{x}_n \mid \pmb{\mu}, \vec{z}) = \prod_{k=1}^K{\left(
    \frac{1}{(2\pi)^{D/2}} \exp{\frac{-\norm{\vec{x}_n - \pmb{\mu}_k}^2}{2}}
\right)^{z_{nk}}}\]

<p>The density assuming that we know that the points are from a given $k$ is whatâs inside of the large parentheses. We use $z_{nk}$ in the exponent to cancel out the contributions of the clusters to which $\vec{x}_n$ does not belong, keeping only the contribution of its cluster.</p>

<p>Now, if we want the likelihood for the whole set instead of for a single sample, assuming that the samples are i.i.d, we can take the product over all samples:</p>

\[p(\vec{X}\mid\pmb{\mu},\vec{z}) 
= \prod_{n=1}^N{p(\vec{x}_n \mid \pmb{\mu}, \vec{z})} 
= \prod_{n=1}^N{\prod_{k=1}^K{\left(
    \frac{1}{(2\pi)^{D/2}} \exp{\frac{-\norm{\vec{x}_n - \pmb{\mu}_k}^2}{2}}
\right)^{z_{nk}}}}\]

<p>This is the likelihood, which we want to maximize. We could equivalently minimize the log-likelihood. Weâll also remove the constant factor as it has no influence on our minimization.</p>

\[\begin{align}
-\log{p(\vec{X}\mid\pmb{\mu},\vec{z})} 
    &amp; = -\log{\prod_{n=1}^N{p(\vec{x}_n \mid \pmb{\mu}, \vec{z})}} \\
    &amp; = -\log{\prod_{n=1}^N{\prod_{k=1}^K{\left(
        \exp{\frac{-\norm{\vec{x}_n - \pmb{\mu}_k}^2}{2}}
    \right)^{z_{nk}}}}} \\
    &amp; = \sum_{n=1}^N{\sum_{k=1}^K{z_{nk} \norm{\vec{x}_n - \pmb{\mu}_k}^2}}
\end{align}\]

<p>And this is of course the cost function we were optimizing before.</p>

<h4 id="issues-with-k-means">Issues with K-means</h4>
<ol>
  <li>Computation may be heavy for large values of $N$, $D$ and $K$</li>
  <li>Clusters are forced to be spherical (and cannot be elliptical for instance)</li>
  <li>Each input can belong to only one cluster (this is known as âhardâ cluster assignment, as opposed to âsoftâ assignment which allows for weighted memberships in different clusters)</li>
</ol>

<h3 id="gaussian-mixture-model-gmm">Gaussian Mixture Model (GMM)</h3>
<p>So now that weâve expressed K-means from a probabilistic view, letâs view the probabilistic generalization, which is called a Gaussian Mixture Model.</p>

<h4 id="clustering-with-gaussians">Clustering with Gaussians</h4>
<p>To generalize the previous, what if our data comes from Gaussian sources that arenât perfectly circularly symmetric<sup id="fnref:isotropic" role="doc-noteref"><a href="#fn:isotropic" class="footnote">10</a></sup>, that donât have the identity matrix as variance? A more general solution is to allow for an arbitrary covariance matrix $\pmb{\Sigma}_k$. This will add another parameter that we need optimize over, but can help us more accurately model the data.</p>

<h4 id="soft-clustering">Soft clustering</h4>
<p>Another extension is that we were previously forced to be either from one or another distribution. This is called hard clustering. We can generalize this to soft clustering, where a point can be associated to multiple clusters. In soft clustering, we model $z_n$ as a random variable taking values in $\set{1, \dots, K}$, instead of a one-hot vector $\vec{z}_n$.</p>

<p>This assignment is given by a certain distribution. We denote the prior probability that the sample comes from the k<sup>th</sup> Gaussian $\normal{\pmb{\mu}_k, \pmb{\Sigma}_k}$, by $\pi_k$:</p>

\[p(z_n = k) = \pi_k,
\quad \text{where } \pi_k &gt; 0 \, \forall k \text{ and } \sum_{k=1}^K{\pi_k} = 1\]

<h4 id="likelihood">Likelihood</h4>
<p>What weâre trying to minimize in this extended model is then (still under the assumption that the data is independently distributed from $K$ samples):</p>

\[\begin{align}
p(\vec{X}, \vec{z} \mid \pmb{\mu}, \pmb{\Sigma}, \pmb{\pi}) 
    &amp; = \prod_{n=1}^N{p(z_n \mid \pmb{\pi}) \normal{\vec{x}_n \mid z_n, \pmb{\mu}, \pmb{\Sigma}}} \\
    &amp; = \prod_{n=1}^N{
        \prod_{k=1}^K{\left(\pi_k \normal{\vec{x}_n\mid\pmb{\mu}_k, \pmb{\Sigma}_k}\right)^{z_{nk}}}
    } \\
\end{align}\]

<p>Our notation here maybe isnât the best; weâre still using $z_{nk}$ as an indicator, but also $z_n$ as a random variable, and not a one-hot vector anymore. Therefore, to be clear, we should define $z_{nk} = \mathbb{I}\set{z_n = k}$.</p>

<p>This is the model that weâll use. Itâs not something that we aim to prove or not prove, itâs just what we chose to base ourselves on. Weâll want to optimize over $\pmb{\mu}$ and $\pmb{\Sigma}$.</p>

<p>The $\vec{z}_n$ variable is whatâs known asf a <strong>latent variable</strong>; itâs not something that we observe directly, itâs just something that we use to make our model more complex. The parameters of the model are $\pmb{\theta} := \set{\pmb{\mu}, \pmb{\Sigma}, \pmb{\pi}}$.</p>

<h4 id="marginal-likelihood">Marginal likelihood</h4>
<p>The advantage of treating $z_n$ are latent variables instead of parameters is that we can marginalize them out to get a cost function that doesnât depend on them. If weâre not interested in these latent variables, we can integrate over the latent variables to get the <strong>marginal likelihood</strong>:</p>

\[p(\vec{X}\mid\pmb{\theta}) = 
\prod_{n=1}^N{p(\vec{x}_n \mid \pmb{\theta})} =
\prod_{n=1}^N{\sum_{k=1}^K{\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}}\]

<figure>
    <img alt="2D view of weighted gaussians forming a single distribution" src="/images/ml/gmm-multiple-gaussians.png" />
    <figcaption>Multiple Gaussians form a single distribution in GMM</figcaption>
</figure>

<p>This is a weighted sum of all the models. The weights sum up to one, so we have a valid density. In other words, we are now able to model much more complex distribution functions by building up our distribution from $K$ Gaussian distributions.</p>

<figure>
    <img alt="Weighted Gaussian bell curves" src="/images/ml/weighted-gaussians.svg" />
    <figcaption>The $\pi_k$ factors allow us to weigh multiple Gaussian distributions</figcaption>
</figure>

<p>Assuming that $D, K \ll N$, the number of parameters in the model was $\mathcal{O}(N)$, because we had an assignment $\vec{z}_n$ for each of the $N$ datapoints. Now, assignments are no longer a parameter, so the number of parameters grows in $\mathcal{O}(D^2 K)$, since we have $K$ covariance matrices, which are $D \times D$, and $K$ $D$-dimensional clusters. Under our assumption that $D, K \ll N$, having $\mathcal{O}(D^2 K)$ parameters is much better.</p>

<h4 id="maximum-likelihood-1">Maximum likelihood</h4>
<p>We can optimize the fit of the model by changing the parameters of $\pmb{\theta}$ and optimizing the log likelihood of the above, which is:</p>

\[\hat{\pmb{\theta}} = \max_{\pmb{\theta}}{
    \sum_{n=1}^N{
        \log{\left(
            \sum_{k=1}^K{\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}
        \right)}
    }
}\]

<p>This can be optimized over $\pi_k, \pmb{\mu}_k, \pmb{\Sigma}_k$. Unfortunately, we now have the log of a sum of Gaussians (which are exponentials), which isnât a very nice formula. Weâll use this as an excuse to talk about another algorithm, the EM algorithm.</p>

<h3 id="em-algorithm">EM algorithm</h3>
<p>In GMM, we had the following set of parameters:</p>

\[\pmb{\theta}^{(t)} := \set{
    \set{\pmb{\mu}_k^{(t)}}_{k=1}^K, 
    \set{\pmb{\Sigma}_k^{(t)}}_{k=1}^K, 
    \set{\pi_k^{(t)}}_{k=1}^K
}\]

<p>We wanted to optimize these parameters under the following maximization problem:</p>

\[\max_{\pmb{\theta}} \cost{\pmb{\theta}} = 
\max_{\pmb{\theta}}{
    \sum_{n=1}^N{
        \log{\left(
            \sum_{k=1}^K{\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}
        \right)}
    }
}\]

<p>Note that in this problem, weâre maximizing the cost function instead of minimizing it as weâre used to. This is strictly equivalent to minimizing the negative of this, and weâre using maximizing and minimizing the negative equivalently.</p>

<p>This is not an easy optimization problem, because wee need to optimize the logarithm of a sum over all choices of $\pmb{\theta}$.</p>

<p>The <strong>expectation-maximization (EM) algorithm</strong> provides with a general method to tackle this kind of problem. It uses an iterative two-step algorithm: at every step, we try to go from a set of parameters $\pmb{\theta}^{(t)}$ to a better set of parameters $\pmb{\theta}^{(t+1)}$.</p>

<p>In the following, weâll consider an arbitrary probability distribution $q_n^{(t)}$ over $K$ members. Since it is a probability distribution, we have:</p>

\[q_{nk}^{(t)} \ge 0, \quad \sum_{k=1}^K{q_{nk}^{(t)}} = 1\]

<p>The EM algorithm consists of optimizing for $q_{nk}$ and $\pmb{\theta}$ alternatively. Note that while every step improves the cost, there is no guarantee that this will converge to the global optimum.</p>

<p>We start by initializing $\pmb{\mu}^{(0)}, \pmb{\Sigma}^{(0)}, \pmb{\pi}^{(0)}$. Then, we iterate between the E and M steps until $\cost{\pmb{\theta}}$ stabilizes.</p>

<h4 id="expectation-step">Expectation step</h4>
<p>In the expectation step, we compute how well weâre doing:</p>

\[\cost{\pmb{\theta}^{(t)}} = 
\sum_{n=1}^N{\log{\left(
    \sum_{k=1}^K{\pi_k^{(t)} \normal{\vec{x}_n \mid \pmb{\mu}_k^{(t)}, \pmb{\Sigma}_k^{(t)}}}
\right)}}\]

<p>We can then choose the new $q_{nk}^{(t)}$ values:</p>

\[q_{nk}^{(t)} = \frac{
    \pi_k^{(t)} \normal{\vec{x}_n \mid \pmb{\mu}_k^{(t)}, \pmb{\Sigma}_k^{(t)}}
}{
    \sum_{k=1}^K{\pi_k^{(t)} \normal{\vec{x}_n \mid \pmb{\mu}_k^{(t)}, \pmb{\Sigma}_k^{(t)}}}
}\]

<p>This gives us a new lower bound on the cost:</p>

\[\cost{\pmb{\theta}^{(t+1)}} 
\ge
\sum_{n=1}^N{\sum_{k=1}^K}{q_{nk}^{(t+1)} \log{\left(
    \frac{\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}{q_{nk}^{(t+1)}}
\right)}}\]

<p>Getting a lower bound means that we have a monotonically non-decreasing cost over the steps $t$. Again, this is a good guarantee because weâre maximizing over the cost: it tells us that our E-step improves at every step.</p>

<p>This value is actually the expected value, hence the name of the E-step. Weâll see this in the interpretation section below.</p>

<details><summary><p>Derivation</p>
</summary><div class="details-content">
<p>Due to the concavity of the log function, we can apply <a href="https://en.wikipedia.org/wiki/Jensen%27s_inequality">Jensenâs inequality</a> recursively to the cost function to get:</p>

\[\begin{align}
\log{\left( \sum_{k=1}^K{\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}} \right)} 
    &amp; = \log{\left(
        \sum_{k=1}^K{
            q_{nk}^{(t)}
            \frac{
                \pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}
            }{
                q_{nk}^{(t)}
            }
        } \right)} \\
    
    &amp; \ge \sum_{k=1}^K{
        q_{nk}^{(t)} 
        \log{\frac{
            \pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}
        }{
            q_{nk}^{(t)}
        }}
    } \\
\end{align}\]

<p>Just like in the <a href="https://en.wikipedia.org/wiki/Log_sum_inequality">log-sum inequality</a>, we have equality when the terms in the log are equal for all members of the sum. If that is the case, it means that all these terms are the same scalar, and therefore that the numerator and denominator are proportional:</p>

\[q_{nk}^{(t)} \propto \pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}\]

<p>Since $q_{nk}$ is a probability, it must sum up to 1 so we have:</p>

\[q_{nk}^{(t)} = \frac{
    \pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}
}{
    \sum_{k=1}^K{\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}
}\]
</div></details>

<h4 id="maximization-step">Maximization step</h4>
<p>We update the parameters $\pmb{\theta}$ as follows:</p>

\[\begin{align}
\pmb{\mu}_k^{(t+1)} &amp; := \frac{\sum_n{q_{nk}^{(t)} \vec{x}_n}}{\sum_n{q_{nk}^{(t)}}} \\ \\

\pmb{\Sigma}_k^{(t+1)} &amp; := \frac{
    \sum_n{q_{nk}^{(t)} (\vec{x}_n - \pmb{\mu}_k^{(t+1)}) (\vec{x}_n - \pmb{\mu}_k^{(t+1)})^T}
}{
    \sum_n{q_{nk}^{(t)}}
} \\ \\

\pi_k^{(t+1)} &amp; := \frac{1}{N}\sum_n{q_{nk}^{(t)}}
\end{align}\]

<details><summary><p>Derivation</p>
</summary><div class="details-content">
<p>We had previously let $q_{nk}$ be an abstract, undefined distribution. We now freeze the $q_n^{(t)}$ assignments, and optimize over $\pmb{\theta}$.</p>

<p>In the E step, we derived a lower bound for the cost function. In general, the lower bound is not equal to the original cost. We can however carefully choose $q_{nk}$ to achieve equality. And since we want to maximize the original cost function, it makes sense to maximize this lower bound. Thus, weâll work under this locked assignment of $q_{nk}$ (thus achieving equality for the lower bound). Seeing that we have equality, our objective function (which we want to maximize) is:</p>

\[\prod_{n=1}^N \sum_{k=1}^K{
    q_{nk}^{(t)} 
    \log{\frac{
        \pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}
    }{
        q_{nk}^{(t)}
    }}
}\]

<p>This leads us to maximizing the expression:</p>

\[\sum_{n=1}^N{\sum_{k=1}^K}{
    q_{nk}^{(t)} \left[
        \log{\pi_k} - \log{q_{nk}^{(t)}} + \log{\normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}
    \right]
}\]

<p>The $\pi_k$ should sum up to one, so weâre dealing with a constrained optimization problem. We therefore add a term to turn it into an unconstrained problem. We therefore want to maximize the following over $\pmb{\theta}$:</p>

\[\sum_{n=1}^N{\sum_{k=1}^K}{
    q_{nk}^{(t)} \left[
        \log{\pi_k} - \log{q_{nk}^{(t)}} + \log{\normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}
    \right] + \lambda \sum_{k=1}^K{\pi_k}
}\]

<p>Differentiating with respect to $\pi_k$, and setting the result to 0 yields:</p>

\[\sum_{n=1}^N{q_{nk}^{(t)} \frac{1}{\pi_k} + \lambda} = 0\]

<p>Solving for $\pi_k$ gives us:</p>

\[\pi_k = -\frac{1}{\lambda} \sum_{n=1}^N{q_{nk}^{(t)}}\]

<p>We can choose $\lambda$ so that this leads to a proper normalization ($\pi_k$ summing up to 1); this leads us to $\lambda = -N$. Hence, we have:</p>

\[\pi_k^{(t+1)} := \frac{1}{N}\sum_{n=1}^N {q_{nk}^{(t)}}\]

<p>This is our first update rule. Letâs see how to derive the others. The term $\log{\normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}$ has the form:</p>

\[-\frac{D}{2}\log{(2\pi)}
+\frac{1}{2}\log{\abs{\pmb{\Sigma}^{-1}}}
-\frac{1}{2}(\vec{x} - \pmb{\mu}_k)^T\pmb{\Sigma}^{-1}(\vec{x} - \pmb{\mu}_k)\]

<p>We used the fact that for an invertible matrix, $\abs{\pmb{\Sigma}} = 1/\abs{\pmb{\Sigma}^{-1}}$. Differentiating the cost function with respect to $\pmb{\mu}_k$ and setting the result to 0 yields:</p>

\[\sum_{n=1}^N {q_{nk}^{(t)} \pmb{\Sigma}^{-1}(\vec{x}_n - \pmb{\mu}_k)} = 0\]

<p>We can multiply this by $\pmb{\Sigma}$ on the left to get rid of the $\pmb{\Sigma}^{-1}$, and solve for $\pmb{\mu}_k$ to get:</p>

\[\pmb{\mu}_k^{(t+1)} := \frac{
    \sum_n q_{nk}^{(t)}\vec{x}_n
}{
    \sum_n{q_{nk}^{(t)}}
}\]

<p>Finally, for the $\pmb{\Sigma}$ update rule, we take the derivative with respect to $\pmb{\Sigma}_k^{-1}$ and set the result to 0, yielding:</p>

\[\sum_{n=1}^N{q_{nk}^{(t)} \frac{1}{2} \pmb{\Sigma}^T_k}
- \frac{1}{2}\sum_{n=1}^N{q_{nk}^{(t)}(\vec{x}_n - \pmb{\mu}_k)(\vec{x}_n - \pmb{\mu}_k)^T}
= 0\]

<p>Solving for $\pmb{\Sigma}$ yields:</p>

\[\pmb{\Sigma}_k^{(t+1)} := \frac{
    \sum_n{q_{nk}^{(t)} (\vec{x}_n - \pmb{\mu}_k^{(t+1)}) (\vec{x}_n - \pmb{\mu}_k^{(t+1)})^T}
}{
    \sum_n{q_{nk}^{(t)}}
}\]

<p>Weâre using the following fact, which I wonât go into details to prove:</p>

\[\frac{\partial}{\partial \vec{A}} \log{\abs{\vec{A}}} = \vec{A}^{-T}\]
</div></details>

<h4 id="interpretation">Interpretation</h4>
<p>The original model for GMM was that our data points are i.i.d. from a mixture model with $K$ Gaussian components. This led us to the following choice of prior distribution:</p>

\[\begin{align}
p(\vec{x}_n \mid \pmb{\theta}) 
&amp; = \sum_{k=1}^K {p(\vec{x}_n, z_n = k \mid \pmb{\theta})}
  = \sum_{k=1}^K {p(z_n = k \mid \pmb{\theta}) p(\vec{x}_n \mid z_n = k, \pmb{\theta})} \\ 
&amp; = \sum_{k=1}^K {\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}
\end{align}\]

<p>Note that we can generalize the EM algorithm to other choices of $p(\vec{x}_n, z_n = k \mid \pmb{\theta})$, but that this is the one we used here.</p>

<p>This probability is an expectation based on the prior $\pi_k$. Letâs now look at the posterior distribution of $z_n$, given the datapoints $\vec{x}_n$:</p>

\[\begin{align}
p(z_n = k \mid \vec{x}_n, \pmb{\theta})
    &amp; = \frac{p(z_n = k, \vec{x}_n, \pmb{\theta})}
             {p(\vec{x}_n, \pmb{\theta})}
      = \frac{p(z_n = k, \vec{x}_n \mid \pmb{\theta})}
             {p(\vec{x}_n \mid \pmb{\theta})} \\
    &amp; = \frac{p(z_n = k, \mid \pmb{\theta})p(\vec{x}_n \mid z_n = k, \pmb{\theta})}
             {p(\vec{x}_n \mid \pmb{\theta})} \\ 
    &amp; = \frac{p(z_n = k, \mid \pmb{\theta})p(\vec{x}_n \mid z_n = k, \pmb{\theta})}
             {\sum_{j=1}^K p(z_n = j\mid\pmb{\theta})p(\vec{x}_n\mid z_n = j, \pmb{\theta})} \\ 
    &amp; = \frac{\pi_k \normal{\vec{x} \mid \mu_k, \pmb{\Sigma}_k}}
             {\sum_{j=1}^K{\pi_j \normal{\vec{x} \mid \mu_j, \pmb{\Sigma}_j}}} =: q_{nk}
\end{align}\]

<p>The distribution that we previously just explained as an abstract, unknown distribution is in fact the posterior $p(z_n = k \mid \vec{x}_n, \pmb{\theta})$.</p>

<p>We can now explain why the E step is the <em>expectation</em> step. Assume that we know the $q_{nk}$ (as a thought experiment, imagine a genie told us the assignment probabilities of each sample $\vec{x}_n$ to a component $k$, which is exactly what the $q_{nk}$ quantities are).</p>

<p>As a reminder, the log-likelihood is:</p>

\[\begin{align}
\log{p(\vec{x}_n, z_n = k \mid \pmb{\theta})} 
&amp; = \log{\left(
    p(z_n = k \mid \pmb{\theta}) p(\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k)
\right)} \\
&amp; = \log{\left(
    \pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}
\right)}
\end{align}\]

<p>Given the parameters $\pmb{\theta}$, the expected value of the above log-likelihood, over the distribution of $z_n$, is:</p>

\[\expectsub{z_n}{\log{p(\vec{x}_n, z_n = k \mid \pmb{\theta})}} =
\sum_{k=1}^K{q_{nk} \log{\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}}\]

<p>Summing this over all samples $\vec{x}_n$, we find the cost</p>

\[\sum_{n=1}^N{\sum_{k=1}^K{q_{nk} \log{\pi_k \normal{\vec{x}_n \mid \pmb{\mu}_k, \pmb{\Sigma}_k}}}}\]

<p>This is almost the same as the expression we maximized in the derivation for the M step, modulo the terms $-q_{nk} \log{(q_{nk})}$, which are just constants for the maximization.</p>

<p>With this probabilistic interpretation, can write the whole EM algorithm compactly as:</p>

\[\pmb{\theta}^{(t+1)} = \argmax_{\pmb{\theta}}{\expectsub{p\left(z_n \mid \vec{x}_n, \pmb{\theta}^{(t)}\right)}{\log{p(\vec{x}_n, z_n \mid \pmb{\theta})}}}\]

<h2 id="matrix-factorization">Matrix Factorization</h2>
<p>Matrix factorization is a form of unsupervised learning. A well-known example in which matrix factorization was used is the Netflix prize. The goal was to predict ratings of users for movies, given a very sparse matrix of ratings. Weâll study the method that achieved the best error.</p>

<p>Letâs describe the data a little more formally. Given movies $d = 1, 2, \dots, D$ and users $n = 1, 2, \dots, N$, we define $\vec{X}$ as the $D\times N$ matrix<sup id="fnref:inverted-matrix-notation" role="doc-noteref"><a href="#fn:inverted-matrix-notation" class="footnote">11</a></sup> containing all rating entries; that is, $x_{dn}$ is the rating of the n<sup>th</sup> user for the d<sup>th</sup> movie. We donât have any additional information on the users or on the movies, apart from the ID thatâs been assigned to them. In practice, the matrix was $D=20â000$ and $N=500â000$, and 99.98% unobserved.</p>

<p>We want to give a prediction for all the unobserved entries, so that we can give the top entries (say, top 10 movies) for each user.</p>

<h3 id="prediction-using-a-matrix-factorization">Prediction using a matrix factorization</h3>
<p>We will aim to find $\vec{W}$ and $\vec{Z}$ such that:</p>

\[\vec{X} \approx \vec{W}\vec{Z}^T\]

<p>The hope is to âexplainâ each rating $x_{dn}$ by a numerical representation of the corresponding movie and user.</p>

<p>Here, we have a âtallâ matrix $W\in\mathbb{R}^{D\times K}$, and $\vec{Z}\in\mathbb{R}^{N\times K}$, forming a âflat matrixâ $\vec{Z}^T \in \mathbb{R}^{K\times N}$. In practice, compared to the size of $N$ or $D$, $K$ will be relatively small (maybe 50 or so).</p>

<p>Weâll assign a cost function that weâre trying to optimize:</p>

\[\min_{\vec{W}, \vec{Z}} \cost{\vec{W}, \vec{Z}} 
:= \min_{\vec{W}, \vec{Z}} \frac{1}{2} \sum_{(d, n)\in\Omega}{\left[
    x_{dn} - (\vec{WZ}^T)_{dn}
\right]^2}\]

<p>Here, $\Omega\subseteq [D]\times[N]$ is given. It collects the indices of the observed ratings of the input matrix $\vec{X}$. Our cost function here compares the number of stars $x_{dn}$ a user assigned to a movie, to the prediction of our model $\vec{WZ}^T$, by using mean squares.</p>

<p>To optimize this cost function, we need to know whether it is jointly <em>convex</em> with respect to $\vec{W}$ and $\vec{Z}$, and whether it is <em>identifiable</em> (there is a unique minimum).</p>

<p>We wonât go into the full proof, but the answer is the minimum is not unique. Since $\vec{WZ}^T$ is a product, we could just divide one by 10 and multiply the other by 10 to get a different solution with the same cost.</p>

<p>And in fact, itâs not even convex. We could compute the Hessian, which is:</p>

\[\begin{bmatrix}
0 &amp; 1 \\
1 &amp; 0 
\end{bmatrix}\]

<p>This isnât positive semi-definite, and therefore the product isnât convex.</p>

<p>If we think of $W$ and $Z$ as numbers (or as $1\times 1$ matrices), we can give a simpler explanation, that also gives us the intuition for why this isnât convex.  The function $w\cdot z$ <a href="https://www.wolframalpha.com/input/?i=xy">looks like a saddle function</a>, and therefore isnât convex.</p>

<h3 id="choosing-k">Choosing K</h3>
<p>$K$ is the number of <em>latent features</em>. This is comparable to the K we chose in K-means, defining the number of clusters. Large values of K facilitate overfitting.</p>

<h3 id="regularization-1">Regularization</h3>
<p>We can add a regularizer and minimize the following cost:</p>

\[\cost{\vec{W}, \vec{Z}} =
\frac{1}{2} \sum_{(d, n)\in\Omega}{\left[
    x_{dn} - (\vec{WZ}^T)_{dn}
\right]^2} 
    + \frac{\lambda_w}{2}\frobnorm{\vec{W}}^2
    + \frac{\lambda_z}{2}\frobnorm{\vec{Z}}^2\]

<p>With scalars $\lambda_w, \lambda_z &gt; 0$.</p>

<h3 id="stochastic-gradient-descent">Stochastic gradient descent</h3>
<p>With our cost functions in place, we can look at our standard algorithm for minimization. Weâll define loss as a sum of many individual loss functions:</p>

\[\cost{\vec{W}, \vec{Z}} =
\sum_{(d, n)\in\Omega}{f_{d, n}(\vec{W}, \vec{Z})}
= \sum_{(d, n)\in\Omega}{\frac{1}{2}\left[
    x_{dn} - (\vec{WZ}^T)_{dn}
\right]^2}\]

<p>Letâs derive the stochastic gradient for an individual loss function (which is what we need to compute when doing SGD). Matrix calculus is not easy, but understanding it starts with understanding the following sentence: <em>a gradient with respect to a matrix is a matrix of gradients</em>. If we compute the gradient of a function $f$ with respect to a matrix $\vec{X}\in\mathbb{R}^{D\times N}$, we get a gradient matrix $\vec{g}\in\mathbb{R}^{D\times N}$, where each element $g_{a, b}$ is the derivative of $f$ with respect to the $(a, b)$ element of $\vec{X}$:</p>

\[g_{a, b} = \diff{f}{x_{a, b}}\]

<p>Before we find the stochastic gradient, letâs start by just looking at the dimensions of what weâre going to compute:</p>

\[\begin{align}
\nabla_{\vec{W}}  f_{d, n} &amp; \in \mathbb{R}^{D\times K} \\
\nabla_{\vec{Z}}  f_{d, n} &amp; \in \mathbb{R}^{N\times K}
\end{align}\]

<p>Luckily, weâre not doing the full gradient here, but only the <em>stochastic</em> gradient, which only requires computing a single entry in the gradient matrix. Therefore, for a fixed pair $(d, n)$ (that is, a rating from user $n$ of movie $d$), we will compute a single entry $(dâ, k)$ in the $\vec{W}$ derivative:</p>

\[\left(\nabla_{\vec{W}} f_{d, n}\right)_{(d', k)}
= \diff{f_{d, n}}{w_{d', k}}(\vec{W}, \vec{Z})
= \begin{cases}
    - \left[x_{dn} - (\vec{WZ}^T)_{dn} \right] z_{n, k} &amp; \text{if } d' = d \\
    0 &amp; \text{otherwise}
\end{cases}\]

<p>The same goes for the derivative by $\vec{Z}$. Weâll compute a single entry $(nâ, k)$ in $\nabla_{\vec{W}} f_{d, n}$:</p>

\[\left(\nabla_{\vec{Z}} f_{d, n}\right)_{(n', k)}
= \diff{f_{d, n}}{z_{n', k}}(\vec{W}, \vec{Z})
= \begin{cases}
    - \left[x_{dn} - (\vec{WZ}^T)_{dn} \right] w_{d, k} &amp; \text{if } n' = n \\
    0 &amp; \text{otherwise}
\end{cases}\]

<p>With these, we have the formulation for the whole matrices.</p>

<p>It turns out that computing this is very cheap: $\mathcal{O}(K)$. This is the greatest advantage of using SGD for this. There are no guarantees that this works though; this is still an open research question. But in practice, it works really well.</p>

<p>The update step is then:</p>

\[\vec{W}^{(t+1)} = \vec{W}^{(t)} - \gamma \nabla_{\vec{W}} f_{d, n} \\
\vec{Z}^{(t+1)} = \vec{Z}^{(t)} - \gamma \nabla_{\vec{Z}} f_{d, n} \\\]

<p>With stochastic gradient descent, we only compute the gradient of a single $f_{d, n}$ instead of the whole cost $\mathcal{L}$. Therefore, each step only updates the d<sup>th</sup> row of $\vec{W}$, and the n<sup>th</sup> row of $\vec{Z}$.</p>

<h3 id="alternating-least-squares-als">Alternating least squares (ALS)</h3>
<p>The alternating minimization algorithm alternates between optimizing $\vec{Z}$ and $\vec{W}$. ALS is a special case of this, with square error.</p>

<h4 id="no-missing-entries">No missing entries</h4>
<p>For simplicity, letâs just assume that there are no missing entries in the data matrix, that is $\Omega = [D]\times[N]$ (instead of $\subseteq$). This makes our life a little easier, and weâll be able to find a closed form solution (indeed, if $\Omega$ is the whole set, the problem is pretty easy to solve; if itâs an arbitrary subset, it becomes a NP-hard problem). Our cost is then:</p>

\[\begin{align}
\cost{\vec{W}, \vec{Z}}

&amp; = \frac{1}{2}\sum_{d=1}^D\sum_{n=1}^N{\left[
        x_{dn} - (\vec{WZ}^T)_{dn}
    \right]^2}
    + \frac{\lambda_w}{2} \frobnorm{\vec{W}}^2 
    + \frac{\lambda_z}{2} \frobnorm{\vec{Z}}^2 \\

&amp; = \frac{1}{2}\frobnorm{\vec{X} - \vec{WZ}^T}^2 
    + \frac{\lambda_w}{2} \frobnorm{\vec{W}}^2 
    + \frac{\lambda_z}{2} \frobnorm{\vec{Z}}^2
\end{align}\]

<p>ALS then does a <strong>coordinate descent</strong> to minimize the cost (plus a regularizer). First, we fix $\vec{W}$ and compute the minimum with respect to $\vec{Z}$ (we ignore the other regularizer, as minimization is the same with or without an added constant):</p>

\[\min_{\vec{Z}}{
    \frac{1}{2} \frobnorm{\vec{X} - \vec{WZ}^T}^2} 
    + \frac{\lambda_z}{2} \frobnorm{\vec{Z}}^2\]

<p>Then, we alternate, minimizing $\vec{W}$ and fixing $\vec{Z}$:</p>

\[\min_{\vec{W}}{
    \frac{1}{2}\frobnorm{\vec{X} - \vec{WZ}^T}^2} 
    + \frac{\lambda_w}{2} \frobnorm{\vec{W}}^2\]

<p>These are two least squares problems. The only difference is that weâre searching for a whole matrix in this case, unlike in least squares where we searched for a vector. Still, we can find a closed form for it by setting the gradient with respect to $\vec{W}$ and then $\vec{Z}$ to 0, which will give:</p>

\[\begin{align}
(\vec{Z}^*)^T &amp; := (\vec{W}^T \vec{W} + \lambda_z \vec{I}_K)^{-1} \vec{W}^T \vec{X} \\
(\vec{W}^*)^T &amp; := (\vec{Z}^T \vec{Z} + \lambda_w \vec{I}_K)^{-1} \vec{Z}^T \vec{X}^T \\
\end{align}\]

<p>Note that the regularization helps us make sure that problem indeed is invertible (since weâre adding an identity matrix). This means that we can find a closed form solution if we donât have any missing entries.</p>

<p>The cost of finding the solution in each step is then per column, $\mathcal{O}(N)$ and $\mathcal{O}(D)$, which is not quite as good as the $\mathcal{O}(K)$ with SGD. Additionally, we need to construct $\vec{W}^T\vec{W}$ and $\vec{Z}^T\vec{Z}$, which is $\mathcal{O}(D^2)$. The inversion isnât too bad: weâre only inverting a $K\times K$ matrix, which is much nicer than dealing with $D$ or $N$. Also note that there is no step size to tune, which makes it easier to deal with (though slower!).</p>

<h4 id="missing-entries">Missing entries</h4>
<p>As before, we can derive the ALS updates for the more general setting, where we only have certain ratings $(d, n)\in\Omega$. The idea is to compute the gradient with respect to each group of variables, and set it to zero.</p>

<h3 id="text-representation-learning">Text representation learning</h3>

<h4 id="co-occurrence-matrix">Co-occurrence matrix</h4>
<p>To attempt to get the meaning of words, we can start by constructing co-occurrence counts from a big corpus or text. This is a matrix $\vec{N}$ in which $n_{ij}$ is the number of contexts where word $w_i$ occurs together with word $w_j$. A context is a window of words occurring together (it could be a document, paragraph, sentence, or a window of $n$ words).</p>

<p>For a vocabulary $\nu = \set{w_1, \dots, w_D}$ and context words $w_n = 1, 2, \dots N$, the co-occurrence matrix is a very sparse $D\times N$.</p>

<h4 id="motivation-1">Motivation</h4>
<p>We canât plug string-encoded words directly into our learning models. Can we find a meaningful numerical representation for all of our data? Weâd like to find a mapping, or <strong>embedding</strong>, for each word $w_i$:</p>

\[w_i \mapsto \vec{w}_i \in \mathbb{R}^K\]

<p>To construct a word embedding, we want to find a factorization of the co-occurrence matrix $\vec{N}$. Typically, we actually use $\vec{X} = \log{\vec{N}}$ as the element-wise log of the co-occurrence matrix, i.e. $x_{dn} := \log{(n_{dn})}$. Weâll find a factorization such that:</p>

\[\vec{X} \approx \vec{W}\vec{Z}^T\]

<p>As before, we let $\Omega\subseteq [D] \times [N]$ collect the indices of non-zero counts in $\vec{X}$. In other words, $\Omega$ contains indices of word pairs that have been observed in the same context.</p>

<p>For each pair of observed words $(w_d, w_n) \in \Omega$, weâll try to explain their co-occurrence count by a numerical representation of the two words; the d<sup>th</sup> row of $\vec{W}$ is the representation of a word $w_d$, and n<sup>th</sup> row of $\vec{Z}$ is the representation of a context word $w_n$.</p>

<h4 id="bag-of-words">Bag of words</h4>
<p>The naive approach would be to pick $K$ to be the size of the vocabulary, $K = \abs{\nu}$. We can then encode words $w_i$ as one-hot vectors taking value 1 at index $i$. This works nicely, but has high dimensionality, and cannot capture the order of the words, which is why itâs called the <strong>bag of words</strong> approach.</p>

<p>But we can do this in smarter way. The idea is to pick a much lower $K$, and try to group semantically similar words in this $K$-dimensional space.</p>

<p><img src="/images/ml/semantic-hyperspace.png" alt="Words with different semantic meanings in different areas of hyperspace" /></p>

<h4 id="word2vec">Word2vec</h4>
<p><a href="https://code.google.com/archive/p/word2vec/">word2vec</a> is an implementation of the skip-gram model. This model uses binary classification (like logistic regression) to separate real word pairs $(w_d, w_n)$ appearing together in a context window, from fake word pairs $(w_d, w_{nâ})$.</p>

<p>It does so by computing the inner product score of the words; $\vec{w}_d^T \vec{w}_n$ is real, and must be distinguished from the fake $\vec{w}_d^T \vec{w}_{nâ}$.</p>

<h4 id="glove">GloVe</h4>
<p>In the following, weâll give an overview of the method known as <a href="https://nlp.stanford.edu/projects/glove/">GloVe (Global Vectors)</a>, which offers an alternative to word2vec.</p>

<p>To do this, we do the following cost minimization:</p>

\[\min_{\vec{W}, \vec{Z}} \cost{\vec{W}, \vec{Z}}
:= \min_{\vec{W}, \vec{Z}} \frac{1}{2} \sum_{(d, n)\in\Omega} f_{dn} \left( x_{dn} - (\vec{W}\vec{Z}^T)_{dn} \right)^2\]

<p>The GloVe embedding uses a little trick to weight the importance of each entry. It computes a weight $f_{dn}$ used in the cost above, according to the following function:</p>

\[f_{dn} = \min\set{1, \left(\frac{n_{dn}}{ n_{\text{max}} }\right)^\alpha},
\quad \alpha\in[0, 1], \text{ e.g. } \alpha = \frac{3}{4}\]

<p>Where $n_{\text{max}}$ is a parameter to be tuned, and $n_{dn}$ is the count of $w_d$ and $w_n$ appearing together (not the log, just the normal count). This is a carefully chosen function by the GloVe creators; we can also choose $f_{dn} := 1$ if we donât want to weigh the vectors, but GloVe achieves good results with this choice.</p>

<p><img src="/images/ml/glove-weight-function.png" alt="Glove weight function" /></p>

<p>For $K$, we can just choose a value, say 50, 100 or 200. Trial and error will serve us well here.</p>

<p>We can train the factorization with <a href="#stochastic-gradient-descent">SGD</a> or <a href="#alternating-least-squares-als">ALS</a>.</p>

<h4 id="fasttext">FastText</h4>
<p>This is another matrix factorization approach to learn document or sentence representations. Unlike the two previous approaches, <a href="https://github.com/facebookresearch/fastText">FastText</a> is a supervised algorithm.</p>

<p>A sentence $s_n$ is composed of $m$ words: $s_n = \set{w_1, w_2, \dots, w_m}$. We try to optimize over the following cost function:</p>

\[\min_{\vec{W}, \vec{Z}} \cost{\vec{W}, \vec{Z}} :=
\min_{\vec{W}, \vec{Z}} \sum_{s_n \text{ a sentence}} f(y_n \vec{WZ}^T\vec{x}_n)\]

<p>Where:</p>

<ul>
  <li>$\vec{W}\in\mathbb{R}^{1\times K}$ and $\vec{Z}\in\mathbb{R}^{\abs{\nu}\times K}$ are the factorization</li>
  <li>$\vec{x}_n\in\mathbb{R}^{\abs{\nu}}$ is the bag-of-words representation of sentence $s_n$</li>
  <li>$f$ is a linear classifier loss function, such as the logistic function or hinge loss</li>
  <li>$y_n\in\set{\pm 1}$ is the classification label for sentence $s_n$</li>
</ul>

<h2 id="svd-and-pca">SVD and PCA</h2>

<h3 id="motivation-2">Motivation</h3>
<p><strong>Principal Component Analysis</strong> (PCA) is a popular <em>dimensionality reduction</em> method. Given a data matrix, weâre looking for a way to linearly map the original $D$ dimensions into $K$ dimensions, with $K \le D$. The criteria for a good such mapping is that the $K$-dimensional representation should represent the original data well.</p>

<p>There are different ways to think of PCA:</p>

<ul>
  <li>It <em>compresses data</em> from $K$ to $D$ dimensions</li>
  <li>It <em>decorrelates data</em>, finding a $K$-dimensional space with maximum variance</li>
</ul>

<p>For machine learning, itâs often best not to compress data in this manner, but it may be necessary in certain situations (for reasons of interpretability for example).</p>

<p>In our subsequent discussion, $\vec{X}$ is the $D \times N$ data matrix, whose $N$ columns represent the feature vectors in $D$-dimensional space.</p>

<p>The PCA will be computed from the data matrix $\vec{X}$ using singular value decomposition.</p>

<h3 id="svd">SVD</h3>
<p>The <strong>singular value decomposition</strong> (SVD) of a $D \times N$ matrix $\vec{X}$ is:</p>

\[\vec{X} = \vec{USV}^T\]

<p>The matrices</p>

<ul>
  <li>$\vec{U}$ is a $D \times D$ orthonormal<sup id="fnref:orthonormal" role="doc-noteref"><a href="#fn:orthonormal" class="footnote">12</a></sup> matrix</li>
  <li>$\vec{V}$ is a $N \times N$ orthonormal matrix</li>
  <li>$\vec{S}$ is a $D\times N$ diagonal matrix (with $D$ diagonal entries)</li>
</ul>

<p>One useful property about unitary matrices (like $\vec{U}$ and $\vec{V}$, which are orthonormal, a stronger claim) is that they preserve the norms (they donât change the length of the vectors being transformed), meaning that we can think of them as a rotation. A small proof of this follows:</p>

\[\frobnorm{\vec{Ux}}^2 = \vec{x}^T\vec{U}^T\vec{Ux} = \vec{x}^T\vec{I}\vec{x} = \frobnorm{\vec{x}}^2\]

<p>Weâll assume $D &lt; N$ without loss of generality (we could just take the transpose of $\vec{X}$ otherwise). This is an arbitrary choice, but helps us tell the dimensions apart.</p>

<p>The diagonal entries in $\vec{S}$ are the <em>singular values</em> in descending order:</p>

\[s_1 \ge s_2 \ge \dots \ge s_D \ge 0\]

<p>The columns of $\vec{U}$ and $\vec{V}$ are the <em>left</em> and <em>right singular vectors</em>.</p>

<h3 id="svd-and-dimensionality-reduction">SVD and dimensionality reduction</h3>
<p>Suppose we want to compress a $D\times N$ data matrix $\vec{X}$ to a $K\times N$ matrix $\tilde{\vec{X}}$, where $1 \le K \le D$. Weâll define this transformation from $\vec{X}$ to $\tilde{\vec{X}}$ by the $K\times D$ compression matrix $\vec{C}$. The decompression (or reconstruction) from $\tilde{\vec{X}}$ to $\vec{X}$ is $\vec{R}$.</p>

<p>Can we find good matrices? Our criteria is that the error introduced when compressing and reconstructing should be small, over all choices of compression and reconstruction matrices:</p>

\[\frobnorm{\vec{X} - \vec{R}\vec{C}\vec{X}}^2\]

<p>There are other ways of measuring the quality of a compression and reconstruction, but for the sake of simplicity, weâll stick to this one.</p>

<p>We can actually place a bound on the reconstruction error using the following lemma.</p>

<hr />

<p><strong>Lemma</strong>: For any $D \times N$ matrix $\vec{X}$ and any $D\times N$ rank-K matrix $\hat{\vec{X}}$:</p>

\[\frobnorm{\vec{X} - \hat{\vec{X}}}^2 \ge \frobnorm{\vec{X} - \vec{U}_K \vec{U}_K^T \vec{X}} = \sum_{i \ge K+1}{s_i^2}\]

<p>Where:</p>

<ul>
  <li>$\vec{X} = \vec{U}\vec{S}\vec{V}^T$ is the SVD of $\vec{X}$</li>
  <li>$s_i$ are the singular values of $\vec{X}$</li>
  <li>$\vec{U}_K$ is the $D\times K$ matrix of the first $K$ rows of $\vec{U}$</li>
</ul>

<hr />

<p>If we use $\vec{C} = \vec{U}_K^T$ as our compression matrix, and $\vec{R} = \vec{U}_K$ as the reconstruction matrix, we get a better (or equal) error than  any other choice of reconstruction $\hat{\vec{X}}$. This tells us that the best compression to dimension $K$ is a projection onto the first $K$ columns of $\vec{U}$, which are the first $K$ left singular vectors.</p>

<p>Note that the reconstruction error is the sum of the singular values after the cut-off $K$; intuitively, we can think of the error as coming from the singular values we ignored.</p>

<p>This also tells us that the left singular vectors are ordered in decreasing order of importance. In other words, the above choice of compression uses the <em>principal</em> components, the most important ones. This is what really defines PCA.</p>

<p>The term $\vec{U}_K \vec{U}_K^T \vec{X}$ has another simple interpretation. Let $\vec{S}^{(K)}$ be the $D\times N$ diagonal matrix corresponding to a truncated version of $\vec{S}$. It is of the same size, but only has the $K$ first diagonal values of $\vec{S}$, and is zero everywhere else. We claim that:</p>

\[\vec{U}_K \vec{U}_K^T \vec{X} = \vec{U}_K \vec{U}_K^T \vec{USV}^T = \vec{US}^{(K)}\vec{V}^T\]

<blockquote>
  <p>ð Itâs okay to drop the $K$ subscript on the $\vec{U}$ matrix because $\vec{S}^{(K)}$ already takes care of selecting the first $K$ rows</p>
</blockquote>

<p>This tells us that the <em>best</em> rank $K$ approximation of a matrix is obtained by computing its SVD, and truncating it at $K$.</p>

<h4 id="svd-and-matrix-factorization">SVD and matrix factorization</h4>
<p>Expressing $\vec{X}$ as an SVD allows us to easily get a matrix factorization.</p>

\[\vec{X} 
= \vec{USV}^T 
= \underbrace{\vec{U}}_{\vec{W}} \underbrace{\vec{SV}^T}_{\vec{Z}^T} 
= \vec{WZ}^T\]

<p>This is clearly a special case of the matrix factorization as we saw it previously. In this form, the matrix factorization is perfect equality, and not an approximationâthough in all fairness, this one uses $K = D$. We get a less perfect (but still optimal) factorization with lower values of $K$.</p>

<p>There are two differences from the general case:</p>

<ul>
  <li>We donât need to preselect the rank $K$ from the start. We can compute the full SVD, and control $K$ at any time later, letting it range from 1 to $\min(D, N)$.</li>
  <li>Matrix factorization started with a $\vec{X}$ with many missing entries; the idea was that the factorization should model the existing entries well, so that we can predict the missing values. This is not something that the SVD can do.</li>
</ul>

<p>As weâve discussed previously, this is the <em>best</em> rank K approximation that we can find, as the Frobenius norm of the difference between the approximation and the true value is the smallest possible (sum of the squares of the singular values).</p>

<p>In response to the first point above, note that we still can preselect $K$ and compute the matrix factorization that defines our dimensionality reduction:</p>

\[\vec{X}_K 
= \vec{U}_K \vec{S}^{(K)} \vec{V}^T 
= \underbrace{\vec{U}_K}_{\vec{W}}
  \underbrace{\vec{S}^{(K)}\vec{V}^T}_{\vec{Z}^T} 
= \vec{W}\vec{Z}^T\]

<h3 id="pca-and-decorrelation">PCA and decorrelation</h3>
<p>Assume that we have $N$ $D$-dimensional points in a $D\times N$ matrix $\vec{X}$. We can compute the empirical mean and covariance by:</p>

\[\begin{align}
\bar{\vec{x}} &amp; = \frac{1}{N} \sum_{n=1}^N {\vec{x}_n} \\
\vec{K} &amp; = \frac{1}{N} \sum_{n=1}^N (\vec{x}_n - \bar{\vec{x}}) (\vec{x}_n - \bar{\vec{x}})^T
\end{align}\]

<p>The covariance matrix $\vec{K}$ is a $D \times D$ rank-1 matrix. If our data is from i.i.d. samples then these empirical values will converge to the true values when $N \rightarrow \infty$.</p>

<p>Before we do PCA, we need to <em>center the data around the mean</em>. Letâs assume our data matrix $\vec{X}$ has been preprocessed as such. Using the SVD, we can rewrite the empirical covariance matrix as:</p>

\[N\vec{K} 
= \sum_{n=1}^N {(\vec{x}_n \vec{x}_n^T)} 
= \vec{X}\vec{X}^T 
= \vec{U}\vec{S}\vec{V}^T \vec{V}\vec{S}^T \vec{U}^T 
= \vec{U}\vec{S}\vec{S}^T \vec{U}^T 
= \vec{U}\vec{S}_D^2 \vec{U}^T\]

<p>This works because $\vec{V}$ is an orthogonal matrix, so $\vec{V}^T\vec{V} = I_N$, and $\vec{S}$ is diagonal, so $\vec{SS}^T = S_D^2$, where $S_D^2$ is a $D\times D$ diagonal matrix consisting of the D first columns of $\vec{S}$.</p>

<p>PCA finds orthogonal axes centered at the mean, that represent the most variance, in decreasing order of variance. Starting with orthogonal axes, it finds the rotation $\vec{U}^T$ so that the axes point in the direction of maximum variance. This can be seen in <a href="http://setosa.io/ev/principal-component-analysis/">this visual explanation of PCA</a>.</p>

<p>With this intuition about PCA in mind, letâs try to decompose the covariance again, but this time considering the transformed, compressed data $\tilde{\vec{X}} = \vec{U}_K^T\vec{X}$. The empirical covariance of along this transformed axis is:</p>

\[N \tilde{\vec{K}} 
= \tilde{\vec{X}} \tilde{\vec{X}}^T 
= \vec{U}^T\vec{X}\vec{X}^T\vec{U} 
= \vec{U}^T\vec{US}_D^2\vec{U}^T\vec{U} 
= \vec{S}_D^2\]

<p>Here, the empirical co-variance is <em>diagonal</em>. This means that through PCA, weâve transformed our data to make the various components <strong>uncorrelated</strong>. This gives us some intuition of why it may be useful to first transform the data with the rotation $\vec{U}^T\vec{X}$.</p>

<p>Additionally, by the definition of SVD, the singular values are in decreasing order (so the first one, $s_1$, is the greatest one). Since we have a diagonal matrix as our empirical variance, it means that the variance of the first component is $s_1^2$, which proves the property of PCAâs axes being in decreasing order of variance.</p>

<p>Assume that weâre doing classification. Intuitively, it makes sense that classifying features with a larger variance would be easier (when the variance is 0, all data is the same and it becomes impossible to classify using that component). From this point of view, it makes intuitive sense to only keep the first $K$ rows of $\tilde{\vec{X}}$ when we perform dimensionality reduction; we keep the features that have high variance and are uncorrelated, and we discard all features with variance close to 0 as theyâre hard to classify.</p>

<h3 id="computing-the-svd-efficiently">Computing the SVD efficiently</h3>
<p>To compute the SVD of a matrix $\vec{X}$, we must compute the matrices $\vec{U}$ and $\vec{S}$ Letâs see how we can do this efficiently.</p>

<p>Letâs consider the $D\times D$ matrix $\vec{XX}^T$. As before, since $\vec{V}$ is orthogonal, we can use the SVD to get:</p>

\[\vec{X}\vec{X}^T 
= \vec{USV}^T\vec{VS}^T\vec{U} 
= \vec{USS}^T\vec{U}^T 
= \vec{U} \vec{S}_D^2 \vec{U}^T\]

<p>Let $\vec{u}_j$ denote the j<sup>th</sup> column of $\vec{U}$.</p>

\[\vec{XX}^T \vec{u}_j = \vec{U}\vec{S}_D^2 \vec{U}^T \vec{u}_j = s_j^2 \vec{u}_j\]

<p>We see that the the j<sup>th</sup> column of $\vec{U}$ is the j<sup>th</sup> eigenvector of $\vec{XX}^T$, with eigenvalue $s_j^2$. Therefore, finding the eigenvalues and eigenvectors for $\vec{XX}^T$ gives us a way to compute $\vec{U}$ and $\vec{S}$.</p>

<p>Thereâs a subtle point to be made here about the sign of the eigenvector. If $\vec{u}_j$ is an eigenvector, then so is $-\vec{u}_j$. But if our goal is simply to use that decomposition to do PCA, then it doesnât matter as the sign of the columns of $\vec{U}_K^T$ disappear when computing $\vec{U}_K\vec{U}_K^T$. However, if the goal is simply to do SVD, we must fix some choice of signs, and be consistent in $\vec{V}$.</p>

<p>To compute this decomposition, we can either work with $\vec{X}^T\vec{X}$ or $\vec{XX}^T$. This is practical, as it allows us to pick the smaller of the two and work in dimension $D$ or $N$.</p>

<h3 id="pitfalls-of-pca">Pitfalls of PCA</h3>
<p>Unfortunately, PCA is no miracle cure. The SVD is not invariant under scalings of the features in the original matrix $\vec{X}$. This is why itâs so important to normalize features. But there are many ways of doing this, and the result of PCA is highly dependent on how we do this, and there is a large degree of arbitrariness.</p>

<p>Still, the conventional approach for PCA is to remove the mean and normalize the variance to 1.</p>

<h2 id="neural-networks">Neural Networks</h2>

<h3 id="motivation-3">Motivation</h3>
<p>Weâve seen that simple linear classification schemes like logistic regression can work well, but also have their limitations. They work best when we add well chosen features to the original data matrix, but this can be a difficult task: a priori, we donât know which features are useful.</p>

<p>We could add a ton of polynomial features and hope that some of them are useful, but this quickly becomes computationally infeasible, and leads to overfitting. To mediate the computational complexity, we can use the kernel trick; to solve the feature selection task, we could collaborate with domain experts to pick just a few good features.</p>

<p>But what if we could <em>learn</em> the features instead of having to construct them manually? This is what neural networks allow us to do.</p>

<h3 id="structure">Structure</h3>
<p>As always in supervised learning, we start with a dataset $\Strain = \set{(\vec{x}_n, y_n)}$, with $\vec{x}_n \in\mathbb{R}^D$.</p>

<p>Letâs take a look at a simple multilayer perceptron neural network. It has an <strong>input layer</strong> of size $D$ (one for each dimension of the data), $L$ <strong>hidden layers</strong> of size $K$, and one <strong>output layer</strong>.</p>

<p><img src="/images/ml/nn.svg" alt="Fully connected multilayer perceptron" /></p>

<p>This is a <em>feedforward</em> network: the computation is performed from left to right, with no feedback loop. Each node in the hidden layer $l$ is connected to all nodes in the previous layer $l-1$ via a weighted edge $w_{i, j}^{(l)}$. The number $L$ and size $K$ of hidden layers are hyperparameters to be tuned.</p>

<p>A node outputs a non-linear function of a weighted sum of all the nodes in the previous layer, plus a bias term. For instance, the output of node $j$ at layer $l$ is given by:</p>

\[x_j^{(l)} = \phi\left( \sum_{i=1}^K w_{i, j}^{(l)} x_i^{(l - 1)} + b_j^{(l)} \right)\]

<p>The actual learning consists of choosing all these weights appropriately for the task. The $\phi$ function is called the <strong>activation function</strong>. Itâs very important that this is non-linear; otherwise, the whole neural netâs global function is just a linear function, which defeats the idea of having a complicated, layered function.</p>

<p>A typical choice for this function is the sigmoid function:</p>

\[\phi(x) = \frac{1}{1+e^{-x}}\]

<p>The layered structured of our neural net means that there are $K^2 L$ parameters.</p>

<h3 id="how-powerful-are-neural-nets">How powerful are neural nets?</h3>
<p>This chapter somewhat follows <a href="http://neuralnetworksanddeeplearning.com/chap4.html">Chapter 4 of Nielsenâs book</a>. See that for a more in-depth explanation of this argument.</p>

<p>Weâll state the following lemma without proof. Let $f: \mathbb{R}^D \rightarrow \mathbb{R}$, where its Fourier transform is:</p>

\[\tilde{f}(w) = \int_{\mathbb{R}^D} {f(\vec{x}) e^{-j\omega^T\vec{x}}} d\vec{x}\]

<p>We also assume that:</p>

\[\int_{\mathbb{R}^D} {\abs{\omega} \abs{\tilde{f}(\omega)}} d\omega \le C\]

<p>Essentially, these assumptions just say that our function is âsufficiently smoothâ (the $C$ has to do with the smoothness; as long as it is real, the function can be shown to be continuously differentiable). Then, for all $n \ge 1$, there exists a function $f_n$ of the form:</p>

\[f_n(\vec{x}) = \sum_{j=1}^n {c_j \phi(\vec{x}^T\vec{w}_j + b_j)} + c_0\]

<p>This is a function that is representable by a neural net with one hidden layer with $n$ nodes and âsigmoid-likeâ activation functions (this is more general than just sigmoid, but includes sigmoid) such that:</p>

\[\int_{\abs{\vec{x}} \le r} {(f(\vec{x}) - f_n(\vec{x}))^2} d\vec{x}
\le
\frac{(2Cr)^2}{n}\]

<p>This tells us that the error goes down with a rate of $\frac{1}{n}$. Note that this only guarantees us a good approximation in a ball of radius $r$ around the center. The larger the bounded domain, the more nodes weâll need to approximate a function to the same level (the upper bound grows in terms of $r^2$).</p>

<p>In fact, weâll see that if we have enough nodes in the network, then we can approximate the underlying distribution function. There is no limit, and no real lower bounds, but we do have the property that neural nets have significant expressive power provided that theyâre large enough; weâll give an intuitive explanation of this below.</p>

<h3 id="approximation-in-average">Approximation in average</h3>
<p>Weâll give a simple and intuitive, albeit a little hand-wavy explanation as to why neural nets with sigmoid activation function and at most two hidden layers already have a large expressive power. Weâre searching for an approximation âin averageâ, i.e. so that the integral over the absolute value of the difference is small.</p>

<p>In the following, we let $f: \mathbb{R} \rightarrow \mathbb{R}$ be a scalar function on a bounded domain. This discussion generalizes to functions that are $\mathbb{R}^D \rightarrow \mathbb{R}$, but in these notes weâll just cover the simple scalar function case (see Nielsen book and lecture notes for the generalization).</p>

<p>$f$ is Riemann integrable, meaning that it can be approximated arbitrarily precisely (with error at most $\epsilon$, for arbitrary $\epsilon &gt; 0$) by a finite number of rectangles.</p>

<figure>
    <img src="/images/ml/riemann.png" alt="Riemann integrals of a function" />
    <figcaption>Lower and upper Riemann sums</figcaption>
</figure>

<p>It follows that a finite number of hidden nodes can approximate any such function arbitrarily closely, since we can model rectangles with the function:</p>

\[f(x) = \phi(w(x-b))\]

<p>Indeed, this function takes on value $\frac{1}{2}$ at $x=b$; we can think of this as the âtransition pointâ. The larger the value of the weight $w$, the faster the transition from 0 to 1 happens. So if we set $b=0$, the transition from 0 to 1 happens at $x=0$. At this point, the derivative of $f$ if $w/4$, to the width of the transition is of the order of $4/w$.</p>

<p>All of the above says that we can create a rectangle that jumps from 0 to 1 at $x=a$ and jumps back to 0 at $x=b$, with $a &lt; b$, with the following, taking a very large value for $w$:</p>

\[\phi(w(x-a)) - \phi(w(x-b))\]

<p>A few of these rectangles are graphed below:</p>

<figure>
    <img src="/images/ml/nn-rectangles.png" alt="Plots of rectangles produced by different values of w" />
    <figcaption>Approximate rectangles for $w=10, 20, 50$, respectively</figcaption>
</figure>

<p>This special rectangle formula has a simple representation in the form of a neural net. This network creates a rectangle from $a$ to $b$ with transition weight $w$ and height $h$: the output of the nodes in the hidden layer is $\phi(w(x - a))$ and $\phi(w(x - b))$, respectively.</p>

<p><img src="/images/ml/small-nn.svg" alt="A neural net implementation of the above rectangle function" /></p>

<p>Scaling this up, we can create the number of rectangles we need to do a Riemann approximation of the function.</p>

<p>Note that doing the Riemann integral is rarely, if ever, the best way to approximate a function. We wouldnât want to approximate a smooth function with horrible squares. The argument here isnât that this is an efficient approach, just that NNs are <em>capable</em> of doing this.</p>

<h4 id="other-activation-functions">Other activation functions</h4>
<p>The same argument also holds under other activation functions. For instance, letâs try to work it out with the rectified linear unit (ReLU) function:</p>

\[(x)_+ = \max{\set{0, x}}\]

<p>Let $f(x)$ be the function weâre trying to approximate. The Stone-Weierstrass theorem tells us that for every $\epsilon &gt; 0$, thereâs a polynomial $p(x)$ locally approximating it arbitrarily precisely; that is, for all $x\in[0, 1]$, we have:</p>

\[\abs{f(x) - p(x)} &lt; \epsilon\]

<p>This function $f(x)$ can also be approximated in $L_\infty$ norm by piecewise linear function of the form:</p>

\[q(x) = \sum_{i=1}^m (a_i x + b_i) \mathbb{I}_{\set{r_{i-1} \le x &lt; r_i}}\]

<p>Where $0 = r_0 &lt; r_1 &lt; \dots &lt; r_m = 1$ is a suitable partition of $[0, 1]$. This continuity imposes the constraint:</p>

\[a_i r_i + b_i = a_{i+1}r_i + b_{i+1}, \quad i = 1, \dots, m-1\]

<p>This allows us to rewrite the $q(x)$ function as follows:</p>

\[q(x) = \tilde{a}_1 x + \tilde{b}_1 + \sum_{i = 2}^m{\tilde{a}_i(x - \tilde{b}_i)_+}\]

<p>Where:</p>

\[a_1 = \tilde{a}_1, 
\quad
a_i = \sum_{j=1}^m{\tilde{a}_i},
\quad
\tilde{b}_i = r_{i - 1}\]

<h3 id="popular-activation-functions">Popular activation functions</h3>

<h4 id="sigmoid">Sigmoid</h4>
<p>The sigmoid function $\sigma(x)$ has a domain of $[0, 1]$. The main problem with sigmoid is the gradient for large values of $x$, which goes very close to zero. This is known as the âvanishing gradient problemâ, which may make learning slow.</p>

\[\phi(x) = \sigma(x) = \frac{1}{1+e^{-x}}\]

<h4 id="tanh">Tanh</h4>
<p>The hyperbolic tangent has a domain of $[-1, 1]$. It suffers from the same âvanishing gradient problemâ.</p>

\[\phi(x) = \tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}} = 2\sigma(2x) - 1\]

<h4 id="relu">ReLU</h4>
<p>Rectified linear unit (ReLU) is a very popular choice, and is what works best in most cases.</p>

\[\phi(x) = (x)_+ = \max{\set{0, x}}\]

<p>ReLu is always positive, and is unbounded. A nice property about it is that its derivative is 1 (and does not vanish) for positive values of $x$ It has 0 derivative for negative values, though.</p>

<h4 id="leaky-relu">Leaky ReLU</h4>
<p>Leaky ReLu solves the 0-derivative problem of ReLU by adding a very small slope $\alpha$ (a hyper-parameter that can be optimized) for negative values:</p>

\[\phi(x) = \max{\set{\alpha x, x}}\]

<h4 id="maxout">Maxout</h4>
<p>Finally, maxout is a generalization of ReLU and leaky ReLU. Again, the constants can be optimized. Note that this is quite different from previous cases, where we computed the activation function of a weighted sum. Here, we compute $k \ge 2$ different weighted sums, and then choose the maximum.</p>

\[\phi(\vec{x}) = \max{\set{\vec{x}^T \vec{w}_1 + b_1, \dots, \vec{x}^T \vec{w}_k + b_k}}\]

<h3 id="sgd-and-backpropagation">SGD and Backpropagation</h3>
<p>Remember that the value of every node is computed by:</p>

\[x_j^{(l)} = \phi\left( \sum_{i=1}^K w_{i, j}^{(l)} x_i^{(l - 1)} + b_j^{(l)} \right)\]

<p>Weâd like to optimize this process. Letâs assume that we want to do a regression. Letâs denote the output of the neural net by the function $f$. Our cost function would then simply be:</p>

\[\mathcal{L} = \frac{1}{N} \sum_{n=1}^N{(y_n - f(\vec{x}_n))^2}\]

<p>Weâll omit regularization for the simplicity of our explanation, but it can trivially be added in, without loss of generality.</p>

<p>To optimize our cost, weâd like to do a gradient descent. Unfortunately, this problem is not convex<sup id="fnref:convexity-nn" role="doc-noteref"><a href="#fn:convexity-nn" class="footnote">13</a></sup>, and we expect it to have many local minima, so there is no guarantee of finding an optimal solution. But the good news is that SGD is <em>stable</em> when applied to a neural net, which means that the outcome wonât be too dependent on the training set. SGD is still the state-of-the art in neural nets.</p>

<p>Letâs do a stochastic gradient descent on a single data point. We need to compute the derivative of the cost of this single point, which is:</p>

\[\frac{\partial \mathcal{L}_n}{\partial w_{i, j}^{(l)}},
\qquad
\frac{\partial \mathcal{L}_n}{\partial b_j^{(l)}}\]

<p>We can gain a more general formula by restating the problem in vector form. Generally, a layer of neurons is computed by:</p>

\[\vec{x}^{(l)} 
= f^{(l)}(\vec{x}^{(l - 1)}) 
= \phi\left(
    \left(\vec{W}^{(l)}\right)^T \vec{x}^{(l - 1)} + \vec{b}^{(l)}
\right)\]

<p>The overall function of the neural net is thus something taking the input layer $\vec{x}^{(0)}$, and passing it through all hidden layers:</p>

\[\vec{y} = f(\vec{x}^{(0)}) = f^{(L+1)} \circ \dots \circ f^{(2)} \circ f^{(1)}(\vec{x}^{(0)})\]

<p>To make things more convenient, weâll introduce notation for the linear part of the computation of a layer. The computation below corresponds to our <strong>forward pass</strong>.</p>

\[\begin{align}
\vec{z}^{(l)} &amp; = \left(\vec{W}^{(l)}\right)^T \vec{x}^{(l - 1)} + \vec{b}^{(l)} \\
\vec{x}^{(l)} &amp; = \phi(\vec{z}^{(l)})
\end{align}\]

<p>To be formal, weâll just quickly state that our notation here means that weâre applying $\phi$ component-wise. We see that to compute a $\vec{x}^{(l)}$, we need $\vec{x}^{(l - 1)}$; we therefore need to start from the input layer and compute our way forward, until the last layer, which is why this is called the forward path.</p>

<p>Note that the full chain of computation that gets us to the output in $\mathcal{O}(K^2 L)$, which is not too bad.</p>

<p>For the <strong>backwards pass</strong>, letâs remember that the cost of a single data-point is:</p>

\[\mathcal{L}_n = (y_n - f^{(L+1)} \circ \dots \circ f^{(2)} \circ f^{(1)}(\vec{x}^{(0)}))^2\]

<p>weâll want to compute the following, which is a derivative over both $\partial w_{i, j}^{(l)}$ and $\partial b_j^{(l)}$.</p>

\[\begin{align}
\delta_j^{(l)} 
&amp; = \frac{\partial\mathcal{L}_n}{\partial z_j^{(l)}} \\
&amp; = \sum_k 
    \frac{\partial\mathcal{L}_n}{\partial z_k^{(l+1)}}
    \frac{\partial z_k^{(l+1)}}{\partial z_j^{(l)}}  \\
&amp; = \sum_k \delta_k^{(l+1)} \vec{W}_{j, k}^{(l+1)} \phi'\left( z_j^{(l)} \right)
\end{align}\]

<p>We can write this more compactly using $\odot$, which is the <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">Hadamard product</a> (element-wise multiplication of vectors):</p>

\[\pmb{\delta}^{(l)} = \left(\vec{W}^{(l+1)} \pmb{\delta}^{(l+1)}\right) \odot \phi'\left(\vec{z}^{(l)}\right)\]

<p>Here, to compute a $\pmb{\delta}^{(l)}$, we need $\pmb{\delta}^{(l+1)}$; we must therefore start from the output, and compute our way back to layer 0, which is why we call this a backwards pass. Speaking of which, we will need a $\delta^{(L+1)}$ to start with on the the right side. Therefore, we set:</p>

\[\delta^{(L+1)} = -2\left(y_n - x^{(L+1)}\right) \phi'\left(z^{(L+1)}\right)\]

<p>Note that $z^{(L+1)}$, $\delta^{(L+1)}$ and $x^{(L+1)}$ are denoted as scalars because we assumed that our neural net only had a single output node.</p>

<p>Now that we have both $\vec{z}^{(l)}$ and $\pmb{\delta}^{(l)}$, letâs go back to our initial goal, which is to compute the following:</p>

\[\frac{\partial \mathcal{L}_n}{\partial w_{i, j}^{(l)}}

= \sum_k 
    \frac{\partial\mathcal{L}_n}{\partial z_k^{(l)}}
    \frac{\partial z_k^{(l)}}{\partial w_{i, j}^{(l)}}

= \frac{\partial\mathcal{L}_n}{\partial z_k^{(l)}}
  \frac{\partial z_k^{(l)}}{\partial w_{i, j}^{(l)}}

= \delta_j^{(l)} \vec{x}_i^{(l - 1)}\]

<p>We were able re-express this as a product of these elements that we already have. We were able to drop the sum because changing a single weight $w_{i, j}^{(l)}$ <em>only</em> changes the single sum $z_j$; all other sums stay unchanged, and therefore do not enter into the derivative with respect to $w_{i, j}^{(l)}$. In other words, the term $\frac{\partial z_k^{(l)}}{\partial w_{i, j}^{(l)}}$ is only non-zero when $j=k$.</p>

<p>Weâve thus found the result of the two derivatives we wanted to originally find:</p>

\[\frac{\partial \mathcal{L}_n}{\partial w_{i, j}^{(l)}}
= \delta_j^{(l)} \vec{x}_i^{(l - 1)},
\qquad
\frac{\partial \mathcal{L}_n}{\partial b_j^{(l)}}
= \delta_j^{(l)}\]

<h3 id="regularization-2">Regularization</h3>
<p>To regularize the weights, we can add $\Omega(\vec{W})$ to the cost function. Typically, we donât include bias terms in the regularization (experience shows that it just doesnât work quite as well). Therefore, the regularization term is expressed as something like:</p>

\[\Omega(\vec{W}) = \frac{1}{2} \mu^{(l)} \sum_{l=1}^{L+1} \frobnorm{\vec{W}^{(l)}}^2\]

<p>We have different weights $\mu^{(l)} \ge 0$ for each layer. With the right constants $\mu^{(l)}$, this regularization will favor small weights and can help us avoid overfitting.</p>

<p>Let $\Theta = w_{i, j}^{(l)}$ denote the weight that weâre updating, and let $\eta$ be the step size. Assuming that we use the same weight $\mu^{(l)} = \mu$ for all layers $l$, the gradient descent rule becomes:</p>

\[\Theta^{(t+1)} = \Theta^{(t)} - \eta (\nabla_{\Theta}\mathcal{L} + \mu \Theta^{(t)}) = \Theta^{(t)} (1 - \eta\mu) + \eta \nabla_{\Theta}\mathcal{L}\]

<p>Usual GD deducts the step size $\eta$ times the gradient from the variable, but here, we also decrease the weights by a factor $(1 - \eta\mu)$; we call this <em>weight decay</em>.</p>

<h3 id="dataset-augmentation">Dataset augmentation</h3>
<p>The more data we have, the better we can train. In some instances we can generate new data from the data we are given. For instance, with the classic <a href="https://en.wikipedia.org/wiki/MNIST_database">MNIST database of handwritten digits</a>, we could generate new data by generating rotated characters from the existing dataset. That way, we can also train our network to become invariant to these transformations. We could also add a small amount of noise to our data (by means of compression to degree $K$ with PCA, for instance).</p>

<h3 id="dropout">Dropout</h3>
<p>We define the probability $p_i^{(l)}$ to be the probability of whether or not to keep node $i$ in layer $l$ in the network at a given step. A typical value would be $p_i^{(l)} = 0.8$, which means 80% chance of keeping a given node. This defines a different <em>subnetwork</em> at every step of SGD.</p>

<p>There are many variations of dropout; we talked about dropping nodes, but one could also drop edges. To predict, we can generate $K$ subnets and take the average prediction. Alternatively, we could use the whole network for the prediction, but scaling the output of node $i$ at layer $l$ by $p_i^{(l)}$, which guarantees that the expected input at each node stays the same as during training.</p>

<p>Dropout is a method to avoid overfitting, as nodes cannot ârelyâ on other nodes being present. It allows us to do a kind of model averaging, as thereâs an exponential number of subnetworks, and weâre averaging the training over several of them. Averaging over many models is a standard ML trick, thatâs usually called <em>bagging</em>, which usually leads to improved performance.</p>

<h3 id="convolutional-nets">Convolutional nets</h3>
<p>The basic idea in convolutions is to slide a small window (called a <em>filter</em>) over an array, and computing the dot product between the filter and the elements it overlaps for every position in the array. A good introduction to the subject can be found on <a href="https://eli.thegreenplace.net/2018/depthwise-separable-convolutions-for-machine-learning/">Eli Benderskyâs website</a>.</p>

<h4 id="structure-1">Structure</h4>
<p>Classically, weâve defined our networks as fully connected graphs, where every node in layer $l$ is connected to every node in layer $l-1$. This means that if we have $K$ nodes in each of the two layers, we have $K^2$ edges, and thus parameters, between them. Convolutional nets allow us to have somewhat more sparse networks.</p>

<p>In some scenarios, it makes sense that a more local processing of data should suffice. For instance, convolutions are commonly used in signal processing, were we have a discrete-time system (e.g. audio samples forming an audio stream), which is denoted by $x^{(0)}[n]$. To process the stream we run it through a linear filter $f[n]$, which produces an output $x^{(1)}[n]$. This filter is often âlocalâ, looking at a window of size $k$ around a central value:</p>

\[x^{(1)}[n] = \sum_k f[k]x^{(0)}[n - k]\]

<p>We have the same scenario if we think of a 2D picture, where the signal is $x^{(0)}[n, m]$. The filter can bring out various aspects, either smoothing features by averaging, or enhancing them by taking a so-called âhigh-passâ filter.</p>

\[x^{(1)}[n, m] = \sum_{k, l} f[k, l]x^{(0)}[n-k, m-l]\]

<p>The output $x^{(1)}$ of the filter at position $[n, m]$ only depends on the values of the input $x^{(0)}$ at positions close to $[n, m]$. This is more sparse and local than a fully connected network. This also implies that we use the <em>same filter</em> at every position, which drastically reduces the number of parameters.</p>

<p>In ML, we do something similar. We have a filter with a fixed size $K_1 \times K_2$ with coefficients for every item in the filter. We move the filter over the input matrix, and compute a weighted sum for every position in the matrix.</p>

<h4 id="padding">Padding</h4>
<p>To handle border cases, we can either do:</p>

<ul>
  <li><em>Zero padding</em>, where give the filter a default value (usually 0) when going over the edges.</li>
  <li><em>Valid padding</em>, where we are careful only to run the filter within the bounds of the matrix. This results in a smaller output matrix.</li>
</ul>

<h4 id="channels">Channels</h4>
<p>A picture naturally has at least three channels: every pixel has a red, green and blue component. So a 2D picture can actually be represented as a 3D cube with a depth of 3. Each layer in the depth represents the same 2D image in red, green and blue, respectively. Each such layer is called a <em>channel</em>.</p>

<p>Channels can also stem from the convolution itself. If weâre doing a convolution on a 2D picture, we may want to use multiple filters in the same model. Each of them produces a different output; these outputs are also <em>channels</em>. If we produce multiple 2D outputs with multiple filters, we can stack them into a 3D cube.</p>

<p>As we get deeper and deeper into a CNN, we tend to add more and more channels, but the 2D size of the picture typically gets smaller and smaller, either due to valid padding or subsampling. This leads to a pyramid shaped structure, as below.</p>

<p><img src="/images/ml/cnn.svg" alt="Example of a CNN getting deeper and deeper" /></p>

<h4 id="training-1">Training</h4>
<p>CNNs are different from fully connected neural nets in that only some of the edges are present, and in that they use weight sharing. The former makes our weight matrices sparser, but doesnât require any changes in SGD or backpropagation; the latter requires a small modification in the backpropagation algorithm.</p>

<p>With CNNs, we run backpropagation ignoring that some weights are shared, considering each weight on each edge to be an independent variable. We then sum up the gradients of all edges that share the same weight, which gives us the gradient for the network with weight sharing.</p>

<p>Why we do this may seem a little counterintuitive at first, but weâll attempt to give the mathematical intuition for it. Letâs consider a simple example, in which we let $f(x, y, z)$ be a function from $\mathbb{R}^3 \rightarrow \mathbb{R}$. If we let $g(x, y) = f(x, y, x)$, then $z$ is no longer an independent variable, but is instead fixed to $z = x$. The gradients of $g$ and $f$ are given by:</p>

\[\begin{align}
\nabla g(x, y) &amp; = \left(
    \diff{g(x, y)}{x}, \quad
    \diff{g(x, y)}{y}
\right) \\

\nabla f(x, y, z) &amp; = \left(
    \diff{f(x, y, z)}{x}, \quad
    \diff{f(x, y, z)}{y}, \quad
    \diff{f(x, y, z)}{z} 
\right) \\
\end{align}\]

<p>To compute the gradient of $g$, we can first compute that of $f$, and then realize that:</p>

\[\left(
    \diff{g(x, y)}{x}, \;
    \diff{g(x, y)}{y}
\right)
= 
\left(
    \diff{f(x, y, z)}{x} + \diff{f(x, y, z)}{z}, \;
    \diff{f(x, y, z)}{y}
\right) \\\]

<p>This is a general property: we can add up the derivatives of the shared weights to compute the value of a single derivative.</p>

<h2 id="bayes-nets">Bayes Nets</h2>
<p>Weâve often seen in this course that there are multiple ways of thinking of the same things; for instance, weâve often seen different models as variations of least squares, and seen different ways of getting back to least squares (e.g. the probabilistic approach assuming linear model with Gaussian noise, in which we maximize likelihood, or the approach in which we try to minimize MSE, etc).</p>

<p>But these have often been based on very simple assumptions. To model more complex models of causality, we turn to <em>graphical models</em>. They allow to use a graphical depiction of the relationships between random variables. The most prominent ones are <em>Bayes Nets</em>, <em>Markov Random Fields</em> and <em>Factor Graphs</em>.</p>

<h3 id="from-distribution-to-graphs">From distribution to graphs</h3>
<p>Assume that weâre given a large set of random variables $X_1, \dots, X_D$ and that weâre interested in their relationships (e.g. whether $X_1$ and $X_2$ are independent given $X_3$). It doesnât matter if these are discrete or continuous; weâll just think of them as being discrete, and consider $p(\cdot)$ to be the density.</p>

<p>The most generic way to write down this model is to write it as a generic distribution over a vector of random variables. The chain rule tells us:</p>

\[p(X_1, \dots, X_D) = p(X_1)p(X_2 \mid X_1) \cdots p(X_D \mid X_1, \dots, X_{D-1})\]

<p>In the above, we used the natural ordering $X_1, X_2, \dots, X_D$, but we could just as well have used any of the $D!$ orders: this degree of freedom will be important later. Each variable in this chain rule formulation is conditioned on other variables. For instance, for $D=4$, we have:</p>

\[p(X_1, X_2, X_3, X_4) = p(X_1)p(X_2 \mid X_1)p(X_3 \mid X_1, X_2)p(X_4 \mid X_1, X_2, X_3)\]

<p>A way to represent this expansion of the chain rule is to draw which variables are conditioned on which. In Bayes nets, we draw an arrow from each variable to the variables that are conditioned on it.</p>

<p><img src="/images/ml/bayes-net-1.svg" alt="The Bayes net corresponding to the above" /></p>

<p>Itâs important not to interpret this as causality, because the ordering that we picked chain rule is arbitrary, and could lead to many kind of arrows in the Bayes nets representation. If we just have $D=2$, we could have an arrow from $X_1$ to $X_2$ just as well as the other way around. The arrows are sufficient condition to guarantee dependence, but not a necessary one: they allow for dependence, but donât guarantee it.</p>

<p>Still, when we know that two variables are (conditionally) independent, we can remove edges from the graph. Perhaps we have $p(X_3 \mid X_1, X_2) = p(X_3 \mid X_2)$, in which case we can draw the same graph, but without the edge from $X_1$ to $X_3$.</p>

<p><img src="/images/ml/bayes-net-2.svg" alt="The Bayes net where X1 is independent from X3 conditional on X2" /></p>

<p>This is suddenly much more interesting. Allowing to remove edges between independent variables means that we can have many different graphs. If we couldnât do that, we would always generate the same graph with the chain rule, in the sense that it would always have the same topology; the exact ordering could still change depending on how we apply the chain rule. This is what will allow us to get information on independence from a graph.</p>

<h3 id="cyclic-graphs">Cyclic graphs</h3>
<p><img src="/images/ml/bayes-net-3.svg" alt="Bayes net with a cycle" /></p>

<p>The above net would correspond to the factorization:</p>

\[p(X_1 \mid X_2) p(X_2 \mid X_3) p(X_3 \mid X_1)\]

<p>This is clearly not something that could stem from the chain rule, and therefore, the graph is not valid. In fact, we can state a stronger assertion:</p>

<p>Valid Bayes nets are always DAGs (directed acyclic graphs). There exists a valid distribution (a valid chain rule factorization) <strong>iff</strong> there are no cycles in the graph.</p>

<h3 id="conditional-independence">Conditional independence</h3>
<p>Now, assume that we are given an acyclic graph. Weâd like to find an appropriate ordering in the chain rule in order to find the distribution. A few things to note before we start:</p>

<ul>
  <li>Every acyclic graph has at least one <em>source</em>, that is, a node that has no incoming edges</li>
  <li>Two random variables $X$ and $Y$ are independent if $p(X, Y) = p(X)p(Y)$</li>
  <li>$X$ is independent of $Y$ given $Z$ (which we denote by $X \bot Y \mid Z$) if $p(X, Y \mid Z) = p(X \mid Z) p(Y \mid Z)$</li>
  <li>When we talk about <em>path</em> in the following, we mean an undirected path</li>
</ul>

<p>Letâs look at some simple graphs involving three variables, which will help us clarify the concept of <strong>D-separation</strong>. Weâll always ask the two same questions:</p>

<ul>
  <li>Is $X_1 \bot X_2$ ?</li>
  <li>Is $X_1 \bot X_2 \mid X_3$ ?</li>
</ul>

<p>These examples have names describing whether weâre comparing the head (source) or tail (sink) of the graph when asking about (conditional) independence of $X_1$ and $X_2$.</p>

<h4 id="tail-to-tail">Tail-to-tail</h4>
<figure>
    <img alt="Tail-to-tail Bayes net" src="/images/ml/bayes-net-4.svg" />
    <figcaption>$X_3$ is tail-to-tail with respect to the path from $X_1$ to $X_2$</figcaption>
</figure>

<p>$X_3$ is the source of this graph, so the factorization is:</p>

\[p(X_1, X_2, X_3) = p(X_3)p(X_1 \mid X_3)p(X_2 \mid X_3)\]

<p>Intuitively, $X_1$ and $X_2$ are not independent here, as $X_3$ influences them both; it would be easy to construct something where they are both correlated (e.g. if we let them be fully dictated by $X_3$).</p>

<p>To know if they are conditionally independent, letâs look at the conditioned quantity $p(X_1, X_2 \mid X_3)$:</p>

\[\begin{align}
p(X_1, X_2 \mid X_3) 
&amp; = \frac{p(X_1, X_2, X_3)}{p(X_3)} \\
&amp; = \frac{p(X_3)p(X_1 \mid X_3)p(X_2 \mid X_3)}{p(X_3)} \\
&amp; = p(X_1 \mid X_3) p(X_2 \mid X_3)
\end{align}\]

<p>This proves $X_1 \bot X_2 \mid X_3$.</p>

<p>Letâs try to look at it in more general terms. We have a path between $X_1$ and $X_2$, which in general is worrisome as it may indicate some kind of relationship. But if we know what the value of $X_3$ is, then the knowledge of $X_3$ âblocksâ that dependence.</p>

<h4 id="head-to-tail">Head-to-tail</h4>
<figure>
    <img alt="Head-to-tail Bayes net" src="/images/ml/bayes-net-5.svg" />
    <figcaption>$X_3$ is head-to-tail with respect to the path from $X_1$ to $X_2$</figcaption>
</figure>

<p>$X_1$ is the source of the graph, so the factorization is:</p>

\[p(X_1, X_2, X_3) = p(X_1) p(X_3 \mid X_1) p(X_2 \mid X_3)\]

<p>We can clearly construct a case where $X_1$ and $X_2$ are dependent (e.g. if we pick $X_1 = X_3 = X_2$). So again, $X_1$ and $X_2$ are not independent.</p>

<p>To know if they are conditionally independent, letâs look at the conditioned quantity $p(X_1, X_2 \mid X_3)$:</p>

\[\begin{align}
p(X_1, X_2 \mid X_3)
&amp; = \frac{p(X_1, X_2, X_3)}{p(X_3)} \\
&amp; = \frac{p(X_1) p(X_3 \mid X_1) p(X_2 \mid X_3)}{p(X_3)} \\
&amp; = \frac{p(X_1) p(X_3) p(X_1 \mid X_3) p(X_2 \mid X_3)}{p(X_1) p(X_3)} \\
&amp; = p(X_1 \mid X_3) p(X_2 \mid X_3)
\end{align}\]

<p>This proves $X_1 \bot X_2 \mid X_3$. Again, conditioned on $X_3$ we block the path from $X_1$ to $X_2$.</p>

<h4 id="head-to-head">Head-to-head</h4>
<figure>
    <img alt="Head-to-head Bayes net" src="/images/ml/bayes-net-6.svg" />
    <figcaption>$X_3$ is head-to-head with respect to the path from $X_1$ to $X_2$</figcaption>
</figure>

<p>Here, $X_3$ is the source of the graph, and the factorization is:</p>

\[p(X_1, X_2, X_3) = p(X_1) p(X_2) p(X_3 \mid X_1, X_2)\]

<p>In this example, $X_1$ and $X_2$ are independent. But if we condition on $X_3$, they become dependent. So contrary, to the two previous cases, conditioning on $X_3$ creates a dependence. This phenomenon is called <a href="https://www.eecs.qmul.ac.uk/~norman/BBNs/The_notion_of__explaining_away__evidence.htm"><em>explaining away</em></a>.</p>

<h4 id="d-separation">D-separation</h4>
<p>Instead of determining independence manually as we did above, we can use the two following criteria to decide on (conditional) independence graphically. Weâll give a series of nested definitions that will eventually lead to the criteria. Note that these definitions talk about sets of random variables, but this also applies to single random variables (which we can consider as a set of one).</p>

<ul>
  <li>Let $X$, $Y$ and $Z$ be sets of random variables. $X \bot Y \mid Z$ if $X$ and $Y$ are <em>D-separated</em> by $Z$.</li>
  <li>We say that $X$ and $Y$ are <strong>D-separated</strong> by $Z$ <strong>iff</strong> every path from any element of $X$ to any element of $Y$ is <em>blocked by</em> $Z$.</li>
  <li>We say that a path from node $X$ to node $Y$ is <strong>blocked</strong> by $Z$ <strong>iff</strong> it contains a variable $U$ such that either:
    <ul>
      <li>$U$ is in $Z$ and is <a href="#head-to-tail">head-to-tail</a></li>
      <li>$U$ is in $Z$ and is <a href="#tail-to-tail">tail-to-tail</a></li>
      <li>The node is <a href="#head-to-head">head-to-head</a> and <em>neither</em> this node nor any of its <em>descendants</em> are in $Z$</li>
    </ul>
  </li>
</ul>

<p><strong>Descendant</strong> means that there exist a <em>directed</em> path from parent to descendant.</p>

<h4 id="examples">Examples</h4>
<p>Letâs do lots of examples to make sure that we understand this. Weâll be working on the following graph, and ask about different combinations of random variables.</p>

<p><img src="/images/ml/bayes-net-7.svg" alt="Example of a Bayes net containing all 3 kinds of relationship" /></p>

<ul>
  <li>
    <p>Is $X_1 \bot X_3 \mid X_2$?</p>

    <p>First, letâs try to understand the idea of <em>paths</em>. There is only one path between $X_1$ and $X_3$: from $X_1$ to $X_2$ to $X_3$. In general, it doesnât have to be a directed path, although this one happens to be so.</p>

    <p>For every such pathâand in this case, there is just one, so itâs easyâ, weâll check if it contains is a variable that is head-tail in $Z = \set{X_2}$. This is the case, and $X_2$ is head-to-tails with respect to this path. This means that the only path is <em>blocked</em> by $X_2$, and therefore that $X_1 \bot X_3 \mid X_2$.</p>
  </li>
  <li>
    <p>Is $X_3 \bot X_1 \mid X_2$?</p>

    <p>This is the same as above, except that the independence is stated in reverse. We know that independence is commutative, and it also follows from the D-separation lemma, since paths are not directed.</p>
  </li>
  <li>
    <p>Is $X_4 \bot X_1 \mid X_2$?</p>

    <p>Thereâs only one path from $X_4$ to $X_1$. Weâll check if it contains a variable $U\in Z = \set{X_2}$: the only node that fits this is quite trivially $U = X_2$, which is head-to-tail with respect to the path. It therefore blocks the path, and we have $X_4 \bot X_1 \mid X_2$.</p>
  </li>
  <li>
    <p>Is $X_4 \bot X_1 \mid X_3$?</p>

    <p>Thereâs only one path from $X_4$ to $X_1$, and it doesnât contain any head-to-tail or tail-to-tail nodes in $Z$. It does however contain a head-to-head node, $X_3$. While $X_3$ has no descendants, we still have $X_3 \in Z = \set{X_3}$, and therefore, the lemma does not apply. The answer is therefore no.</p>
  </li>
  <li>
    <p>Is $X_4 \bot X_1 \mid X_3, X_2$?</p>

    <p>In this case, we have $Z = \set{X_2, X_3}$. Thereâs still only one path from $X_4$ to $X_1$. We saw previously that we cannot apply the lemma with $X_3$, so letâs try with $X_2$: this node is head-to-tail with respect to the path, and belongs to $Z$. Therefore, $X_2$ blocks the path, and we have a D-separation, which means that the answer is yes.</p>
  </li>
  <li>
    <p>Is $X_4 \bot X_1$?</p>

    <p>Thereâs only one path between them, which is blocked by $X_3$ which is head-to-head, and $X_3 \notin Z = \emptyset$, and it has no descendants (so none of them are in $Z$). Therefore, the answer is yes.</p>
  </li>
</ul>

<h3 id="markov-blankets">Markov blankets</h3>
<p>Given a node $X_i$, we can ask if there is a minimal set so that every random variable outside this set is conditionally independent of $X_i$. The answer to this is the Markov blanket.</p>

<p>The <strong>Markov blanket</strong> of $X_1$ is the set of parents, children, and co-parents of $X_i$. By co-parent, we mean other parents of the children of $X_i$.</p>

<figure>
    <img src="/images/ml/markov-blanket.svg" alt="Example of a Markov blanket" />
    <figcaption>The Markov blanket of $X_1$ is colored in gray</figcaption>
</figure>

<h3 id="sampling-and-marginalizing">Sampling and marginalizing</h3>
<p>So far weâve seen how to recognize independence relationships from a Bayes net. Another possible task is to sample given a Bayes net, or to compute marginals from a Bayes net. As it turns out, these two tasks are related.</p>

<p>First, letâs assume we know how to sample from a Bayes net. Letâs assume that we have a set of $D$ binary random variables, $X_i \in \set{0, 1}$. We can then generate $N$ independent samples $\set{\vec{x}_n}_{n=1}^N = \set{(X_{1n}, \dots, X_{Dn})}_{n=1}^N$. To get the marginal for $X_i$, we estimate $\expect{X_i}$ by computing the empirical quantity $\frac{1}{N}\sum_{n=1}^N x_{in}$. As $N\rightarrow\infty$, we know that this converges to the true mean.</p>

<p>Conversely, assume we know how to efficiently compute marginals from any Bayes net, and that weâd like to sample from the joint distribution. We can then compute the marginal of the net with respect to a certain variable $X_i$, and then flip a coin according to the marginal probability weâve computed.</p>

<p>The problem is that neither of these can be done efficiently, except for some special cases. The chain rule tells us that $X_i$ is conditioned on $X_1, \dots, X_{i-1}$, which means weâd need to have a table of $2^{i-1}$ conditional probabilities. In general, the storage requirement is exponential in the largest number of parents any node in the Bayes net has.</p>

<h3 id="factor-graphs">Factor graphs</h3>
<p>Assume we have a function $f$ that can be factorized as follows:</p>

\[f(X_1, X_2, X_3, X_4) = f_a(X_1) f_b(X_2, X_3) f_c(X_3, X_4)\]

<p>A very natural representation is another graphical representation. Each variable $X_i$ gets a node, and each factor $f_j$ gets a factor node.</p>

<p><img src="/images/ml/factor-graph.svg" alt="Factor graph of the above function" /></p>

<p>If the factor graph is a bipartite tree (i.e. no cycles), then we can marginalize very efficiently with a <a href="https://en.wikipedia.org/wiki/Factor_graph#Message_passing_on_factor_graphs">message-passing algorithm</a>, which runs in linear time in the number of edges, instead of exponential complexity in the size of the network.</p>

<p>Sadly, very few probability distributions do us the favor of producing a tree in the factor graph. But it turns out that there many probability distributions where the factorizationâs terms are fairly small, and despite cycles in the graph, we can still run the algorithm and it works approximately.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:here-be-dragons" role="doc-endnote">
      <p>Iâve done my best to respect this notational convention everywhere in these notes, but a few mistakes may have slipped through. If you see any, please correct me in the comments below!Â <a href="#fnref:here-be-dragons" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:optimality-linear-mse" role="doc-endnote">
      <p>To understand why, see the sections on <a href="#optimality">optimality conditions</a> and on <a href="#single-parameter-linear-regression">single parameter linear regressions</a>Â <a href="#fnref:optimality-linear-mse" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:mse-is-convex" role="doc-endnote">
      <p>We accept this without a formal proof for now, but it should be clear from the <a href="#convexity">section on convexity</a> that MSE is convex. Otherwise, the section on <a href="#multiple-parameter-linear-regression">normal equations for multi-parameter linear regression</a> has more complete proofs.Â <a href="#fnref:mse-is-convex" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:convergence-prob-distrib" role="doc-endnote">
      <p>Convergence in probability means that the actual realizations of $X$ converges to that of $Y$ (i.e. $\mathbb{P}(X=Y)\rightarrow 1$), while convergence in distribution means that the distribution function of $X$ converges to that of $Y$ (but without any guarantee that the actual realizations will be the same). Convergence in probability implies convergence in distribution, and is therefore a stronger assertion.Â <a href="#fnref:convergence-prob-distrib" class="reversefootnote" role="doc-backlink">&#8617;</a>Â <a href="#fnref:convergence-prob-distrib:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:fisher-information" role="doc-endnote">
      <p>Fisher information is a way of measuring the information that a random variable carries about an unknown parameter. See <a href="https://en.wikipedia.org/wiki/Fisher_information">the Wikipedia article for Fisher information</a>.Â <a href="#fnref:fisher-information" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:data-subset-training-data" role="doc-endnote">
      <p>We say âdata subsetâ here, because, as <a href="#splitting-the-data">weâll see later</a>, the data available to the learning algorithm $\mathcal{A}$ is often a subset of the whole dataset, called the training set. In this subsection, $S$ actually corresponds to $\Strain$.Â <a href="#fnref:data-subset-training-data" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:squishification-function" role="doc-endnote">
      <p>Because this function squeezes inputs in $(-\infty, \infty)$ into a true probability in $[0, 1]$, I like the name âsquishification functionâ that <a href="https://www.youtube.com/watch?v=aircAruvnKk">3Blue1Brown uses</a>, but other people also call it a âsquashingâ function.Â <a href="#fnref:squishification-function" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:logistic-implementation" role="doc-endnote">
      <p>Note that this function applies the exponential function to rather large values, so we should be careful when implementing this.Â <a href="#fnref:logistic-implementation" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:binary-logistic-regression" role="doc-endnote">
      <p>We have only studied binary logistic regression, which is the basic form of logistic regression. Generalized linear models will lead us to more complex extensions, such as <a href="https://en.wikipedia.org/wiki/Multinomial_logistic_regression">multinomial logistic regression</a>.Â <a href="#fnref:binary-logistic-regression" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:isotropic" role="doc-endnote">
      <p>The word that expresses this idea is <em>isotropic</em>, meaning âuniform in all directionsâ.Â <a href="#fnref:isotropic" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:inverted-matrix-notation" role="doc-endnote">
      <p>Usually, the data matrix is $N \times D$, but here, we define it as the transpose, a $D \times N$ matrix. Donât ask me why, because I have no clue ð¤·ââï¸Â <a href="#fnref:inverted-matrix-notation" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:orthonormal" role="doc-endnote">
      <p>The columns of an orthonormal matrix are orthogonal and unitary (they have have norm 1). The transpose is equal to the inverse, meaning that if $\vec{U}$ is orthogonal, then $\vec{U}^T\vec{U} = \vec{UU}^T = \vec{I}$Â <a href="#fnref:orthonormal" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:convexity-nn" role="doc-endnote">
      <p>The cost function is no longer convex as $f$ is now a forward pass through a neural net, including multiple applications of the non-linear activation functionÂ <a href="#fnref:convexity-nn" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET